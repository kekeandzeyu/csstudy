<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#6860F6" data-link-color="#307FFF" data-resizable-sidebar="true" data-sidebar-width="260"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2024-10-28T10:27:42.0123314"><title>Rust Programming | Computer Science Study Notes</title><script type="application/json" id="virtual-toc-data">[{"id":"-i4c74b_4","level":0,"title":"1 Program Analysis","anchor":"#-i4c74b_4"},{"id":"1-1-dynamic-analysis","level":1,"title":"1.1 Dynamic Analysis","anchor":"#1-1-dynamic-analysis"},{"id":"1-2-static-analysis","level":1,"title":"1.2 Static Analysis","anchor":"#1-2-static-analysis"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b419/app.css" rel="stylesheet"><link href="static/custom.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="Computer-Science-Study-Notes/photo.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Rust Programming | Computer Science Study Notes"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Computer Science Study Notes Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/rust-programming.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Rust Programming | Computer Science Study Notes"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/rust-programming.html#webpage",
    "url": "writerside-documentation/rust-programming.html",
    "name": "Rust Programming | Computer Science Study Notes",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Computer Science Study Notes Help"
}</script><!-- End Schema.org --></head><body data-id="Rust-Programming" data-main-title="Rust Programming" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs=""><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Computer Science Study Notes  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Rust-Programming" id="Rust-Programming.topic">Rust Programming</h1><section class="chapter"><h2 id="-i4c74b_4" data-toc="-i4c74b_4">1 Program Analysis</h2><p id="-i4c74b_5"><span id="-i4c74b_9"><font style="color:#8a2be2">Types of program analysis</font></span></p><ul class="list _bullet" id="-i4c74b_6"><li class="list__item" id="-i4c74b_10"><p id="-i4c74b_12"><span id="-i4c74b_13"><font style="color:#ff00ff">Dynamic analysis:</font></span> run the program and watch what it does.</p></li><li class="list__item" id="-i4c74b_11"><p id="-i4c74b_14"><span id="-i4c74b_15"><font style="color:#ff00ff">Static analysis:</font></span> read the source code.</p></li></ul><section class="chapter"><h3 id="1-1-dynamic-analysis" data-toc="1-1-dynamic-analysis">1.1 Dynamic Analysis</h3><ul class="list _bullet" id="-i4c74b_16"><li class="list__item" id="-i4c74b_36"><p id="-i4c74b_40">Run the program, watch what it does, and look for problematic behavior.</p></li><li class="list__item" id="-i4c74b_37"><p id="-i4c74b_41">Can find problems, but only if the program exhibits problematic behavior on the inputs you use to test. (Separately, some tools only check for certain types of issues.)</p></li><li class="list__item" id="-i4c74b_38"><p id="-i4c74b_42">Commonly combined with techniques to run the program with lots of different test inputs (e.g. fuzzing), yet this still can&rsquo;t give us any assurances that code is bug-free</p></li><li class="list__item" id="-i4c74b_39"><p id="-i4c74b_43">Dynamic analysis is great! Test your code and understand the limitations!</p></li></ul><p id="-i4c74b_17"><span id="-i4c74b_44"><font style="color:#8a2be2">Valgrind</font></span></p><section class="procedure-steps"><h3 id="-i4c74b_18" data-toc="-i4c74b_18">Valgrind</h3><ol class="list _decimal"><li class="list__item" id="-i4c74b_45"><p id="-i4c74b_49">Takes in compiled binary (executable).</p></li><li class="list__item" id="-i4c74b_46"><p id="-i4c74b_50">Disassembles binary into intermediate, assembly/assembly-like representation.</p></li><li class="list__item" id="-i4c74b_47"><p id="-i4c74b_51">Turns this ^ back into machine code (re-compiles); one small block at a time during execution.</p></li><li class="list__item" id="-i4c74b_48"><p id="-i4c74b_52">While &quot;instrumenting&quot;, modifying instructions or inserting &quot;analysis&quot; code.</p></li></ol></section><div class="code-collapse" data-lang="c" data-is-expanded="false" data-synopsis="int main() {">
                int main() {
                    char *buf = (char *)malloc(8);
                    buf[16] = 'a';
                }
            </div><p id="-i4c74b_20">Compiler:</p><div class="code-collapse" data-lang="plaintext" data-is-expanded="false" data-synopsis="mov edi, 8">
                mov edi, 8
                call malloc
                mov QWORD PTR [rbp-8], rax

                mov rax, QWORD PTR [rbp-8]
                add rax, 16
                mov BYTE PTR [rax], 97
            </div><p id="-i4c74b_22">Valgrind</p><div class="code-collapse" data-lang="plaintext" data-is-expanded="false" data-synopsis="mov edi, 8">
                mov edi, 8
                call valgrind_malloc
                mov QWORD PTR [rbp-8], rax
                # record memory write ^

                mov rax, QWORD PTR [rbp-8]
                # record memory read
                add rax, 16
                mov BYTE PTR [rax], 97
                # record memory write ^
                # Invalid write of size 4
            </div><p id="-i4c74b_24">Pros &amp; Cons</p><ul class="list _bullet" id="-i4c74b_25"><li class="list__item" id="-i4c74b_53"><p id="-i4c74b_55">Works with any binary compiled by any compiler (even if you don&rsquo;t have source code available!)</p></li><li class="list__item" id="-i4c74b_54"><p id="-i4c74b_56">But not a lot of information is available in binaries.</p><p id="-i4c74b_57">For example, cannot detect stack-based buffer overflows!</p></li></ul><p id="-i4c74b_26"><span id="-i4c74b_58"><font style="color:#8a2be2">LLVM Sanitizers</font></span></p><ul class="list _bullet" id="-i4c74b_27"><li class="list__item" id="-i4c74b_59"><p id="-i4c74b_62">Instrument source code</p></li><li class="list__item" id="-i4c74b_60"><p id="-i4c74b_63">Implemented as part of the LLVM compiler suite (e.g. clang)</p></li><li class="list__item" id="-i4c74b_61"><p id="-i4c74b_64">Because more information is available pre-compilation, there is a lot more analysis that sanitizers can do (and they&rsquo;re also easier to implement)</p></li></ul><p id="-i4c74b_28"><span id="-i4c74b_65"><font style="color:#8a2be2">Types of sanitizers</font></span></p><ul class="list _bullet" id="-i4c74b_29"><li class="list__item" id="-i4c74b_66"><p id="-i4c74b_71"><span id="-i4c74b_72"><font style="color:#ff00ff">AddressSanitizer:</font></span> Finds use of improper memory addresses: out of bounds memory accesses, double free, use after free</p></li><li class="list__item" id="-i4c74b_67"><p id="-i4c74b_73"><span id="-i4c74b_74"><font style="color:#ff00ff">LeakSanitizer:</font></span> Finds memory leaks</p></li><li class="list__item" id="-i4c74b_68"><p id="-i4c74b_75"><span id="-i4c74b_76"><font style="color:#ff00ff">MemorySanitizer:</font></span> Finds use of uninitialized memory</p></li><li class="list__item" id="-i4c74b_69"><p id="-i4c74b_77"><span id="-i4c74b_78"><font style="color:#ff00ff">UndefinedBehaviorSanitizer:</font></span> Finds usage of null pointers, integer/float overflow, etc</p></li><li class="list__item" id="-i4c74b_70"><p id="-i4c74b_79"><span id="-i4c74b_80"><font style="color:#ff00ff">ThreadSanitizer:</font></span> Finds improper usage of threads</p></li></ul><p id="-i4c74b_30"><span id="-i4c74b_81"><font style="color:#8a2be2">Fundamental limitation of dynamic analysis</font></span></p><ul class="list _bullet" id="-i4c74b_31"><li class="list__item" id="-i4c74b_82"><p id="-i4c74b_84">Dynamic analysis can only report bad behavior that actually happened</p></li><li class="list__item" id="-i4c74b_83"><p id="-i4c74b_85">If your program worked fine with the input you provided, but it might do bad things in certain edge cases, dynamic analysis cannot tell you anything about</p></li></ul><div class="code-collapse" data-lang="c" data-is-expanded="false" data-synopsis="#include &lt;stdio.h&gt;">
                #include &lt;stdio.h&gt;
                #include &lt;string.h&gt;

                int main() {
                    char s[100];
                    int i;
                    printf(&quot;\nEnter a string : &quot;); // The size of the input string may get larger than 100!
                    gets(s);
                    for (i = 0; s[i] != '\0'; i++) {
                        if(s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z') {
                            s[i] = s[i] -32;
                        }
                    }
                    printf(&quot;\nString in Upper Case = %s&quot;, s);
                    return 0;
                }
            </div><p id="-i4c74b_33"><span id="-i4c74b_86"><font style="color:#8a2be2">Fuzzing</font></span></p><figure id="-i4c74b_34"><img alt="Fuzzing" src="Computer-Science-Study-Notes/r1-1-1.png" title="Fuzzing" width="5648" height="2333"></figure><ul class="list _bullet" id="-i4c74b_35"><li class="list__item" id="-i4c74b_87"><p id="-i4c74b_91">Very simple but extremely effective</p></li><li class="list__item" id="-i4c74b_88"><p id="-i4c74b_92">Most common fuzzers: <a href="https://github.com/google/AFL" id="-i4c74b_93" data-tooltip="AFL" data-external="true" rel="noopener noreferrer">AFL (archived)</a> and <a href="https://llvm.org/docs/LibFuzzer.html" id="-i4c74b_94" data-tooltip="libfuzzer" data-external="true" rel="noopener noreferrer">libfuzzer</a></p></li><li class="list__item" id="-i4c74b_89"><p id="-i4c74b_95">Still, cannot provide any guarantees that a program is bug-free (if the fuzzer didn&rsquo;t find anything in 24 hours, maybe we just didn&rsquo;t run it long enough)</p></li><li class="list__item" id="-i4c74b_90"><p id="-i4c74b_96">Google <a href="https://github.com/google/oss-fuzz" id="-i4c74b_97" data-tooltip="OSS-Fuzz" data-external="true" rel="noopener noreferrer">OSS-Fuzz</a> is a large cluster that fuzzes open-source software 24/7</p></li></ul></section><section class="chapter"><h3 id="1-2-static-analysis" data-toc="1-2-static-analysis">1.2 Static Analysis</h3><p id="-i4c74b_98"><span id="-i4c74b_112"><font style="color:#8a2be2">linting</font></span></p><ul class="list _bullet" id="-i4c74b_99"><li class="list__item" id="-i4c74b_113"><p id="-i4c74b_116">Linters employ very simple techniques (e.g. ctrl+f) to find obvious mistakes.</p></li><li class="list__item" id="-i4c74b_114"><p id="-i4c74b_117">The person running the linter can configure a set of rules to enforce.</p><ul class="list _bullet" id="-i4c74b_118"><li class="list__item" id="-i4c74b_119"><p id="-i4c74b_121">Rules are intended to improve the style of the codebase.</p></li><li class="list__item" id="-i4c74b_120"><p id="-i4c74b_122">Just because there is a linter error doesn&rsquo;t mean the code is broken (e.g. it's possible to call <code class="code" id="-i4c74b_123">strcpy()</code> without introducing bugs, but many linters will complain if you call it)</p></li></ul></li><li class="list__item" id="-i4c74b_115"><p id="-i4c74b_124">Common C/C++ linter: <a href="https://clang.llvm.org/extra/clang-tidy/" id="-i4c74b_125" data-tooltip="clang-tidy" data-external="true" rel="noopener noreferrer">clang-tidy</a></p></li></ul><p id="-i4c74b_100"><span id="-i4c74b_126"><font style="color:#8a2be2">Dataflow Analysis</font></span></p><p id="-i4c74b_101">We can trace through how the program might execute, keeping track of possible variable values</p><p id="-i4c74b_102"><span id="-i4c74b_127"><font style="color:#cd5c5c">Example 1</font></span></p><div class="code-collapse" data-lang="c" data-is-expanded="false" data-synopsis="void printToUpper(const char *str) {">
                void printToUpper(const char *str) {
                    char *upper = strdup(str);
                    for (int i = 0; str[i] != '\0'; i++) {
                        if(str[i] &gt;= 'a' &amp;&amp; str[i] &lt;= 'z') {
                            upper[i] = str[i] - ('a' - 'A');
                        }
                    }
                    printf(&quot;%s\n&quot;, upper);
                    free(upper);
                }

                int main(int argc, char *argv[]) {
                    printf(&quot;Enter a string to make uppercase, or type \&quot;quit\&quot; to quit:\n&quot;);
                    char input[512];
                    // safely read input string
                    fgets(input, sizeof(input), stdin);
                    char *toMakeUppercase;
                    if (strcmp(input, &quot;quit&quot;) != 0) {
                        toMakeUppercase = input;
                    }
                    // The pointer toMakeUppercase can be uninitialized here!
                    printToUpper(toMakeUppercase);
                }
            </div><p id="-i4c74b_104"><span id="-i4c74b_128"><font style="color:#cd5c5c">Example 2</font></span></p><div class="code-collapse" data-lang="c" data-is-expanded="false" data-synopsis="int main(int argc, char *argv[]) {">
                int main(int argc, char *argv[]) {
                    // Goal: parse out a string between brackets
                    // (e.g. &quot; [target string]&quot; -&gt; &quot;target string&quot;)
                    char *parsed = strdup(argv[1]);

                    // Find open bracket
                    char *open_bracket = strchr(parsed, '[');
                    if (open_bracket == NULL) {
                        printf(&quot;Malformed input!\n&quot;);
                        return 1; // Early return fails to clean up heap alllocation!
                    }

                    // Make the output string start after the open bracket
                    parsed = open_bracket + 1;

                    // Find the close bracket
                    char *close_bracket = strchr(parsed, ']');
                    if (close_bracket == NULL) {
                        printf(&quot;Malformed input!\n&quot;);
                        return 1; // Early return fails to clean up heap alllocation!
                    }

                    // Replace the close bracket with a null
                    // terminator to end the parsed string there
                    *close_bracket = '\0';

                    printf(&quot;Parsed string: %s\n&quot;, parsed);
                    free(parsed);
                    return 0;
                }
            </div><p id="-i4c74b_106"><span id="-i4c74b_129"><font style="color:#cd5c5c">Example 3(Work across functions)</font></span></p><div class="code-collapse" data-lang="c" data-is-expanded="false" data-synopsis="void freeSometimes(void *buf) {">
                void freeSometimes(void *buf) {
                    if (rand() == 1) {
                        return;
                    }
                    free(buf); // buf can be a heap allocation or a freed allocation!
                }

                int main() {
                    void *buf = malloc(8);
                    freeSometimes(buf);
                    return 0;
                }
            </div><p id="-i4c74b_108"><span id="-i4c74b_130"><font style="color:#8a2be2">Limitations</font></span></p><ul class="list _bullet" id="-i4c74b_109"><li class="list__item" id="-i4c74b_131"><p id="-i4c74b_134"><span id="-i4c74b_136"><font style="color:#ff00ff">False positives</font></span></p><ul class="list _bullet" id="-i4c74b_135"><li class="list__item" id="-i4c74b_137"><p id="-i4c74b_139">Dataflow analysis will follow each branch, even if it&rsquo;s impossible for some condition to be true in real life.</p></li><li class="list__item" id="-i4c74b_138"><p id="-i4c74b_140">False positives are the Achille&rsquo;s heel of static analysis. Need a good signal/noise ratio or else no one will use your analyzer.</p></li></ul></li><li class="list__item" id="-i4c74b_132"><p id="-i4c74b_141"><span id="-i4c74b_143"><font style="color:#ff00ff">Need to limit scope to get reasonable performance</font></span></p><ul class="list _bullet" id="-i4c74b_142"><li class="list__item" id="-i4c74b_144"><p id="-i4c74b_146">Many static analyzers only analyze a single file at a time: they don't do dataflow analysis into/out of functions elsewhere in the codebase</p></li><li class="list__item" id="-i4c74b_145"><p id="-i4c74b_147">If you have a huge codebase, loops, tons of conditions, etc., dataflow analysis can get unwieldy.</p></li></ul></li><li class="list__item" id="-i4c74b_133"><p id="-i4c74b_148">Static analysis can only report bad behavior that might happen</p></li></ul><p id="-i4c74b_110"><span id="-i4c74b_149"><font style="color:#8a2be2">Fundamental limitations of static analysis</font></span></p><ul class="list _bullet" id="-i4c74b_111"><li class="list__item" id="-i4c74b_150"><p id="-i4c74b_153">If you can only look at a few lines of code, it's hard to tell (without broader context) whether that code is safe.</p></li><li class="list__item" id="-i4c74b_151"><p id="-i4c74b_154">Getting broader context is impossible in the general case.</p></li><li class="list__item" id="-i4c74b_152"><p id="-i4c74b_155">You can always add more specific things to check for, but there will always be other ways to mess up.</p></li></ul></section></section><div class="last-modified">Last modified: 28 October 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="python-programming.html" class="navigation-links__prev">Python Programming</a><a href="web-development.html" class="navigation-links__next">Web Development</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b419/app.js"></script></body></html>