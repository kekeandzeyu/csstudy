<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#E8488B" data-link-color="#307FFF" data-resizable-sidebar="true"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2024-09-20T11:24:13.6443684"><title>Computer Architecture | Computer Science Study Notes</title><script type="application/json" id="virtual-toc-data">[{"id":"c-programming","level":0,"title":"Ⅰ C Programming","anchor":"#c-programming"},{"id":"1-introduction-to-c","level":1,"title":"1 Introduction to C","anchor":"#1-introduction-to-c"},{"id":"2-c-memory-layout","level":1,"title":"2 C Memory Layout","anchor":"#2-c-memory-layout"},{"id":"2-1-stack","level":2,"title":"2.1 Stack","anchor":"#2-1-stack"},{"id":"2-2-static-data","level":2,"title":"2.2 Static Data","anchor":"#2-2-static-data"},{"id":"2-3-code","level":2,"title":"2.3 Code","anchor":"#2-3-code"},{"id":"2-4-addressing-endianness","level":2,"title":"2.4 Addressing \u0026 Endianness","anchor":"#2-4-addressing-endianness"},{"id":"2-5-heap","level":2,"title":"2.5 Heap","anchor":"#2-5-heap"},{"id":"assembly-language","level":0,"title":"Ⅱ Assembly Language","anchor":"#assembly-language"},{"id":"3-introduction-to-assembly-language","level":1,"title":"3 Introduction to Assembly Language","anchor":"#3-introduction-to-assembly-language"},{"id":"3-1-assembly-language","level":2,"title":"3.1 Assembly Language","anchor":"#3-1-assembly-language"},{"id":"3-2-registers","level":2,"title":"3.2 Registers","anchor":"#3-2-registers"},{"id":"3-3-risc-instructions","level":2,"title":"3.3 RISC-Ⅴ Instructions","anchor":"#3-3-risc-instructions"},{"id":"4-risc-functions","level":1,"title":"4 RISC-Ⅴ Functions","anchor":"#4-risc-functions"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b419/app.css" rel="stylesheet"><link href="static/custom.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="Computer-Science-Study-Notes/photo.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Computer Architecture | Computer Science Study Notes"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Computer Science Study Notes Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/computer-architecture.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Computer Architecture | Computer Science Study Notes"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/computer-architecture.html#webpage",
    "url": "writerside-documentation/computer-architecture.html",
    "name": "Computer Architecture | Computer Science Study Notes",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Computer Science Study Notes Help"
}</script><!-- End Schema.org --></head><body data-id="Computer-Architecture" data-main-title="Computer Architecture" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs=""><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Computer Science Study Notes  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Computer-Architecture" id="Computer-Architecture.md">Computer Architecture</h1><figure id="szk6xb_4"><img alt="Computer Architecture" src="Computer-Science-Study-Notes/a1-1-1.png" title="Computer Architecture" width="8083" height="7350"></figure><section class="chapter"><h2 id="c-programming" data-toc="c-programming">Ⅰ C Programming</h2><section class="chapter"><h3 id="1-introduction-to-c" data-toc="1-introduction-to-c">1 Introduction to C</h3><p id="szk6xb_10">For this part, please refer to <a href="c-programming.html#intro" id="szk6xb_11" data-tooltip="C++ Introduction">introduction in C++ programming</a> for more details.</p></section><section class="chapter"><h3 id="2-c-memory-layout" data-toc="2-c-memory-layout">2 C Memory Layout</h3><p id="szk6xb_12">Program's <span id="szk6xb_22"><i><font style="color:#ff4500">address space</font></i></span> contains 4 regions:</p><ul class="list _bullet" id="szk6xb_13"><li class="list__item" id="szk6xb_23"><p id="szk6xb_27"><span id="szk6xb_28"><font style="color:#ff00ff">Stack:</font></span> local variables, grow downwards.</p></li><li class="list__item" id="szk6xb_24"><p id="szk6xb_29"><span id="szk6xb_30"><font style="color:#ff00ff">Heap:</font></span> space requested via <code class="code" id="szk6xb_31">malloc()</code> and used with pointers; resizes dynamically, grow upward.</p></li><li class="list__item" id="szk6xb_25"><p id="szk6xb_32"><span id="szk6xb_33"><font style="color:#ff00ff">Static Data:</font></span> global or static variables, does not grow or shrink.</p></li><li class="list__item" id="szk6xb_26"><p id="szk6xb_34"><span id="szk6xb_35"><font style="color:#ff00ff">Code:</font></span> loaded when program starts, does not change.</p></li></ul><figure id="szk6xb_14"><img alt="C Memory Layout" src="Computer-Science-Study-Notes/a2-1-1.png" title="C Memory Layout" width="480" height="742"></figure><p id="szk6xb_15"><span id="szk6xb_36"><font style="color:#8a2be2">Storage:</font></span></p><ul class="list _bullet" id="szk6xb_16"><li class="list__item" id="szk6xb_37"><p id="szk6xb_40"><span id="szk6xb_41"><font style="color:#ff00ff">Declared outside a function:</font></span> Static Data</p></li><li class="list__item" id="szk6xb_38"><p id="szk6xb_42"><span id="szk6xb_44"><font style="color:#ff00ff">Declared inside a function:</font></span> Stack</p><ul class="list _bullet" id="szk6xb_43"><li class="list__item" id="szk6xb_45"><p id="szk6xb_47"><code class="code" id="szk6xb_48">main()</code> is a function.</p></li><li class="list__item" id="szk6xb_46"><p id="szk6xb_49">freed when function returns.</p></li></ul></li><li class="list__item" id="szk6xb_39"><p id="szk6xb_50"><span id="szk6xb_51"><font style="color:#ff00ff">Dynamically allocated (i.e., <code class="code" id="szk6xb_52">malloc</code>, <code class="code" id="szk6xb_53">calloc</code>& <code class="code" id="szk6xb_54">realloc</code>):</font></span> Heap.</p></li></ul><section class="chapter"><h4 id="2-1-stack" data-toc="2-1-stack">2.1 Stack</h4><ul class="list _bullet" id="szk6xb_55"><li class="list__item" id="szk6xb_56"><p id="szk6xb_59">A stack frame includes:</p><ul class="list _bullet" id="szk6xb_60"><li class="list__item" id="szk6xb_61"><p id="szk6xb_64">Location of caller function</p></li><li class="list__item" id="szk6xb_62"><p id="szk6xb_65">Function arguments</p></li><li class="list__item" id="szk6xb_63"><p id="szk6xb_66">Space for local variables</p></li></ul></li><li class="list__item" id="szk6xb_57"><p id="szk6xb_67">Stack pointer (SP) tells where lowest (current) stack frame is.</p></li><li class="list__item" id="szk6xb_58"><p id="szk6xb_68">When procedure ends, stack pointer is moved back (but data remains (<span id="szk6xb_69"><font style="color:#ff4500">garbage!</font></span>)); frees memory for future stack frames;</p></li></ul></section><section class="chapter"><h4 id="2-2-static-data" data-toc="2-2-static-data">2.2 Static Data</h4><ul class="list _bullet" id="szk6xb_70"><li class="list__item" id="szk6xb_72"><p id="szk6xb_75">Place for variables that persist, and data doesn't subject to comings and goings like function calls, e.g. string literals, global variables.</p></li><li class="list__item" id="szk6xb_73"><p id="szk6xb_76">String literal example: <code class="code" id="szk6xb_77">char * str = &ldquo;hi&rdquo;</code>.</p></li><li class="list__item" id="szk6xb_74"><p id="szk6xb_78">Size does not change, but sometimes data can be writable.</p></li></ul><aside class="prompt" data-type="warning" data-title="" id="szk6xb_71"><p id="szk6xb_79">String literals cannot change!</p></aside></section><section class="chapter"><h4 id="2-3-code" data-toc="2-3-code">2.3 Code</h4><ul class="list _bullet" id="szk6xb_80"><li class="list__item" id="szk6xb_81"><p id="szk6xb_83">Copy of your code goes here, C code becomes data too!</p></li><li class="list__item" id="szk6xb_82"><p id="szk6xb_84">Does (should) not change, typically read-only.</p></li></ul></section><section class="chapter"><h4 id="2-4-addressing-endianness" data-toc="2-4-addressing-endianness">2.4 Addressing &amp; Endianness</h4><p id="szk6xb_85"><span id="szk6xb_91"><font style="color:#8a2be2">Addresses:</font></span></p><ul class="list _bullet" id="szk6xb_86"><li class="list__item" id="szk6xb_92"><p id="szk6xb_94">The size of an address (and thus, the size of a pointer) in bytes depends on architecture. For 64-bit system, the size of an address is 8 bytes, and the system has <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.919ex" height="1.904ex" role="img" focusable="false" viewBox="0 -841.7 1290.1 841.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"></path><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(500,0)"></path></g></g></g></g></g></svg></mjx-container> possible addresses.</p></li><li class="list__item" id="szk6xb_93"><p id="szk6xb_96">If a machine is <span id="szk6xb_97"><b>byte-addressed</b></span>, then each of its addresses points to a unique <span id="szk6xb_98"><b>byte</b></span>.</p></li></ul><p id="szk6xb_87"><span id="szk6xb_99"><font style="color:#8a2be2">Endianness:</font></span></p><figure id="szk6xb_88"><img alt="Endianness" src="Computer-Science-Study-Notes/a2-4-1.png" title="Endianness" width="1920" height="960"></figure><ul class="list _bullet" id="szk6xb_89"><li class="list__item" id="szk6xb_100"><p id="szk6xb_102"><span id="szk6xb_103"><font style="color:#ff8c00">Big Endian:</font></span> Descending numerical significance with ascending memory addresses.</p></li><li class="list__item" id="szk6xb_101"><p id="szk6xb_104"><span id="szk6xb_105"><font style="color:#ff8c00">Little Endian:</font></span> Ascending numerical significance with ascending memory addresses.</p></li></ul><aside class="prompt" data-type="warning" data-title="" id="szk6xb_90"><p id="szk6xb_106">Endianess ONLY APPLIES to values that occupy multiple bytes.</p><p id="szk6xb_107">Endianness refers to STORAGE IN MEMORY NOT number representation.</p></aside></section><section class="chapter"><h4 id="2-5-heap" data-toc="2-5-heap">2.5 Heap</h4><p id="szk6xb_108">Dynamically allocated memory goes on the <span id="szk6xb_110"><font style="color:#ff4500">Heap</font></span>, more permanent and persistent than Stack.</p><ol class="list _alpha-lower" id="szk6xb_109" type="a"><li class="list__item" id="szk6xb_111"><p id="szk6xb_115"><span id="szk6xb_117"><font style="color:#ff00ff">malloc(n)</font></span></p><ul class="list _bullet" id="szk6xb_116"><li class="list__item" id="szk6xb_118"><p id="szk6xb_123">Allocates a continuous block of <span id="szk6xb_124"><b><i>n bytes</i></b></span> of uninitialized memory (contains garbage!)</p></li><li class="list__item" id="szk6xb_119"><p id="szk6xb_125">Returns a pointer to the beginning of an allocated block; NULL indicates failed request (check for this!)</p></li><li class="list__item" id="szk6xb_120"><p id="szk6xb_126"><code class="code" id="szk6xb_127">int *p = (int *) malloc(n * sizeof(int))</code></p></li><li class="list__item" id="szk6xb_121"><p id="szk6xb_128"><code class="code" id="szk6xb_129">sizeof()</code> makes code more portable.</p></li><li class="list__item" id="szk6xb_122"><p id="szk6xb_130"><code class="code" id="szk6xb_131">malloc()</code> returns <code class="code" id="szk6xb_132">void *</code>; typecast will help you catch coding errors when pointer types don't match.</p></li></ul></li><li class="list__item" id="szk6xb_112"><p id="szk6xb_133"><span id="szk6xb_135"><font style="color:#ff00ff">calloc(n, size)</font></span></p><ul class="list _bullet" id="szk6xb_134"><li class="list__item" id="szk6xb_136"><p id="szk6xb_140"><code class="code" id="szk6xb_141">void* calloc(size_t nmemb, size_t size)</code></p></li><li class="list__item" id="szk6xb_137"><p id="szk6xb_142">nmemb is the number of the members</p></li><li class="list__item" id="szk6xb_138"><p id="szk6xb_143">size is the size of each member</p></li><li class="list__item" id="szk6xb_139"><p id="szk6xb_144">Example for allocating space for 5 integers.</p><div class="code-block" data-lang="cpp">
    int *p = (int*)calloc(5, sizeof(int));
    </div></li></ul></li><li class="list__item" id="szk6xb_113"><p id="szk6xb_146"><span id="szk6xb_148"><font style="color:#ff00ff">realloc()</font></span></p><ul class="list _bullet" id="szk6xb_147"><li class="list__item" id="szk6xb_149"><p id="szk6xb_154">Use it when you need more or less memory in an array.</p></li><li class="list__item" id="szk6xb_150"><p id="szk6xb_155"><code class="code" id="szk6xb_156">void *realloc(void *ptr, size_t size)</code></p></li><li class="list__item" id="szk6xb_151"><p id="szk6xb_157">Takes in a ptr that has been the return of malloc/calloc/realloc and a new size.</p></li><li class="list__item" id="szk6xb_152"><p id="szk6xb_158">Returns a pointer with now size space (or NULL) and copies any content from ptr.</p></li><li class="list__item" id="szk6xb_153"><p id="szk6xb_159">Realloc can move or keep the address same, so DO NOT rely on old ptr values.</p></li></ul></li><li class="list__item" id="szk6xb_114"><p id="szk6xb_160"><span id="szk6xb_162"><font style="color:#ff00ff">free()</font></span></p><ul class="list _bullet" id="szk6xb_161"><li class="list__item" id="szk6xb_163"><p id="szk6xb_167">Release memory on the heap: Pass the pointer p to the beginning of allocated block; releases the whole block.</p></li><li class="list__item" id="szk6xb_164"><p id="szk6xb_168">p must be the address <span id="szk6xb_169"><i>originally</i></span> returned by m/c/realloc(), otherwise throws system exception.</p></li><li class="list__item" id="szk6xb_165"><p id="szk6xb_170">Don't call <code class="code" id="szk6xb_171">free()</code> on a block that has already been released or on NULL.</p></li><li class="list__item" id="szk6xb_166"><p id="szk6xb_172">Make sure you don't lose the original address.</p></li></ul></li></ol></section></section></section><section class="chapter"><h2 id="assembly-language" data-toc="assembly-language">Ⅱ Assembly Language</h2><section class="chapter"><h3 id="3-introduction-to-assembly-language" data-toc="3-introduction-to-assembly-language">3 Introduction to Assembly Language</h3><section class="chapter"><h4 id="3-1-assembly-language" data-toc="3-1-assembly-language">3.1 Assembly Language</h4><p id="szk6xb_179"><span id="szk6xb_187"><font style="color:#ff8c00">Assembly (also known as Assembly language, ASM):</font></span> A low-level programming language where the program instructions match a particular architecture's operations.</p><p id="szk6xb_180"><span id="szk6xb_188"><font style="color:#8a2be2">Properties:</font></span></p><ul class="list _bullet" id="szk6xb_181"><li class="list__item" id="szk6xb_189"><p id="szk6xb_192">Splits a program into many small instructions that each do one single part of the process.</p></li><li class="list__item" id="szk6xb_190"><p id="szk6xb_193">Each architecture will have a different set of operations that it supports (although there are similarities).</p></li><li class="list__item" id="szk6xb_191"><p id="szk6xb_194">Assembly is not <span id="szk6xb_195"><i>portable</i></span> to other architectures.</p></li></ul><p id="szk6xb_182"><span id="szk6xb_196"><font style="color:#8a2be2">Complex/Reduced Instruction Set Computing</font></span></p><ol class="list _alpha-lower" id="szk6xb_183" type="a"><li class="list__item" id="szk6xb_197"><p id="szk6xb_199">Early trend - add more and more instructions to do elaborate operations</p><p id="szk6xb_200"><span id="szk6xb_202"><font style="color:#ff00ff">Complex Instruction Set Computing (CISC)</font></span></p><ul class="list _bullet" id="szk6xb_201"><li class="list__item" id="szk6xb_203"><p id="szk6xb_206">Difficult to learn and comprehend language</p></li><li class="list__item" id="szk6xb_204"><p id="szk6xb_207">Less work for the compiler</p></li><li class="list__item" id="szk6xb_205"><p id="szk6xb_208">Complicated hardware runs more slowly</p></li></ul></li><li class="list__item" id="szk6xb_198"><p id="szk6xb_209">Opposite philosophy later began to dominate</p><p id="szk6xb_210"><span id="szk6xb_212"><font style="color:#ff00ff">Reduced Instruction Set Computing (RISC)</font></span></p><ul class="list _bullet" id="szk6xb_211"><li class="list__item" id="szk6xb_213"><p id="szk6xb_215">Simple (and smaller) instruction set makes it easier to build fast hardware.</p></li><li class="list__item" id="szk6xb_214"><p id="szk6xb_216">Let software do the complicated operations by composing simpler ones.</p></li></ul></li></ol><p id="szk6xb_184"><span id="szk6xb_217"><font style="color:#8a2be2">Code:</font></span></p><p id="szk6xb_185">op dst, src1, src2</p><ul class="list _bullet" id="szk6xb_186"><li class="list__item" id="szk6xb_218"><p id="szk6xb_222"><code class="code" id="szk6xb_223">op</code>: operation name (&quot;operator&quot;)</p></li><li class="list__item" id="szk6xb_219"><p id="szk6xb_224"><code class="code" id="szk6xb_225">dst</code>: register getting result (&quot;destination&quot;)</p></li><li class="list__item" id="szk6xb_220"><p id="szk6xb_226"><code class="code" id="szk6xb_227">src1</code>: first register for operation (&quot;source 1&quot;)</p></li><li class="list__item" id="szk6xb_221"><p id="szk6xb_228"><code class="code" id="szk6xb_229">src2</code>: second register for operation (&quot;source 2&quot;)</p></li></ul></section><section class="chapter"><h4 id="3-2-registers" data-toc="3-2-registers">3.2 Registers</h4><p id="szk6xb_230">Assembly uses registers to store values. Registers are:</p><ul class="list _bullet" id="szk6xb_231"><li class="list__item" id="szk6xb_235"><p id="szk6xb_239">Small memories of a fixed size.</p></li><li class="list__item" id="szk6xb_236"><p id="szk6xb_240">Can be read or written.</p></li><li class="list__item" id="szk6xb_237"><p id="szk6xb_241">Limited in number.</p></li><li class="list__item" id="szk6xb_238"><p id="szk6xb_242">Very fast and low power to access.</p></li></ul><div class="table-wrapper"><table class="left_header wide" id="szk6xb_232"><thead><tr class="ijRowHead" id="szk6xb_243"><th id="szk6xb_247"></th><th id="szk6xb_248"><p>Registers</p></th><th id="szk6xb_249"><p>Memory</p></th></tr></thead><tbody><tr id="szk6xb_244"><th id="szk6xb_250"><p>Speed</p></th><td id="szk6xb_251"><p>Fast</p></td><td id="szk6xb_252"><p>Slow</p></td></tr><tr id="szk6xb_245"><th id="szk6xb_253"><p>Size</p></th><td id="szk6xb_254"><p id="szk6xb_256">Small</p><p id="szk6xb_257">e.g., 32 registers * 32 bit = 128 bytes</p></td><td id="szk6xb_255"><p id="szk6xb_258">Big</p><p id="szk6xb_259">4-32 GB</p></td></tr><tr id="szk6xb_246"><th id="szk6xb_260"><p>Connection</p></th><td id="szk6xb_261" colspan="2"><p id="szk6xb_262">More variables than registers?</p><p id="szk6xb_263">Keep most frequently used in registers and move the rest to memory</p></td></tr></tbody></table></div><figure id="szk6xb_233"><img alt="Registers" src="Computer-Science-Study-Notes/a3-2-1.png" title="Registers" width="2207" height="1307"></figure><aside class="prompt" data-type="warning" data-title="" id="szk6xb_234"><p id="szk6xb_264">Some important notes about registers:</p><ul class="list _bullet" id="szk6xb_265"><li class="list__item" id="szk6xb_266"><p id="szk6xb_271">Each ISA has a predetermined number of registers, registers are built in with hardware.</p></li><li class="list__item" id="szk6xb_267"><p id="szk6xb_272">Register denoted by 'x' can be referenced by number (x0 - x31) or by name.</p></li><li class="list__item" id="szk6xb_268"><p id="szk6xb_273">Registers have no type.</p></li><li class="list__item" id="szk6xb_269"><p id="szk6xb_274">Register zero (x0 or zero) always has the value 0 and cannot be changed! Any instruction writing to x0 has no effect!</p></li><li class="list__item" id="szk6xb_270"><p id="szk6xb_275">In high-level languages, number of variables limited only by available memory.</p></li></ul></aside></section><section class="chapter"><h4 id="3-3-risc-instructions" data-toc="3-3-risc-instructions">3.3 RISC-Ⅴ Instructions</h4><p id="szk6xb_277">In high-level languages, variable types determine operation.</p><p id="szk6xb_278">In assembly, operation determines type, i.e., how register contents are treated.</p><section class="chapter"><h5 id="3-3-1-basic-arithmetic-instructions" data-toc="3-3-1-basic-arithmetic-instructions">3.3.1 Basic Arithmetic Instructions</h5><aside class="prompt" data-type="note" data-title="" id="szk6xb_283"><p id="szk6xb_286">Assume here that the variables a, b and c are assigned to registers s1, s2 and s3, respectively.</p></aside><p id="szk6xb_284"><span id="szk6xb_287"><font style="color:#8a2be2">Types:</font></span></p><ul class="list _bullet" id="szk6xb_285"><li class="list__item" id="szk6xb_288"><p id="szk6xb_290"><span id="szk6xb_292"><font style="color:#ff00ff">Integer Addition:</font></span></p><ul class="list _bullet" id="szk6xb_291"><li class="list__item" id="szk6xb_293"><p id="szk6xb_295">C: a = b + c;</p></li><li class="list__item" id="szk6xb_294"><p id="szk6xb_296">RISC-Ⅴ: add s1, s2, s3</p></li></ul></li><li class="list__item" id="szk6xb_289"><p id="szk6xb_297"><span id="szk6xb_299"><font style="color:#ff00ff">Integer Subtraction:</font></span></p><ul class="list _bullet" id="szk6xb_298"><li class="list__item" id="szk6xb_300"><p id="szk6xb_302">C: a = b - c;</p></li><li class="list__item" id="szk6xb_301"><p id="szk6xb_303">RISC-Ⅴ: sub s1, s2, s3</p></li></ul></li></ul></section><section class="chapter"><h5 id="3-3-2-immediate-instructions" data-toc="3-3-2-immediate-instructions">3.3.2 Immediate Instructions</h5><p id="szk6xb_304"><span id="szk6xb_308"><font style="color:#ff8c00">Immediates:</font></span> Numerical constants.</p><p id="szk6xb_305"><span id="szk6xb_309"><font style="color:#8a2be2">Syntax:</font></span> opi dst, src, imm</p><ul class="list _bullet" id="szk6xb_306"><li class="list__item" id="szk6xb_310"><p id="szk6xb_314">Operation names end with &quot;i&quot;, replace <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="3.098ex" height="1.932ex" role="img" focusable="false" viewBox="0 -853.7 1369.3 853.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mtext"><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z"></path><path data-c="64" d="M376 495Q376 511 376 535T377 568Q377 613 367 624T316 637H298V660Q298 683 300 683L310 684Q320 685 339 686T376 688Q393 689 413 690T443 693T454 694H457V390Q457 84 458 81Q461 61 472 55T517 46H535V0Q533 0 459 -5T380 -11H373V44L365 37Q307 -11 235 -11Q158 -11 96 50T34 215Q34 315 97 378T244 442Q319 442 376 393V495ZM373 342Q328 405 260 405Q211 405 173 369Q146 341 139 305T131 211Q131 155 138 120T173 59Q203 26 251 26Q322 26 373 103V342Z" transform="translate(556,0)"></path></g></g></g></g></g></svg></mjx-container> source register with an immeidate.</p></li><li class="list__item" id="szk6xb_311"><p id="szk6xb_316">Immediates can up to 12-bits in size.</p></li><li class="list__item" id="szk6xb_312"><p id="szk6xb_317">Interpreted as sign-extended two's complement.</p></li><li class="list__item" id="szk6xb_313"><p id="szk6xb_318">RISC-Ⅴ hardwires the register zero (x0) to value 0.</p><p id="szk6xb_319">Example: RISC-Ⅴ: add x3 x4 0</p><p id="szk6xb_320">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C:&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f = g</p></li></ul><aside class="prompt" data-type="warning" data-title="" id="szk6xb_307"><p id="szk6xb_321">No <code class="code" id="szk6xb_322">subi</code> instruction, since RISC-Ⅴ is all about reducing # of instructions.</p></aside></section><section class="chapter"><h5 id="3-3-3-data-transfer-instructions" data-toc="3-3-3-data-transfer-instructions">3.3.3 Data Transfer Instructions</h5><p id="szk6xb_323">Specialized <span id="szk6xb_331"><font style="color:#ff4500">data transfer instructions</font></span> move data between registers and memory.</p><ul class="list _bullet" id="szk6xb_324"><li class="list__item" id="szk6xb_332"><p id="szk6xb_334"><span id="szk6xb_335"><font style="color:#ff00ff">Store:</font></span> register TO memory</p></li><li class="list__item" id="szk6xb_333"><p id="szk6xb_336"><span id="szk6xb_337"><font style="color:#ff00ff">Load:</font></span> register FROM memory</p></li></ul><p id="szk6xb_325"><span id="szk6xb_338"><font style="color:#8a2be2">Syntax:</font></span> memop reg, off (bAbbr)</p><ul class="list _bullet" id="szk6xb_326"><li class="list__item" id="szk6xb_339"><p id="szk6xb_343"><code class="code" id="szk6xb_344">memop</code>: operation name (&quot;operator&quot;)</p></li><li class="list__item" id="szk6xb_340"><p id="szk6xb_345"><code class="code" id="szk6xb_346">reg</code>: register for operation source or destination.</p></li><li class="list__item" id="szk6xb_341"><p id="szk6xb_347"><code class="code" id="szk6xb_348">bAbbr</code>: register with pointer to memory (&quot;base address&quot;)</p></li><li class="list__item" id="szk6xb_342"><p id="szk6xb_349"><code class="code" id="szk6xb_350">off</code>: Address offset (immediate) in bytes (&quot;offset&quot;)</p></li></ul><p id="szk6xb_327"><span id="szk6xb_351"><font style="color:#8a2be2">Types:</font></span></p><ul class="list _bullet" id="szk6xb_328"><li class="list__item" id="szk6xb_352"><p id="szk6xb_354"><span id="szk6xb_355"><font style="color:#ff00ff">Load Word:</font></span> Takes data at address <code class="code" id="szk6xb_356">bAbbr+off</code> FROM memory and places it into <code class="code" id="szk6xb_357">reg</code>.</p></li><li class="list__item" id="szk6xb_353"><p id="szk6xb_358"><span id="szk6xb_359"><font style="color:#ff00ff">Store Word:</font></span> Takes data in <code class="code" id="szk6xb_360">reg</code> and stores it TO memory at <code class="code" id="szk6xb_361">bAbbr+off</code>.</p></li></ul><p id="szk6xb_329"><span id="szk6xb_362"><font style="color:#8a2be2">Example:</font></span> address of int array [] -&gt; s3, value of b -&gt; s2</p><ul class="list _bullet" id="szk6xb_330"><li class="list__item" id="szk6xb_363"><p id="szk6xb_365">C: array[10] = array[3] + b;</p></li><li class="list__item" id="szk6xb_364"><p id="szk6xb_366">RISC-Ⅴ</p><p id="szk6xb_367">lw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t0, <span id="szk6xb_370"><font style="color:#ff4500">l2</font></span> (s3)&nbsp;&nbsp;&nbsp;&nbsp;# t0 = A[<span id="szk6xb_371"><font style="color:#ff4500">3</font></span>]</p><p id="szk6xb_368">add&nbsp;&nbsp;&nbsp;&nbsp;t0, s2, t0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# t0 = A[3] + b</p><p id="szk6xb_369">sw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t0, <span id="szk6xb_372"><font style="color:#ff4500">40</font></span> (s3)&nbsp;&nbsp;# A[<span id="szk6xb_373"><font style="color:#ff4500">10</font></span>] = A[3] + b</p></li></ul></section><section class="chapter"><h5 id="3-3-4-control-flow-instructions" data-toc="3-3-4-control-flow-instructions">3.3.4 Control Flow Instructions</h5><p id="szk6xb_374"><span id="szk6xb_382"><font style="color:#ff8c00">Labels in RISC-Ⅴ</font></span>: Defined by a text and followed by a colon (e.g., main:) and refers to the instructions that follows; generate control flow by jumping to labels.</p><p id="szk6xb_375"><span id="szk6xb_383"><font style="color:#8a2be2">Types:</font></span></p><ol class="list _alpha-lower" id="szk6xb_376" type="a"><li class="list__item" id="szk6xb_384"><p id="szk6xb_389"><span id="szk6xb_391"><font style="color:#ff00ff">Branch If Equal</font></span> (beq)</p><ul class="list _bullet" id="szk6xb_390"><li class="list__item" id="szk6xb_392"><p id="szk6xb_395"><span id="szk6xb_396"><font style="color:#7cfc00">Syntax:</font></span> beq reg1, reg2, label</p></li><li class="list__item" id="szk6xb_393"><p id="szk6xb_397">If value in reg1 == value in reg2, go to label.</p></li><li class="list__item" id="szk6xb_394"><p id="szk6xb_398">Otherwise go to next instruction.</p></li></ul></li><li class="list__item" id="szk6xb_385"><p id="szk6xb_399"><span id="szk6xb_401"><font style="color:#ff00ff">Branch If Not Equal</font></span> (bne)</p><ul class="list _bullet" id="szk6xb_400"><li class="list__item" id="szk6xb_402"><p id="szk6xb_404"><span id="szk6xb_405"><font style="color:#7cfc00">Syntax:</font></span> bne reg1, reg2, label</p></li><li class="list__item" id="szk6xb_403"><p id="szk6xb_406">If value in reg1 &amp;#8800; value in reg2, go to label.</p></li></ul></li><li class="list__item" id="szk6xb_386"><p id="szk6xb_407"><span id="szk6xb_409"><font style="color:#ff00ff">Jump</font></span> (j)</p><ul class="list _bullet" id="szk6xb_408"><li class="list__item" id="szk6xb_410"><p id="szk6xb_412"><span id="szk6xb_413"><font style="color:#7cfc00">Syntax:</font></span> j label</p></li><li class="list__item" id="szk6xb_411"><p id="szk6xb_414">Unconditional jump to label.</p></li></ul></li><li class="list__item" id="szk6xb_387"><p id="szk6xb_415"><span id="szk6xb_417"><font style="color:#ff00ff">Branch Less Than</font></span> (blt)</p><ul class="list _bullet" id="szk6xb_416"><li class="list__item" id="szk6xb_418"><p id="szk6xb_420"><span id="szk6xb_421"><font style="color:#7cfc00">Syntax:</font></span> blt reg1, reg2, label</p></li><li class="list__item" id="szk6xb_419"><p id="szk6xb_422">If value in reg1 &lt; value in reg2, go to label.</p></li></ul></li><li class="list__item" id="szk6xb_388"><p id="szk6xb_423"><span id="szk6xb_425"><font style="color:#ff00ff">Branch Less Than or Equal</font></span> (ble)</p><ul class="list _bullet" id="szk6xb_424"><li class="list__item" id="szk6xb_426"><p id="szk6xb_428"><span id="szk6xb_429"><font style="color:#7cfc00">Syntax:</font></span> ble reg1, reg2, label</p></li><li class="list__item" id="szk6xb_427"><p id="szk6xb_430">If value in reg1 &amp;#8804; value in reg2, go to label.</p></li></ul></li></ol><div class="code-comparer" id="szk6xb_377" data-comparing="vertically"><div class="code-block" data-lang="c" data-title="C">
        if (i == j) {
            a = b; /* then */
        } else {
            a = -b; /* else */
        }
    </div><div class="code-block" data-lang="python" data-title="RISC-Ⅴ (beq)">
        # i -&gt; s0, j -&gt; s1
        # a -&gt; s2, b -&gt; s3
        beq s0, s1, then
        else:
        sub s2, x0, s3
        j end
        then:
        add s2, s3, x0
        end:
    </div></div><p id="szk6xb_378"><span id="szk6xb_433"><font style="color:#8a2be2">Loops in RISC-Ⅴ:</font></span></p><ul class="list _bullet" id="szk6xb_379"><li class="list__item" id="szk6xb_434"><p id="szk6xb_437">There are three types of loops in C: while, do...while, and for.</p></li><li class="list__item" id="szk6xb_435"><p id="szk6xb_438">These can be created with branch instructions as well.</p></li><li class="list__item" id="szk6xb_436"><p id="szk6xb_439">The key to decision making is the branch statement.</p></li></ul><p id="szk6xb_380"><span id="szk6xb_440"><font style="color:#8a2be2">Program Counter:</font></span></p><ul class="list _bullet" id="szk6xb_381"><li class="list__item" id="szk6xb_441"><p id="szk6xb_445">Program Counter (PC): A special register that contains the current address of the code that is being executed.</p></li><li class="list__item" id="szk6xb_442"><p id="szk6xb_446">Branches and Jumps change the flow of execution by modifying the PC.</p></li><li class="list__item" id="szk6xb_443"><p id="szk6xb_447">Instructions are stored as data in memory (code section) and have addresses! Labels get converted to instruction addresses.</p></li><li class="list__item" id="szk6xb_444"><p id="szk6xb_448">The PC tracks where in memory the current instruction is.</p></li></ul></section></section></section><section class="chapter"><h3 id="4-risc-functions" data-toc="4-risc-functions">4 RISC-Ⅴ Functions</h3></section></section><div class="last-modified">Last modified: 20 September 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="c-programming.html" class="navigation-links__prev">C++ Programming</a><a href="data-structures-and-algorithms.html" class="navigation-links__next">Data Structures and Algorithms</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b419/app.js"></script></body></html>