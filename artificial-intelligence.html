<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#6860F6" data-link-color="#307FFF" data-resizable-sidebar="true" data-sidebar-width="260"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2024-11-29T10:57:30.3419486"><title>Artificial Intelligence | Computer Science Study Notes</title><script type="application/json" id="virtual-toc-data">[{"id":"1-search","level":0,"title":"1 Uninformed Search","anchor":"#1-search"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b518/app.css" rel="stylesheet"><link href="static/custom.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="Computer-Science-Study-Notes/photo.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Artificial Intelligence | Computer Science Study Notes"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Computer Science Study Notes Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/artificial-intelligence.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Artificial Intelligence | Computer Science Study Notes"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/artificial-intelligence.html#webpage",
    "url": "writerside-documentation/artificial-intelligence.html",
    "name": "Artificial Intelligence | Computer Science Study Notes",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Computer Science Study Notes Help"
}</script><!-- End Schema.org --></head><body data-id="Artificial-Intelligence" data-main-title="Artificial Intelligence" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs=""><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Computer Science Study Notes  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Artificial-Intelligence" id="Artificial-Intelligence.topic">Artificial Intelligence</h1><section class="chapter"><h2 id="1-search" data-toc="1-search">1 Uninformed Search</h2><section class="chapter"><h3 id="1-1-agent-design" data-toc="1-1-agent-design">1.1 Agent Design</h3><p id="z6fwrd0_5">There are mainly two types of agents.</p><ol class="list _decimal" id="z6fwrd0_6" type="1"><li class="list__item" id="z6fwrd0_7"><p id="z6fwrd0_9"><span id="z6fwrd0_10"><font style="color:#ff00ff">Reflex Agents:</font></span> Choose action based on current percept (and maybe memory), may have memory or a model of the world's current state, do not consider the future consequences of their actions.</p></li><li class="list__item" id="z6fwrd0_8"><p id="z6fwrd0_11"><span id="z6fwrd0_12"><font style="color:#ff00ff">Planning Agents:</font></span> Decisions based on (hypothesized) consequences of actions, must have a model of how the world evolves in response to actions, and must formulate a goal (test).</p></li></ol></section><section class="chapter"><h3 id="1-2-search-problems-and-algorithms" data-toc="1-2-search-problems-and-algorithms">1.2 Search Problems and Algorithms</h3><p id="z6fwrd0_13"><span id="z6fwrd0_30"><font style="color:#8a2be2">Search Problems</font></span></p><ul class="list _bullet" id="z6fwrd0_14"><li class="list__item" id="z6fwrd0_31"><p id="z6fwrd0_35">A state space.</p></li><li class="list__item" id="z6fwrd0_32"><p id="z6fwrd0_36">A successor function (with actions, costs).</p></li><li class="list__item" id="z6fwrd0_33"><p id="z6fwrd0_37">A start state and a goal test.</p></li><li class="list__item" id="z6fwrd0_34"><p id="z6fwrd0_38">A solution is a sequence of actions (a plan) which transforms the start state to a goal state.</p></li></ul><p id="z6fwrd0_15"><span id="z6fwrd0_39"><font style="color:#8a2be2">State Space Graphs vs. Search Trees</font></span></p><figure id="z6fwrd0_16"><img alt="State Space Graphs vs. Search Trees" src="Computer-Science-Study-Notes/ai1-2-1.png" title="State Space Graphs vs. Search Trees" width="7475" height="2567"></figure><p id="z6fwrd0_17"><span id="z6fwrd0_40"><font style="color:#8a2be2">Search Algorithms</font></span></p><ul class="list _bullet" id="z6fwrd0_18"><li class="list__item" id="z6fwrd0_41"><p id="z6fwrd0_43">Uninformed search algorithms (blind search).</p><ul class="list _bullet" id="z6fwrd0_44"><li class="list__item" id="z6fwrd0_45"><p id="z6fwrd0_48">Depth-First Search</p></li><li class="list__item" id="z6fwrd0_46"><p id="z6fwrd0_49">Breadth-First Search</p></li><li class="list__item" id="z6fwrd0_47"><p id="z6fwrd0_50">Uniform-Cost Search</p></li></ul></li><li class="list__item" id="z6fwrd0_42"><p id="z6fwrd0_51">Informed search algorithms (heuristic search).</p></li></ul><p id="z6fwrd0_19"><span id="z6fwrd0_52"><font style="color:#8a2be2">Depth-First Search</font></span></p><ul class="list _bullet" id="z6fwrd0_20"><li class="list__item" id="z6fwrd0_53"><p id="z6fwrd0_55"><span id="z6fwrd0_56"><font style="color:#ff00ff">Completeness:</font></span> <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.986ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 878 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container> could be infinite, so only if we prevent cycles.</p></li><li class="list__item" id="z6fwrd0_54"><p id="z6fwrd0_58"><span id="z6fwrd0_59"><font style="color:#ff00ff">Optimality:</font></span> No, it finds the &quot;leftmost&quot; solution, regardless of depth or cost.</p></li></ul><figure id="z6fwrd0_21"><img alt="Depth-First Search" src="Computer-Science-Study-Notes/ai1-2-2.png" title="Depth-First Search" width="3571" height="1939"></figure><p id="z6fwrd0_22"><span id="z6fwrd0_60"><font style="color:#8a2be2">Breadth-First Search</font></span></p><ul class="list _bullet" id="z6fwrd0_23"><li class="list__item" id="z6fwrd0_61"><p id="z6fwrd0_63"><span id="z6fwrd0_64"><font style="color:#ff00ff">Completeness:</font></span> <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex;" xmlns="http://www.w3.org/2000/svg" width="1.061ex" height="1.023ex" role="img" focusable="false" viewBox="0 -442 469 452"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g></g></g></svg></mjx-container> must be finite if a solution exists , so yes!</p></li><li class="list__item" id="z6fwrd0_62"><p id="z6fwrd0_66"><span id="z6fwrd0_67"><font style="color:#ff00ff">Optimality:</font></span> Only if costs are all 1.</p></li></ul><figure id="z6fwrd0_24"><img alt="Breadth-First Search" src="Computer-Science-Study-Notes/ai1-2-3.png" title="Breadth-First Search" width="3597" height="1922"></figure><aside class="prompt" data-type="note" data-title="" id="z6fwrd0_25"><p id="z6fwrd0_68">For more information on DFS &amp; BFS, please visit <a href="data-structures-and-algorithms-2.html#14-3-depth-first-search" id="z6fwrd0_69" data-tooltip="DFS & BFS">DFS &amp; BFS in Data Structures and Algorithms</a>.</p></aside><p id="z6fwrd0_26"><span id="z6fwrd0_70"><font style="color:#8a2be2">Iterative Deepening:</font></span> get DFS&rsquo;s space advantage with BFS's time / shallow solution advantages, run Run a DFS with depth limit 1, 2, 3, ...</p><p id="z6fwrd0_27"><span id="z6fwrd0_71"><font style="color:#8a2be2">Uniform Cost Search:</font></span> Expand the node with the lowest path cost.</p><section class="procedure-steps"><h3 id="uniform-cost-search" data-toc="uniform-cost-search">Uniform Cost Search</h3><ol class="list _decimal"><li class="list__item" id="z6fwrd0_72"><p id="z6fwrd0_75">Dequeue the node with the lowest path cost (current_node).</p></li><li class="list__item" id="z6fwrd0_73"><p id="z6fwrd0_76">If current_node is the goal state, reconstruct and return the path.</p></li><li class="list__item" id="z6fwrd0_74"><p id="z6fwrd0_77">Expand current_node: For each successor (neighbor) of current_node,</p><ul class="list _bullet" id="z6fwrd0_78"><li class="list__item" id="z6fwrd0_79"><p id="z6fwrd0_81">If the successor is not in the explored set and not already in the priority queue, create a new node for the successor with the calculated cost and parent set to current_node, and insert the successor node into the priority queue.</p></li><li class="list__item" id="z6fwrd0_80"><p id="z6fwrd0_82">Else if the successor is already in the priority queue with a higher cost, update the successor's cost in the priority queue and its parent to current_node.</p></li></ul></li></ol></section><div class="tabs" id="z6fwrd0_29" data-anchors="[z6fwrd0_83,z6fwrd0_84]"><div class="tabs__content" data-gtm="tab" id="z6fwrd0_83" data-title="Java"><div class="code-block" data-lang="java" data-title="Java">
                        import java.util.*;

                        class Node implements Comparable&lt;Node&gt; {
                            String state;
                            Node parent;
                            int cost;

                            public Node(String state, Node parent, int cost) {
                                this.state = state;
                                this.parent = parent;
                                this.cost = cost;
                            }

                            @Override
                            public int compareTo(Node other) {
                                return Integer.compare(this.cost, other.cost);
                            }
                        }

                        public class UCS {

                            public static List&lt;String&gt; uniformCostSearch(Map&lt;String, Map&lt;String, Integer&gt;&gt; graph, String start, String goal) {
                                PriorityQueue&lt;Node&gt; priorityQueue = new PriorityQueue&lt;&gt;();
                                priorityQueue.offer(new Node(start, null, 0));
                                Set&lt;String&gt; explored = new HashSet&lt;&gt;();

                                while (!priorityQueue.isEmpty()) {
                                    Node current = priorityQueue.poll();

                                    if (current.state.equals(goal)) {
                                        List&lt;String&gt; path = new ArrayList&lt;&gt;();
                                        while (current != null) {
                                            path.add(current.state);
                                            current = current.parent;
                                        }
                                        Collections.reverse(path);
                                        return path;
                                    }

                                    explored.add(current.state);

                                    Map&lt;String, Integer&gt; successors = graph.getOrDefault(current.state, Collections.emptyMap());
                                    for (Map.Entry&lt;String, Integer&gt; entry : successors.entrySet()) {
                                        String successor = entry.getKey();
                                        int cost = entry.getValue();
                                        Node successorNode = new Node(successor, current, current.cost + cost);

                                        if (!explored.contains(successor)) {
                                            boolean inQueue = false;
                                            for (Node n : priorityQueue) {
                                                if (n.state.equals(successor)) {
                                                    inQueue = true;
                                                    if (n.cost &gt; successorNode.cost) {
                                                        priorityQueue.remove(n);  // Remove higher cost node
                                                        priorityQueue.offer(successorNode); // Add lower cost node
                                                        break; // Important: Exit loop after updating
                                                    }
                                                }
                                            }
                                            if (!inQueue) {
                                                priorityQueue.offer(successorNode);
                                            }
                                        }
                                    }
                                }

                                return null; // No path found
                            }
                        }
                    </div></div><div class="tabs__content" data-gtm="tab" id="z6fwrd0_84" data-title="Python"><div class="code-block" data-lang="python" data-title="Python">
                        import heapq

                        class Node:
                            def __init__(self, state, parent=None, cost=0):
                                self.state = state
                                self.parent = parent
                                self.cost = cost

                            def __lt__(self, other):
                                return self.cost &lt; other.cost

                        def uniform_cost_search(graph, start, goal):
                            priority_queue = []
                            heapq.heappush(priority_queue, Node(start))
                            explored = set()

                            while priority_queue:
                                current_node = heapq.heappop(priority_queue)

                                if current_node.state == goal:
                                    path = []
                                    while current_node:
                                        path.append(current_node.state)
                                        current_node = current_node.parent
                                    return path[::-1]

                                explored.add(current_node.state)

                                for successor, cost in graph.get(current_node.state, {}).items():  # Directly access successors and costs
                                    successor_node = Node(successor, current_node, current_node.cost + cost)


                                    if successor not in explored:
                                        in_queue = False
                                            for i, node in enumerate(priority_queue):
                                                if node.state == successor:
                                                    in_queue = True
                                                    if node.cost &gt; successor_node.cost:
                                                        priority_queue[i] = successor_node
                                                        heapq.heapify(priority_queue)
                                                    break

                                            if not in_queue:
                                                heapq.heappush(priority_queue, successor_node)


                        return None
                    </div></div></div></section></section><div class="last-modified">Last modified: 29 November 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="section-starting-page.html" class="navigation-links__prev">Get Started</a><a href="c-programming.html" class="navigation-links__next">C++ Programming</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b518/app.js"></script></body></html>