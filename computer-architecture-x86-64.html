<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#6860F6" data-link-color="#307FFF" data-resizable-sidebar="true" data-sidebar-width="260"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2024-11-14T10:00:43.5307583"><title>x86-64 Architecture | Computer Science Study Notes</title><script type="application/json" id="virtual-toc-data">[{"id":"6-introduction-to-assembly-language-x86","level":0,"title":"6 Introduction to Assembly Language","anchor":"#6-introduction-to-assembly-language-x86"},{"id":"6-1-assembly-language-x86","level":1,"title":"6.1 Assembly Language","anchor":"#6-1-assembly-language-x86"},{"id":"6-2-registers-x86","level":1,"title":"6.2 Registers","anchor":"#6-2-registers-x86"},{"id":"6-3-instructions-x86","level":1,"title":"6.3 x86-64 Instructions","anchor":"#6-3-instructions-x86"},{"id":"6-3-1-moving-data-instructions","level":2,"title":"6.3.1 Moving Data Instructions","anchor":"#6-3-1-moving-data-instructions"},{"id":"6-3-2-address-aomputation-instructions","level":2,"title":"6.3.2 Address Computation Instructions","anchor":"#6-3-2-address-aomputation-instructions"},{"id":"6-3-3-arithmetic-instructions","level":2,"title":"6.3.3 Arithmetic Instructions","anchor":"#6-3-3-arithmetic-instructions"},{"id":"6-4-c-assembly-machine-code-x86","level":1,"title":"6.4 C, Assembly \u0026 Machine Code","anchor":"#6-4-c-assembly-machine-code-x86"},{"id":"7-control-flow-instructions-x86","level":0,"title":"7 Control Flow Instructions","anchor":"#7-control-flow-instructions-x86"},{"id":"7-1-conditional-codes-x86","level":1,"title":"7.1 Conditional Codes","anchor":"#7-1-conditional-codes-x86"},{"id":"7-2-conditional-Branches-x86","level":1,"title":"7.2 Conditional Branches","anchor":"#7-2-conditional-Branches-x86"},{"id":"7-3-loops-x86","level":1,"title":"7.3 Loops","anchor":"#7-3-loops-x86"},{"id":"7-4-switch-statements-x86","level":1,"title":"7.4 Switch Statements","anchor":"#7-4-switch-statements-x86"},{"id":"8-program-optimization","level":0,"title":"8 Program Optimization","anchor":"#8-program-optimization"},{"id":"8-1-generally-useful-optimizations","level":1,"title":"8.1 Generally Useful Optimizations","anchor":"#8-1-generally-useful-optimizations"},{"id":"8-2-optimization-blockers","level":1,"title":"8.2 Optimization Blockers","anchor":"#8-2-optimization-blockers"},{"id":"8-3-exploit-instruction-level-parallelism","level":1,"title":"8.3 Exploit Instruction-Level Parallelism","anchor":"#8-3-exploit-instruction-level-parallelism"},{"id":"8-4-dealing-with-conditions","level":1,"title":"8.4 Dealing with Conditions","anchor":"#8-4-dealing-with-conditions"},{"id":"9-memory-hierarchy","level":0,"title":"9 Memory Hierarchy","anchor":"#9-memory-hierarchy"},{"id":"10-linking","level":0,"title":"10 Linking","anchor":"#10-linking"},{"id":"10-1-static-linking","level":1,"title":"10.1 Static Linking","anchor":"#10-1-static-linking"},{"id":"10-2-elf-object-files","level":1,"title":"10.2 ELF Object Files","anchor":"#10-2-elf-object-files"},{"id":"11-exceptional-control-flow","level":0,"title":"11 Exceptional Control Flow","anchor":"#11-exceptional-control-flow"},{"id":"11-1-exceptions","level":1,"title":"11.1 Exceptions","anchor":"#11-1-exceptions"},{"id":"11-2-processes","level":1,"title":"11.2 Processes","anchor":"#11-2-processes"},{"id":"11-2-1context-switch","level":2,"title":"11.2.1 Context Switch","anchor":"#11-2-1context-switch"},{"id":"11-2-2-concurrent-flows","level":2,"title":"11.2.2 Concurrent Flows","anchor":"#11-2-2-concurrent-flows"},{"id":"11-2-3-system-calls","level":2,"title":"11.2.3 System Calls","anchor":"#11-2-3-system-calls"},{"id":"11-2-4-process-control","level":2,"title":"11.2.4 Process Control","anchor":"#11-2-4-process-control"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b518/app.css" rel="stylesheet"><link href="static/custom.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="Computer-Science-Study-Notes/photo.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="x86-64 Architecture | Computer Science Study Notes"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Computer Science Study Notes Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/computer-architecture-x86-64.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="x86-64 Architecture | Computer Science Study Notes"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/computer-architecture-x86-64.html#webpage",
    "url": "writerside-documentation/computer-architecture-x86-64.html",
    "name": "x86-64 Architecture | Computer Science Study Notes",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Computer Science Study Notes Help"
}</script><!-- End Schema.org --></head><body data-id="Computer-Architecture-x86-64" data-main-title="x86-64 Architecture" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Computer-Architecture.topic|Computer Architecture"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Computer Science Study Notes  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Computer-Architecture-x86-64" id="Computer-Architecture-x86-64.topic">x86-64 Architecture</h1><section class="chapter"><h2 id="6-introduction-to-assembly-language-x86" data-toc="6-introduction-to-assembly-language-x86">6 Introduction to Assembly Language</h2><section class="chapter"><h3 id="6-1-assembly-language-x86" data-toc="6-1-assembly-language-x86">6.1 Assembly Language</h3><p id="e0bhpf_14"><span id="e0bhpf_20"><font style="color:#ff8c00">Assembly (also known as Assembly language, ASM):</font></span> A low-level programming language where the program instructions match a particular architecture's operations.</p><p id="e0bhpf_15"><span id="e0bhpf_21"><font style="color:#ff8c00">Architecture:</font></span> (also ISA: instruction set architecture) The parts of a processor design that one needs to understand for writing assembly/machine code.</p><p id="e0bhpf_16"><span id="e0bhpf_22"><font style="color:#8a2be2">Properties:</font></span></p><ul class="list _bullet" id="e0bhpf_17"><li class="list__item" id="e0bhpf_23"><p id="e0bhpf_26">Splits a program into many small instructions that each do one single part of the process.</p></li><li class="list__item" id="e0bhpf_24"><p id="e0bhpf_27">Each architecture will have a different set of operations that it supports (although there are similarities).</p></li><li class="list__item" id="e0bhpf_25"><p id="e0bhpf_28">Assembly is not <span id="e0bhpf_29"><i>portable</i></span> to other architectures.</p></li></ul><p id="e0bhpf_18"><span id="e0bhpf_30"><font style="color:#8a2be2">Complex/Reduced Instruction Set Computing</font></span></p><ol class="list _alpha-lower" id="e0bhpf_19" type="a"><li class="list__item" id="e0bhpf_31"><p id="e0bhpf_33">Early trend - add more and more instructions to do elaborate operations</p><p id="e0bhpf_34"><span id="e0bhpf_36"><font style="color:#ff00ff">Complex Instruction Set Computing (CISC)</font></span></p><ul class="list _bullet" id="e0bhpf_35"><li class="list__item" id="e0bhpf_37"><p id="e0bhpf_40">Difficult to learn and comprehend language</p></li><li class="list__item" id="e0bhpf_38"><p id="e0bhpf_41">Less work for the compiler</p></li><li class="list__item" id="e0bhpf_39"><p id="e0bhpf_42">Complicated hardware runs more slowly</p></li></ul></li><li class="list__item" id="e0bhpf_32"><p id="e0bhpf_43">Opposite philosophy later began to dominate</p><p id="e0bhpf_44"><span id="e0bhpf_46"><font style="color:#ff00ff">Reduced Instruction Set Computing (RISC)</font></span></p><ul class="list _bullet" id="e0bhpf_45"><li class="list__item" id="e0bhpf_47"><p id="e0bhpf_49">Simple (and smaller) instruction set makes it easier to build fast hardware.</p></li><li class="list__item" id="e0bhpf_48"><p id="e0bhpf_50">Let software do the complicated operations by composing simpler ones.</p></li></ul></li></ol></section><section class="chapter"><h3 id="6-2-registers-x86" data-toc="6-2-registers-x86">6.2 Registers</h3><p id="e0bhpf_51">Assembly uses registers to store values. Registers are:</p><ul class="list _bullet" id="e0bhpf_52"><li class="list__item" id="e0bhpf_58"><p id="e0bhpf_62">Small memories of a fixed size.</p></li><li class="list__item" id="e0bhpf_59"><p id="e0bhpf_63">Can be read or written.</p></li><li class="list__item" id="e0bhpf_60"><p id="e0bhpf_64">Limited in number.</p></li><li class="list__item" id="e0bhpf_61"><p id="e0bhpf_65">Very fast and low power to access.</p></li></ul><div class="table-wrapper"><table class="left_header wide" id="e0bhpf_53"><thead><tr class="ijRowHead" id="e0bhpf_66"><th id="e0bhpf_70"><p>Registers</p></th><th id="e0bhpf_71"><p>Memory</p></th></tr></thead><tbody><tr id="e0bhpf_67"><th id="e0bhpf_72"><p>Speed</p></th><td id="e0bhpf_73"><p>Fast</p></td><td id="e0bhpf_74"><p>Slow</p></td></tr><tr id="e0bhpf_68"><th id="e0bhpf_75"><p>Size</p></th><td id="e0bhpf_76"><p id="e0bhpf_78">Small</p><p id="e0bhpf_79">e.g., 32 registers * 32 bit = 128 bytes</p></td><td id="e0bhpf_77"><p id="e0bhpf_80">Big</p><p id="e0bhpf_81">4-32 GB</p></td></tr><tr id="e0bhpf_69"><th id="e0bhpf_82"><p>Connection</p></th><td id="e0bhpf_83" colspan="2"><p id="e0bhpf_84">More variables than registers?</p><p id="e0bhpf_85">Keep most frequently used in registers and move the rest to memory</p></td></tr></tbody></table></div><figure id="e0bhpf_54"><img alt="Registers" src="Computer-Science-Study-Notes/a6-2-1.png" title="Registers" width="2207" height="1307"></figure><p id="e0bhpf_55"><span id="e0bhpf_86"><font style="color:#8a2be2">x86-84 Registers</font></span></p><div class="table-wrapper"><table class="no_header wide" id="e0bhpf_56"><tbody><tr id="e0bhpf_87"><td id="e0bhpf_95"><p>%rax&nbsp;&nbsp;%eax</p></td><td id="e0bhpf_96"><p>%r8&nbsp;&nbsp;%r8d</p></td></tr><tr id="e0bhpf_88"><td id="e0bhpf_97"><p>%rbx&nbsp;&nbsp;%ebx</p></td><td id="e0bhpf_98"><p>%r9&nbsp;&nbsp;%r9d</p></td></tr><tr id="e0bhpf_89"><td id="e0bhpf_99"><p>%rcx&nbsp;&nbsp;%ecx</p></td><td id="e0bhpf_100"><p>%r10&nbsp;&nbsp;%r10d</p></td></tr><tr id="e0bhpf_90"><td id="e0bhpf_101"><p>%rdx&nbsp;&nbsp;%edx</p></td><td id="e0bhpf_102"><p>%r11&nbsp;&nbsp;%r11d</p></td></tr><tr id="e0bhpf_91"><td id="e0bhpf_103"><p>%rsi&nbsp;&nbsp;%esi</p></td><td id="e0bhpf_104"><p>%r12&nbsp;&nbsp;%r12d</p></td></tr><tr id="e0bhpf_92"><td id="e0bhpf_105"><p>%rdi&nbsp;&nbsp;%edi</p></td><td id="e0bhpf_106"><p>%r13&nbsp;&nbsp;%r13d</p></td></tr><tr id="e0bhpf_93"><td id="e0bhpf_107"><p>%rsp&nbsp;&nbsp;%esp</p></td><td id="e0bhpf_108"><p>%r14&nbsp;&nbsp;%r14d</p></td></tr><tr id="e0bhpf_94"><td id="e0bhpf_109"><p>%rbp&nbsp;&nbsp;%ebp</p></td><td id="e0bhpf_110"><p>%r15&nbsp;&nbsp;%r15d</p></td></tr></tbody></table></div><aside class="prompt" data-type="note" data-title="" id="e0bhpf_57"><p id="e0bhpf_111">Usages for the LHS:</p><ul class="list _bullet" id="e0bhpf_112"><li class="list__item" id="e0bhpf_116"><p id="e0bhpf_121"><span id="e0bhpf_122"><font style="color:#ff00ff">%rax:</font></span> 64 bits</p></li><li class="list__item" id="e0bhpf_117"><p id="e0bhpf_123"><span id="e0bhpf_124"><font style="color:#ff00ff">%eax:</font></span> lower 32 bits of rax ( can also be used for storing smaller integers)</p></li><li class="list__item" id="e0bhpf_118"><p id="e0bhpf_125"><span id="e0bhpf_126"><font style="color:#ff00ff">%ax:</font></span> lower 16 bits of eax</p></li><li class="list__item" id="e0bhpf_119"><p id="e0bhpf_127"><span id="e0bhpf_128"><font style="color:#ff00ff">%al:</font></span> lower 8 bits of ax</p></li><li class="list__item" id="e0bhpf_120"><p id="e0bhpf_129"><span id="e0bhpf_130"><font style="color:#ff00ff">%ah:</font></span> upper 8 bits of ax</p></li></ul><p id="e0bhpf_113">Usages for the RHS</p><ul class="list _bullet" id="e0bhpf_114"><li class="list__item" id="e0bhpf_131"><p id="e0bhpf_135"><span id="e0bhpf_136"><font style="color:#ff00ff">%r13:</font></span> 64 bits</p></li><li class="list__item" id="e0bhpf_132"><p id="e0bhpf_137"><span id="e0bhpf_138"><font style="color:#ff00ff">%r13d (doubleword):</font></span> lower 32 bits of rax ( can also be used for storing smaller integers)</p></li><li class="list__item" id="e0bhpf_133"><p id="e0bhpf_139"><span id="e0bhpf_140"><font style="color:#ff00ff">%r13w (word):</font></span> lower 16 bits of eax</p></li><li class="list__item" id="e0bhpf_134"><p id="e0bhpf_141"><span id="e0bhpf_142"><font style="color:#ff00ff">%r13b (byte):</font></span> lower 8 bits of ax</p></li></ul><p id="e0bhpf_115">Stack pointer: %rsp (%esp), you cannot use it!</p></aside></section><section class="chapter"><h3 id="6-3-instructions-x86" data-toc="6-3-instructions-x86">6.3 x86-64 Instructions</h3><p id="e0bhpf_143">In high-level languages, variable types determine operation.</p><p id="e0bhpf_144">In assembly, operation determines type, i.e., how register contents are treated.</p><p id="e0bhpf_145"><span id="e0bhpf_150"><font style="color:#8a2be2">Operations</font></span></p><ul class="list _bullet" id="e0bhpf_146"><li class="list__item" id="e0bhpf_151"><p id="e0bhpf_154"><span id="e0bhpf_156"><font style="color:#ff00ff">Transfer data between memory and register</font></span></p><ul class="list _bullet" id="e0bhpf_155"><li class="list__item" id="e0bhpf_157"><p id="e0bhpf_159">Load data from memory into register</p></li><li class="list__item" id="e0bhpf_158"><p id="e0bhpf_160">Store register data into memory</p></li></ul></li><li class="list__item" id="e0bhpf_152"><p id="e0bhpf_161"><span id="e0bhpf_162"><font style="color:#ff00ff">Perform arithmetic function on register or memory data</font></span></p></li><li class="list__item" id="e0bhpf_153"><p id="e0bhpf_163"><span id="e0bhpf_165"><font style="color:#ff00ff">Transfer control</font></span></p><ul class="list _bullet" id="e0bhpf_164"><li class="list__item" id="e0bhpf_166"><p id="e0bhpf_169">Unconditional jumps to/from procedures</p></li><li class="list__item" id="e0bhpf_167"><p id="e0bhpf_170">Conditional branches</p></li><li class="list__item" id="e0bhpf_168"><p id="e0bhpf_171">Indirect branches</p></li></ul></li></ul><section class="chapter"><h4 id="6-3-1-moving-data-instructions" data-toc="6-3-1-moving-data-instructions">6.3.1 Moving Data Instructions</h4><p id="e0bhpf_172">movq source, dest</p><p id="e0bhpf_173"><span id="e0bhpf_178"><font style="color:#8a2be2">Operand Types</font></span></p><ul class="list _bullet" id="e0bhpf_174"><li class="list__item" id="e0bhpf_179"><p id="e0bhpf_181"><span id="e0bhpf_182"><font style="color:#ff00ff">Immediate:</font></span> Constant integer data. Like C constants, but prefix with '$'.</p></li><li class="list__item" id="e0bhpf_180"><p id="e0bhpf_183"><span id="e0bhpf_186"><font style="color:#ff00ff">Memory:</font></span>: 8 consecutive bytes of memory at address given by register (for movq).</p><p id="e0bhpf_184">This is corresponding to <code class="code" id="e0bhpf_187">movq</code>. The <code class="code" id="e0bhpf_188">mov</code> instruction without a suffix is size-dependent. <code class="code" id="e0bhpf_189">mov</code> defaults to 32-bit operations when the size isn't explicitly indicated.</p><p id="e0bhpf_185">Recommend to use the explicit suffixes (movq, movl, movw, movb) whenever possible</p></li></ul><figure id="e0bhpf_175"><img alt="movq Operand Combinations" src="Computer-Science-Study-Notes/a6-2-2.png" title="movq Operand Combinations" width="2824" height="1150"></figure><p id="e0bhpf_176"><span id="e0bhpf_190"><font style="color:#8a2be2">Memory Addressing Mode</font></span></p><ol class="list _decimal" id="e0bhpf_177" type="1"><li class="list__item" id="e0bhpf_191"><p id="e0bhpf_194">Normal (R) =&gt; pointer dereferencing in C</p><p> <code class="code" id="e0bhpf_195">movq (%rcx),%rax</code> equals: </p><div class="code-block" data-lang="c">
                            rax = *rcx
                        </div></li><li class="list__item" id="e0bhpf_192"><p id="e0bhpf_197">Displacement D(R) =&gt; accessing data at a fixed offset from a base address</p><p id="e0bhpf_198"><code class="code" id="e0bhpf_200">movq 8(%rbp), %rdx</code> equals:</p><div class="code-block" data-lang="c">
                            rdx = *(((char*)rbp) + 8)
                        </div></li><li class="list__item" id="e0bhpf_193"><p id="e0bhpf_201"><span id="e0bhpf_205"><font style="color:#ff00ff">Complete Mode:</font></span> D(Rb,Ri,S)</p><ul class="list _bullet" id="e0bhpf_202"><li class="list__item" id="e0bhpf_206"><p id="e0bhpf_210"><span id="e0bhpf_211"><font style="color:#7cfc00">D:</font></span> Constant &quot;displacement&quot; 1, 2, or 4 bytes</p></li><li class="list__item" id="e0bhpf_207"><p id="e0bhpf_212"><span id="e0bhpf_213"><font style="color:#7cfc00">Rb:</font></span> Base register: Any of 16 integer registers</p></li><li class="list__item" id="e0bhpf_208"><p id="e0bhpf_214"><span id="e0bhpf_215"><font style="color:#7cfc00">Ri:</font></span> Index register: Any, except for %rsp</p></li><li class="list__item" id="e0bhpf_209"><p id="e0bhpf_216"><span id="e0bhpf_217"><font style="color:#7cfc00">S:</font></span> Scale: 1, 2, 4, or 8</p></li></ul><p id="e0bhpf_203"><span id="e0bhpf_218"><font style="color:#ff69b4">Example:</font></span> <code class="code" id="e0bhpf_219">movl (&amp;#37;rbx,&amp;#37;rdi,4), %eax</code></p><ol class="list _decimal" id="e0bhpf_204" type="1"><li class="list__item" id="e0bhpf_220"><p id="e0bhpf_223">Calculate the address: %rbx + (4 * %rdi) (e.g., base address + 4 * 5 = base address + 20).</p></li><li class="list__item" id="e0bhpf_221"><p id="e0bhpf_224">Access the 32-bit value at that calculated address.</p></li><li class="list__item" id="e0bhpf_222"><p id="e0bhpf_225">Move the retrieved value into the %eax register.</p></li></ol></li></ol></section><section class="chapter"><h4 id="6-3-2-address-aomputation-instructions" data-toc="6-3-2-address-aomputation-instructions">6.3.2 Address Computation Instructions</h4><p id="e0bhpf_226"><code class="code" id="e0bhpf_230">leaq src, dst</code></p><div class="code-block" data-lang="nasm">
                    leaq (%rdi,%rdi,2), %rax ; # Calculate the address of the element at index rdx in an array of integers pointed to by rsi (assuming 4 bytes per integer)
                </div><p id="e0bhpf_228">It can also be used for arithmetic expressions.</p><div class="code-block" data-lang="nasm">
                    leaq (%rdi,%rdi,2), %rax  ; Calculate rax = rdi + (rdi * 2) = 3 * rdi
                </div></section><section class="chapter"><h4 id="6-3-3-arithmetic-instructions" data-toc="6-3-3-arithmetic-instructions">6.3.3 Arithmetic Instructions</h4><p id="e0bhpf_231"><span id="e0bhpf_239"><font style="color:#8a2be2">Two Operand Instructions:</font></span></p><div class="table-wrapper"><table class="wide" id="e0bhpf_232"><thead><tr class="ijRowHead" id="e0bhpf_240"><th id="e0bhpf_250"><p>Format</p></th><th id="e0bhpf_251"><p>Computation</p></th></tr></thead><tbody><tr id="e0bhpf_241"><td id="e0bhpf_252"><p><code class="code" id="e0bhpf_254">addq src, dest</code></p></td><td id="e0bhpf_253"><p>dest = dest + src</p></td></tr><tr id="e0bhpf_242"><td id="e0bhpf_255"><p><code class="code" id="e0bhpf_257">subq src, dest</code></p></td><td id="e0bhpf_256"><p>dest = dest - src</p></td></tr><tr id="e0bhpf_243"><td id="e0bhpf_258"><p><code class="code" id="e0bhpf_260">imulq src, dest</code></p></td><td id="e0bhpf_259"><p>dest = dest * src</p></td></tr><tr id="e0bhpf_244"><td id="e0bhpf_261"><p><code class="code" id="e0bhpf_263">salq src, dest</code></p></td><td id="e0bhpf_262"><p>dest = dest &lt;&lt; src</p></td></tr><tr id="e0bhpf_245"><td id="e0bhpf_264"><p><code class="code" id="e0bhpf_266">sarq src, dest</code> (Arithmetic Shift)</p></td><td id="e0bhpf_265"><p>dest = dest &gt;&gt; src</p></td></tr><tr id="e0bhpf_246"><td id="e0bhpf_267"><p><code class="code" id="e0bhpf_269">shrq src, dest</code> (Logical Shift)</p></td><td id="e0bhpf_268"><p>dest = dest &gt;&gt; src</p></td></tr><tr id="e0bhpf_247"><td id="e0bhpf_270"><p><code class="code" id="e0bhpf_272">xorq src, dest</code></p></td><td id="e0bhpf_271"><p>dest = dest ^ src</p></td></tr><tr id="e0bhpf_248"><td id="e0bhpf_273"><p><code class="code" id="e0bhpf_275">andq src, dest</code></p></td><td id="e0bhpf_274"><p>dest = dest &amp; src</p></td></tr><tr id="e0bhpf_249"><td id="e0bhpf_276"><p><code class="code" id="e0bhpf_278">orq src, dest</code></p></td><td id="e0bhpf_277"><p>dest = dest | src</p></td></tr></tbody></table></div><aside class="prompt" data-type="note" data-title="" id="e0bhpf_233"><p id="e0bhpf_279">Watch out for the argument order!</p><p id="e0bhpf_280">Intel docs use &quot;op dest, src&quot;!</p></aside><p id="e0bhpf_234"><span id="e0bhpf_281"><font style="color:#8a2be2">One Operand Instructions:</font></span></p><div class="table-wrapper"><table class="wide" id="e0bhpf_235"><thead><tr class="ijRowHead" id="e0bhpf_282"><th id="e0bhpf_292"><p>Format</p></th><th id="e0bhpf_293"><p>Computation</p></th></tr></thead><tbody><tr id="e0bhpf_283"><td id="e0bhpf_294"><p><code class="code" id="e0bhpf_296">incq dest</code></p></td><td id="e0bhpf_295"><p>dest = dest + 1</p></td></tr><tr id="e0bhpf_284"><td id="e0bhpf_297"><p><code class="code" id="e0bhpf_299">decq src, dest</code></p></td><td id="e0bhpf_298"><p>dest = dest - 1</p></td></tr><tr id="e0bhpf_285"><td id="e0bhpf_300"><p><code class="code" id="e0bhpf_302">negq src, dest</code></p></td><td id="e0bhpf_301"><p>dest = - dest</p></td></tr><tr id="e0bhpf_286"><td id="e0bhpf_303"><p><code class="code" id="e0bhpf_305">notq dest</code></p></td><td id="e0bhpf_304"><p>dest = ~ dest</p></td></tr><tr id="e0bhpf_287"><td id="e0bhpf_306"><p><code class="code" id="e0bhpf_308">sarq src, dest</code> (Arithmetic Shift)</p></td><td id="e0bhpf_307"><p>dest = dest &gt;&gt; src</p></td></tr><tr id="e0bhpf_288"><td id="e0bhpf_309"><p><code class="code" id="e0bhpf_311">shrq src, dest</code> (Logical Shift)</p></td><td id="e0bhpf_310"><p>dest = dest &gt;&gt; src</p></td></tr><tr id="e0bhpf_289"><td id="e0bhpf_312"><p><code class="code" id="e0bhpf_314">xorq src, dest</code></p></td><td id="e0bhpf_313"><p>dest = dest ^ src</p></td></tr><tr id="e0bhpf_290"><td id="e0bhpf_315"><p><code class="code" id="e0bhpf_317">andq src, dest</code></p></td><td id="e0bhpf_316"><p>dest = dest &amp; src</p></td></tr><tr id="e0bhpf_291"><td id="e0bhpf_318"><p><code class="code" id="e0bhpf_320">orq src, dest</code></p></td><td id="e0bhpf_319"><p>dest = dest | src</p></td></tr></tbody></table></div><p id="e0bhpf_236"><span id="e0bhpf_321"><font style="color:#ff69b4">Example</font></span></p><div class="code-collapse" data-lang="c" data-is-expanded="false" data-synopsis="long arith(long x, long y, long z) {">
                    long arith(long x, long y, long z) {
                    long t1 = x + y;
                    long t2 = z + t1;
                    long t3 = x + 4;
                    long t4 = y * 48;
                    long t5 = t3 + t4;
                    long rval = t2 * t5;
                    return rval;
                    }
                </div><div class="code-collapse" data-lang="nasm" data-is-expanded="false" data-synopsis="0000000000001149 &lt;arith&gt;:">
                    0000000000001149 &lt;arith&gt;:
                    1149:	f3 0f 1e fa          	endbr64
                    114d:	55                   	push   %rbp
                    114e:	48 89 e5             	mov    %rsp,%rbp
                    1151:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)   # Store x on the stack
                    1155:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)   # Store y on the stack
                    1159:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)   # Store z on the stack
                    115d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx  # Load x into rdx
                    1161:	48 8b 45 c0          	mov    -0x40(%rbp),%rax  # Load y into rax
                    1165:	48 01 d0             	add    %rdx,%rax         # t1 = x + y
                    1168:	48 89 45 d0          	mov    %rax,-0x30(%rbp)   # Store t1 on the stack
                    116c:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx  # Load z into rdx
                    1170:	48 8b 45 d0          	mov    -0x30(%rbp),%rax  # Load t1 into rax
                    1174:	48 01 d0             	add    %rdx,%rax         # t2 = z + t1
                    1177:	48 89 45 d8          	mov    %rax,-0x28(%rbp)   # Store t2 on the stack
                    117b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax  # Load x into rax
                    117f:	48 83 c0 04          	add    $0x4,%rax         # t3 = x + 4
                    1183:	48 89 45 e0          	mov    %rax,-0x20(%rbp)   # Store t3 on the stack
                    1187:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx  # Load y into rdx
                    118b:	48 89 d0             	mov    %rdx,%rax         # Copy y into rax (for multiplication)
                    118e:	48 01 c0             	add    %rax,%rax         # Multiply y by 2 (left shift)
                    1191:	48 01 d0             	add    %rdx,%rax         # Add y (original value) so now its 3y
                    1194:	48 c1 e0 04          	shl    $0x4,%rax         # Multiply by 16 (left shift 4) 3y*16 = 48y
                    1198:	48 89 45 e8          	mov    %rax,-0x18(%rbp)   # Store t4 = 48 * y on the stack
                    119c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx  # Load t3 into rdx
                    11a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax  # Load t4 into rax
                    11a4:	48 01 d0             	add    %rdx,%rax         # t5 = t3 + t4
                    11a7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)   # Store t5 on the stack
                    11ab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax  # Load t2 into rax
                    11af:	48 0f af 45 f0       	imul   -0x10(%rbp),%rax  # rval = t2 * t5
                    11b4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)    # Store rval on the stack
                    11b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax   # Move rval into rax (return value)
                    11bc:	5d                   	pop    %rbp              # Restore the caller's base pointer
                    11bd:	c3                   	ret                      # Return from the function
                </div></section></section><section class="chapter"><h3 id="6-4-c-assembly-machine-code-x86" data-toc="6-4-c-assembly-machine-code-x86">6.4 C, Assembly &amp; Machine Code</h3><p id="e0bhpf_322">Compile with the following code (debugging-friendly):</p><div class="code-block" data-lang="bash">
                $ gcc –Og p1.c -o p
            </div><figure id="e0bhpf_324"><img alt="C, Assembly &amp; Machine Code" src="Computer-Science-Study-Notes/a6-4-1.png" title="C, Assembly &amp; Machine Code" width="2631" height="1242"></figure><p id="e0bhpf_325">Use the following command to generate the assembly code:</p><div class="code-block" data-lang="bash">
                $ gcc –Og –S p1.c
            </div><p id="e0bhpf_327">Use the following command to disassembly the machine code:</p><div class="code-block" data-lang="bash">
                $ objdump –d p1
            </div></section></section><section class="chapter"><h2 id="7-control-flow-instructions-x86" data-toc="7-control-flow-instructions-x86">7 Control Flow Instructions</h2><section class="chapter"><h3 id="7-1-conditional-codes-x86" data-toc="7-1-conditional-codes-x86">7.1 Conditional Codes</h3><p id="e0bhpf_333"><span id="e0bhpf_339"><font style="color:#8a2be2">Processor State (Partial)</font></span></p><ul class="list _bullet" id="e0bhpf_334"><li class="list__item" id="e0bhpf_340"><p id="e0bhpf_344"><span id="e0bhpf_345"><font style="color:#ff00ff">Temporary Data:</font></span> %rax, ...</p></li><li class="list__item" id="e0bhpf_341"><p id="e0bhpf_346"><span id="e0bhpf_347"><font style="color:#ff00ff">Location of runtime stack:</font></span> %rsp, ...</p></li><li class="list__item" id="e0bhpf_342"><p id="e0bhpf_348"><span id="e0bhpf_349"><font style="color:#ff00ff">Location of current code control point:</font></span> %rip, ...</p></li><li class="list__item" id="e0bhpf_343"><p id="e0bhpf_350"><span id="e0bhpf_351"><font style="color:#ff00ff">Status of recent tests:</font></span> CF, ZF, SF, OF, ... =&gt; Conditional Codes!</p></li></ul><p id="e0bhpf_335"><span id="e0bhpf_352"><font style="color:#8a2be2">Conditional Codes</font></span></p><ul class="list _bullet" id="e0bhpf_336"><li class="list__item" id="e0bhpf_353"><p id="e0bhpf_355">Single bit registers, GDB prints these as one &quot;rflags&quot; register or &quot;eflags&quot;(more commonly used, lower 32 bits).</p></li><li class="list__item" id="e0bhpf_354"><p id="e0bhpf_356">Implicitly set (as side effect) of arithmetic operations.</p><ul class="list _bullet" id="e0bhpf_357"><li class="list__item" id="e0bhpf_358"><p id="e0bhpf_362"><span id="e0bhpf_363"><font style="color:#ff00ff">CF (Carry Flag):</font></span> Overflowing or underflowing in an unsigned range.</p></li><li class="list__item" id="e0bhpf_359"><p id="e0bhpf_364"><span id="e0bhpf_365"><font style="color:#ff00ff">ZF (Zero Flag):</font></span> The result of an operation is zero</p></li><li class="list__item" id="e0bhpf_360"><p id="e0bhpf_366"><span id="e0bhpf_367"><font style="color:#ff00ff">SF (Sign Flag):</font></span> The result of an operation, interpreted as a signed two's complement number, is negative (MSB is 1).</p></li><li class="list__item" id="e0bhpf_361"><p id="e0bhpf_368"><span id="e0bhpf_369"><font style="color:#ff00ff">OF (Overflow FLag):</font></span> Overflow in signed two's complement.</p></li></ul></li></ul><p id="e0bhpf_337"><span id="e0bhpf_370"><font style="color:#8a2be2">Instructions</font></span></p><ol class="list _decimal" id="e0bhpf_338" type="1"><li class="list__item" id="e0bhpf_371"><p id="e0bhpf_373"><code class="code" id="e0bhpf_376">cmp a, b</code></p><p id="e0bhpf_374">Computes <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="4.933ex" height="1.756ex" role="img" focusable="false" viewBox="0 -694 2180.4 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(651.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(1651.4,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g></g></g></svg></mjx-container>, set conditional codes based on result, <span id="e0bhpf_378"><font style="color:#ff4500">but does not change b!</font></span></p><p id="e0bhpf_375">Used for <code class="code" id="e0bhpf_379">if (a &lt; b)</code></p></li><li class="list__item" id="e0bhpf_372"><p id="e0bhpf_380"><code class="code" id="e0bhpf_384">test a, b</code></p><p id="e0bhpf_381">Computes <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="4.072ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 1800 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="merror" data-mjx-error="Misplaced &" title="Misplaced &"><rect data-background="true" width="1800" height="950" y="-200"></rect><title>Misplaced &</title><g data-mml-node="mtext" style="font-family: serif;"><text data-variant="-explicitFont" transform="scale(1,-1)" font-size="884px">b&amp;a</text></g></g></g></g></svg></mjx-container>, set conditional codes based on the result, <span id="e0bhpf_386"><font style="color:#ff4500">but does not change b!</font></span></p><p id="e0bhpf_382"><span id="e0bhpf_387"><font style="color:#ff00ff">Most common use:</font></span> <code class="code" id="e0bhpf_388">test %rx, %rx</code> to compare %rx to zero</p><p id="e0bhpf_383"><span id="e0bhpf_389"><font style="color:#ff00ff">Second most common use:</font></span> <code class="code" id="e0bhpf_390">test %rX, %rY</code> to test if any of the 1-bits in <code class="code" id="e0bhpf_391">%rY</code> are also 1 in <code class="code" id="e0bhpf_392">%rX</code>.</p></li></ol></section><section class="chapter"><h3 id="7-2-conditional-Branches-x86" data-toc="7-2-conditional-Branches-x86">7.2 Conditional Branches</h3><p id="e0bhpf_393"><span id="e0bhpf_402"><font style="color:#8a2be2">Jumping</font></span></p><div class="table-wrapper"><table class="wide" id="e0bhpf_394"><thead><tr class="ijRowHead" id="e0bhpf_403"><th id="e0bhpf_415"><p><code class="code" id="e0bhpf_418">jX</code></p></th><th id="e0bhpf_416"><p>Condition</p></th><th id="e0bhpf_417"><p>Description</p></th></tr></thead><tbody><tr id="e0bhpf_404"><td id="e0bhpf_419"><p><code class="code" id="e0bhpf_422">jmp</code></p></td><td id="e0bhpf_420"><p>1</p></td><td id="e0bhpf_421"><p>Unconditional</p></td></tr><tr id="e0bhpf_405"><td id="e0bhpf_423"><p><code class="code" id="e0bhpf_426">je</code></p></td><td id="e0bhpf_424"><p><code class="code" id="e0bhpf_427">ZF</code></p></td><td id="e0bhpf_425"><p>Equal/Zero</p></td></tr><tr id="e0bhpf_406"><td id="e0bhpf_428"><p><code class="code" id="e0bhpf_431">jne</code></p></td><td id="e0bhpf_429"><p><code class="code" id="e0bhpf_432">~ZF</code></p></td><td id="e0bhpf_430"><p>Not Equal/Not Zero</p></td></tr><tr id="e0bhpf_407"><td id="e0bhpf_433"><p><code class="code" id="e0bhpf_436">js</code></p></td><td id="e0bhpf_434"><p><code class="code" id="e0bhpf_437">SF</code></p></td><td id="e0bhpf_435"><p>Negative</p></td></tr><tr id="e0bhpf_408"><td id="e0bhpf_438"><p><code class="code" id="e0bhpf_441">jns</code></p></td><td id="e0bhpf_439"><p><code class="code" id="e0bhpf_442">~SF</code></p></td><td id="e0bhpf_440"><p>Non-Negative</p></td></tr><tr id="e0bhpf_409"><td id="e0bhpf_443"><p><code class="code" id="e0bhpf_446">jq</code></p></td><td id="e0bhpf_444"><p><code class="code" id="e0bhpf_447">~(SF^OF)&amp;~ZF</code></p></td><td id="e0bhpf_445"><p>Greater (Signed)</p></td></tr><tr id="e0bhpf_410"><td id="e0bhpf_448"><p><code class="code" id="e0bhpf_451">jqe</code></p></td><td id="e0bhpf_449"><p><code class="code" id="e0bhpf_452">~(SF^OF)</code></p></td><td id="e0bhpf_450"><p>Greater or Equal (Signed)</p></td></tr><tr id="e0bhpf_411"><td id="e0bhpf_453"><p><code class="code" id="e0bhpf_456">jl</code></p></td><td id="e0bhpf_454"><p><code class="code" id="e0bhpf_457">(SF^OF)</code></p></td><td id="e0bhpf_455"><p>Less (Signed)</p></td></tr><tr id="e0bhpf_412"><td id="e0bhpf_458"><p><code class="code" id="e0bhpf_461">jle</code></p></td><td id="e0bhpf_459"><p><code class="code" id="e0bhpf_462">(SF^OF)|ZF</code></p></td><td id="e0bhpf_460"><p>Less or Equal (Signed)</p></td></tr><tr id="e0bhpf_413"><td id="e0bhpf_463"><p><code class="code" id="e0bhpf_466">ja</code></p></td><td id="e0bhpf_464"><p><code class="code" id="e0bhpf_467">~CF&amp;~ZF</code></p></td><td id="e0bhpf_465"><p>Above (unsigned)</p></td></tr><tr id="e0bhpf_414"><td id="e0bhpf_468"><p><code class="code" id="e0bhpf_471">jb</code></p></td><td id="e0bhpf_469"><p><code class="code" id="e0bhpf_472">CF</code></p></td><td id="e0bhpf_470"><p>Below (unsigned)</p></td></tr></tbody></table></div><p id="e0bhpf_395"><span id="e0bhpf_473"><font style="color:#8a2be2"><code class="code" id="e0bhpf_475">SetX</code> Instructions:</font></span> Set low-order byte of destination to 0 or 1 based on combinations of condition codes. <span id="e0bhpf_474"><font style="color:#ff4500">Does not alter remaining 7 bytes!</font></span></p><div class="table-wrapper"><table class="wide" id="e0bhpf_396"><thead><tr class="ijRowHead" id="e0bhpf_476"><th id="e0bhpf_487"><p><code class="code" id="e0bhpf_490">SetX</code></p></th><th id="e0bhpf_488"><p>Condition</p></th><th id="e0bhpf_489"><p>Description</p></th></tr></thead><tbody><tr id="e0bhpf_477"><td id="e0bhpf_491"><p><code class="code" id="e0bhpf_494">sete</code></p></td><td id="e0bhpf_492"><p><code class="code" id="e0bhpf_495">ZF</code></p></td><td id="e0bhpf_493"><p>Equal/Zero</p></td></tr><tr id="e0bhpf_478"><td id="e0bhpf_496"><p><code class="code" id="e0bhpf_499">setne</code></p></td><td id="e0bhpf_497"><p><code class="code" id="e0bhpf_500">~ZF</code></p></td><td id="e0bhpf_498"><p>Not Equal/Not Zero</p></td></tr><tr id="e0bhpf_479"><td id="e0bhpf_501"><p><code class="code" id="e0bhpf_504">sets</code></p></td><td id="e0bhpf_502"><p><code class="code" id="e0bhpf_505">SF</code></p></td><td id="e0bhpf_503"><p>Negative</p></td></tr><tr id="e0bhpf_480"><td id="e0bhpf_506"><p><code class="code" id="e0bhpf_509">setns</code></p></td><td id="e0bhpf_507"><p><code class="code" id="e0bhpf_510">~SF</code></p></td><td id="e0bhpf_508"><p>Non-Negative</p></td></tr><tr id="e0bhpf_481"><td id="e0bhpf_511"><p><code class="code" id="e0bhpf_514">setg</code></p></td><td id="e0bhpf_512"><p><code class="code" id="e0bhpf_515">~(SF^OF)&amp;~ZF</code></p></td><td id="e0bhpf_513"><p>Greater (Signed)</p></td></tr><tr id="e0bhpf_482"><td id="e0bhpf_516"><p><code class="code" id="e0bhpf_519">setge</code></p></td><td id="e0bhpf_517"><p><code class="code" id="e0bhpf_520">~(SF^OF)</code></p></td><td id="e0bhpf_518"><p>Greater or Equal (Signed)</p></td></tr><tr id="e0bhpf_483"><td id="e0bhpf_521"><p><code class="code" id="e0bhpf_524">setl</code></p></td><td id="e0bhpf_522"><p><code class="code" id="e0bhpf_525">(SF^OF)</code></p></td><td id="e0bhpf_523"><p>Less (Signed)</p></td></tr><tr id="e0bhpf_484"><td id="e0bhpf_526"><p><code class="code" id="e0bhpf_529">setle</code></p></td><td id="e0bhpf_527"><p><code class="code" id="e0bhpf_530">(SF^OF)|ZF</code></p></td><td id="e0bhpf_528"><p>Less or Equal (Signed)</p></td></tr><tr id="e0bhpf_485"><td id="e0bhpf_531"><p><code class="code" id="e0bhpf_534">seta</code></p></td><td id="e0bhpf_532"><p><code class="code" id="e0bhpf_535">~CF&amp;~ZF</code></p></td><td id="e0bhpf_533"><p>Above (unsigned)</p></td></tr><tr id="e0bhpf_486"><td id="e0bhpf_536"><p><code class="code" id="e0bhpf_539">setb</code></p></td><td id="e0bhpf_537"><p><code class="code" id="e0bhpf_540">CF</code></p></td><td id="e0bhpf_538"><p>Below (unsigned)</p></td></tr></tbody></table></div><aside class="prompt" data-type="note" data-title="" id="e0bhpf_397"><p id="e0bhpf_541">Typically use <code class="code" id="e0bhpf_543">movzbl</code> to finish job</p><p id="e0bhpf_542"><code class="code" id="e0bhpf_544">movzbl</code> takes this byte and zero-extends it into a larger 32-bit register or memory location. Zero-extending means it copies the byte into the lower 8 bits of the destination and fills the remaining higher bits with zeros.</p></aside><p id="e0bhpf_398"><span id="e0bhpf_545"><font style="color:#8a2be2">Normal version vs. goto version</font></span></p><div class="code-comparer" id="e0bhpf_399" data-comparing="vertically"><div class="code-block" data-lang="c" data-title="Normal version">
                    #include &lt;stdio.h&gt;

                    int main() {
                    int x = 5;

                    if (x &gt; 3) {
                    printf(&quot;x is greater than 3\n&quot;);
                    } else {
                    printf(&quot;x is less than or equal to 3\n&quot;);
                    }

                    return 0;
                    }
                </div><div class="code-block" data-lang="c" data-title="goto version">
                    #include &lt;stdio.h&gt;

                    int main() {
                    int x = 5;

                    if (x &gt; 3) {
                    goto greater_than_three;
                    } else {
                    goto less_than_or_equal_to_three;
                    }

                    greater_than_three:
                    printf(&quot;x is greater than 3\n&quot;);
                    goto end; // Jump to the end to avoid the other block

                    less_than_or_equal_to_three:
                    printf(&quot;x is less than or equal to 3\n&quot;);

                    end:
                    return 0;
                    }
                </div></div><p id="e0bhpf_400"><span id="e0bhpf_548"><font style="color:#cd5c5c">Example</font></span></p><div class="code-collapse" data-lang="nasm" data-is-expanded="false" data-synopsis="0000000000000000 &lt;main&gt;:">
                0000000000000000 &lt;main&gt;:
                #include &lt;stdio.h&gt;

                int main() {
                0:	f3 0f 1e fa          	endbr64
                4:	55                   	push   %rbp
                5:	48 89 e5             	mov    %rsp,%rbp
                8:	48 83 ec 10          	sub    $0x10,%rsp
                int y = 15;
                c:	c7 45 fc 0f 00 00 00 	movl   $0xf,-0x4(%rbp)

                if (y &lt; 10) {
                13:	83 7d fc 09          	cmpl   $0x9,-0x4(%rbp)
                17:	7f 05                	jg     1e &lt;main+0x1e&gt;
                y = y * 2;
                19:	d1 65 fc             	shll   $1,-0x4(%rbp)
                1c:	eb 04                	jmp    22 &lt;main+0x22&gt;
                } else {
                y = y + 1;
                1e:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
                }

                printf(&quot;y = %d\n&quot;, y);
                22:	8b 45 fc             	mov    -0x4(%rbp),%eax
                25:	89 c6                	mov    %eax,%esi
                27:	48 8d 05 00 00 00 00 	lea    0x0(%rip),%rax        # 2e &lt;main+0x2e&gt;
                2e:	48 89 c7             	mov    %rax,%rdi
                31:	b8 00 00 00 00       	mov    $0x0,%eax
                36:	e8 00 00 00 00       	call   3b &lt;main+0x3b&gt;
                return 0;
                3b:	b8 00 00 00 00       	mov    $0x0,%eax
                40:	c9                   	leave
                41:	c3                   	ret
            </div></section><section class="chapter"><h3 id="7-3-loops-x86" data-toc="7-3-loops-x86">7.3 Loops</h3><p id="e0bhpf_549"><span id="e0bhpf_551"><font style="color:#cd5c5c">Example</font></span></p><div class="code-collapse" data-lang="nasm" data-is-expanded="false" data-synopsis="0000000000000000 &lt;main&gt;:">
                0000000000000000 &lt;main&gt;:
                #include &lt;stdio.h&gt;

                int main() {
                0:	f3 0f 1e fa          	endbr64
                4:	55                   	push   %rbp
                5:	48 89 e5             	mov    %rsp,%rbp
                8:	48 83 ec 10          	sub    $0x10,%rsp
                int i;
                for (i = 0; i &lt; 5; i++) {
                c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
                13:	eb 1d                	jmp    32 &lt;main+0x32&gt;
                printf(&quot;Iteration: %d\n&quot;, i);
                15:	8b 45 fc             	mov    -0x4(%rbp),%eax
                18:	89 c6                	mov    %eax,%esi
                1a:	48 8d 05 00 00 00 00 	lea    0x0(%rip),%rax        # 21 &lt;main+0x21&gt;
                21:	48 89 c7             	mov    %rax,%rdi
                24:	b8 00 00 00 00       	mov    $0x0,%eax
                29:	e8 00 00 00 00       	call   2e &lt;main+0x2e&gt;
                for (i = 0; i &lt; 5; i++) {
                2e:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
                32:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
                36:	7e dd                	jle    15 &lt;main+0x15&gt;
                }
                return 0;
                38:	b8 00 00 00 00       	mov    $0x0,%eax
                3d:	c9                   	leave
                3e:	c3                   	ret
            </div></section><section class="chapter"><h3 id="7-4-switch-statements-x86" data-toc="7-4-switch-statements-x86">7.4 Switch Statements</h3><p id="e0bhpf_552"><span id="e0bhpf_554"><font style="color:#cd5c5c">Example</font></span></p><div class="code-collapse" data-lang="nasm" data-is-expanded="false" data-synopsis="0000000000000000 &lt;main&gt;:">
                0000000000000000 &lt;main&gt;:
                #include &lt;stdio.h&gt;

                int main() {
                0:	f3 0f 1e fa          	endbr64
                4:	55                   	push   %rbp
                5:	48 89 e5             	mov    %rsp,%rbp
                8:	48 83 ec 10          	sub    $0x10,%rsp
                int x = 2;
                c:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%rbp)
                int result = 0;
                13:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)

                switch (x) {
                1a:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
                1e:	74 26                	je     46 &lt;main+0x46&gt;
                20:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
                24:	7f 29                	jg     4f &lt;main+0x4f&gt;
                26:	83 7d fc 01          	cmpl   $0x1,-0x4(%rbp)
                2a:	74 08                	je     34 &lt;main+0x34&gt;
                2c:	83 7d fc 02          	cmpl   $0x2,-0x4(%rbp)
                30:	74 0b                	je     3d &lt;main+0x3d&gt;
                32:	eb 1b                	jmp    4f &lt;main+0x4f&gt;
                case 1:
                result = 10;
                34:	c7 45 f8 0a 00 00 00 	movl   $0xa,-0x8(%rbp)
                break;
                3b:	eb 19                	jmp    56 &lt;main+0x56&gt;
                case 2:
                result = 20;
                3d:	c7 45 f8 14 00 00 00 	movl   $0x14,-0x8(%rbp)
                break;
                44:	eb 10                	jmp    56 &lt;main+0x56&gt;
                case 3:
                result = 30;
                46:	c7 45 f8 1e 00 00 00 	movl   $0x1e,-0x8(%rbp)
                break;
                4d:	eb 07                	jmp    56 &lt;main+0x56&gt;
                default:
                result = 0;
                4f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
                }

                printf(&quot;Result: %d\n&quot;, result);
                56:	8b 45 f8             	mov    -0x8(%rbp),%eax
                59:	89 c6                	mov    %eax,%esi
                5b:	48 8d 05 00 00 00 00 	lea    0x0(%rip),%rax        # 62 &lt;main+0x62&gt;
                62:	48 89 c7             	mov    %rax,%rdi
                65:	b8 00 00 00 00       	mov    $0x0,%eax
                6a:	e8 00 00 00 00       	call   6f &lt;main+0x6f&gt;
                return 0;
                6f:	b8 00 00 00 00       	mov    $0x0,%eax
                74:	c9                   	leave
                75:	c3                   	ret
            </div></section></section><section class="chapter"><h2 id="8-program-optimization" data-toc="8-program-optimization">8 Program Optimization</h2><p id="e0bhpf_555"><span id="e0bhpf_561"><font style="color:#8a2be2">Limitations of Optimizing Compilers</font></span></p><ul class="list _bullet" id="e0bhpf_556"><li class="list__item" id="e0bhpf_562"><p id="e0bhpf_566">Operate under fundamental constraint.</p></li><li class="list__item" id="e0bhpf_563"><p id="e0bhpf_567">Behavior that may be obvious to programmers can be obfuscated by languages and code styles.</p></li><li class="list__item" id="e0bhpf_564"><p id="e0bhpf_568">When in doubt, the compiler must be conservative.</p></li><li class="list__item" id="e0bhpf_565"><p id="e0bhpf_569">...</p></li></ul><section class="chapter"><h3 id="8-1-generally-useful-optimizations" data-toc="8-1-generally-useful-optimizations">8.1 Generally Useful Optimizations</h3><ul class="list _bullet" id="e0bhpf_570"><li class="list__item" id="e0bhpf_571"><p id="e0bhpf_575"><span id="e0bhpf_577"><font style="color:#ff00ff">Reduce frequency with which computation performed</font></span></p><div class="code-comparer" id="e0bhpf_576" data-comparing="vertically"><div class="code-block" data-lang="c" data-title="Raw">
                            void set_row(double *a, double *b, long i, long n) {
                            long j;
                            for (j = 0; j &lt; n; j++) {
                            a[i * n + j] = b[j];
                            }
                            }
                        </div><div class="code-block" data-lang="c" data-title="Optimized">
                            void set_row(double *a, double *b, long i, long n) {
                            long j;
                            int ni = n + i;
                            for (j = 0; j &lt; n; j++) {
                            a[ni + j] = b[j];
                            }
                            }
                        </div></div></li><li class="list__item" id="e0bhpf_572"><p id="e0bhpf_580"><span id="e0bhpf_582"><font style="color:#ff00ff">Reduction in Strength: Shift, add instead of multiply or divide</font></span></p><div class="code-comparer" id="e0bhpf_581" data-comparing="vertically"><div class="code-block" data-lang="c" data-title="Raw">
                            for (int i = 0; i &lt; n; i++) {
                            int ni = n * i;
                            for (int j = 0; j &lt; n; j++)
                            a[ni + j] = b[j];
                            }
                        </div><div class="code-block" data-lang="c" data-title="Optimized">
                            int ni = 0;
                            for (int i = 0; i &lt; n; i++) {
                            for (int j = 0; j &lt; n; j++)
                            a[ni + j] = b[j];
                            ni += n;
                            }
                        </div></div></li><li class="list__item" id="e0bhpf_573"><p id="e0bhpf_585"><span id="e0bhpf_587"><font style="color:#ff00ff">Share Common Subexpressions</font></span></p><div class="code-comparer" id="e0bhpf_586" data-comparing="vertically"><div class="code-block" data-lang="c" data-title="Raw">
                            /* Sum neighbors of i, j */
                            up = val[(i - 1) * n + j];
                            down = val[(i + 1) * n + j];
                            left = val[i * n + j - 1];
                            down = val[i * n + j + 1];
                            sum = up + down + left + right;
                            // 3 multiplications
                        </div><div class="code-block" data-lang="c" data-title="Optimized">
                            long inj = i * n + j;
                            up = val[inj - n];
                            down = val[inj + n];
                            left = val[inj - 1];
                            down = val[inj + 1];
                            sum = up + down + left + right;
                            // 1 multiplication
                        </div></div></li><li class="list__item" id="e0bhpf_574"><p id="e0bhpf_590"><span id="e0bhpf_591"><font style="color:#ff00ff">Remove unnecessary procedure calls</font></span></p></li></ul></section><section class="chapter"><h3 id="8-2-optimization-blockers" data-toc="8-2-optimization-blockers">8.2 Optimization Blockers</h3><ul class="list _bullet" id="e0bhpf_592"><li class="list__item" id="procedure-calls"><p id="e0bhpf_595"><span id="e0bhpf_598"><font style="color:#ff00ff">Procedure Calls</font></span></p><div class="code-comparer" id="e0bhpf_596" data-comparing="vertically"><div class="code-block" data-lang="none" data-title="Raw">
                            /* Convert string to lower case with quadratic performance*/
                            void lower(char* s) {
                            size_t i;
                            for (i = 0; i &lt; strlen(s); i++) {
                            if (s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z')
                            s[i] += 'a' - 'A';
                            }
                            }
                        </div><div class="code-block" data-lang="none" data-title="Optimized">
                            /* Optimized code */
                            void lower(char* s) {
                            size_t i;
                            size_t len = strlen(s);
                            for (i = 0; i &lt; len; i++) {
                            if (s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z')
                            s[i] += 'a' - 'A';
                            }
                            }
                        </div></div><ul class="list _bullet" id="e0bhpf_597"><li class="list__item" id="e0bhpf_601"><p id="e0bhpf_603"><code class="code" id="e0bhpf_604">strlen()</code> takes linear time to scan the string until it reaches the null character.</p></li><li class="list__item" id="e0bhpf_602"><p id="e0bhpf_605">Why couldn't compiler move <code class="code" id="e0bhpf_607">strlen()</code> out of inner loop?</p><ul class="list _bullet" id="e0bhpf_606"><li class="list__item" id="e0bhpf_608"><p id="e0bhpf_612">Procedure may have side effects.</p></li><li class="list__item" id="e0bhpf_609"><p id="e0bhpf_613">Function may not return the same value for a given argument.</p></li><li class="list__item" id="e0bhpf_610"><p id="e0bhpf_614">Compiler treats procedure call as a black box =&gt; weak optimizaion!</p></li><li class="list__item" id="e0bhpf_611"><p id="e0bhpf_615">You can use GCC with inline functions and optimization O1, but better do yur own code motion.</p></li></ul></li></ul></li><li class="list__item" id="e0bhpf_594"><p id="e0bhpf_616"><span id="e0bhpf_620"><font style="color:#ff00ff">Memory Alias</font></span></p><div class="code-block" data-lang="c">
                        void sum_rows1(double *a, double *b, long n)  {
                        long i, j;
                        for (i = 0; i &lt; n; i++) {
                        b[i] = 0;
                        for (j = 0; j &lt; n; j++) {
                        b[i] += a[i * n + j];
                        }
                        }
                        }

                        int main() {
                        double A[9] =
                        {0, 1, 2,
                        4, 8, 16,
                        32, 64, 128};
                        double B[3] = A + 3;
                        sum_rows1(A, B, 3);
                        return 0;
                        }
                    </div><p id="e0bhpf_618">Memory and registers have to pass values over and over again!</p><p id="e0bhpf_619">The optimizer cannot optimize because the code may updates a[i] on every iteration!</p></li></ul></section><section class="chapter"><h3 id="8-3-exploit-instruction-level-parallelism" data-toc="8-3-exploit-instruction-level-parallelism">8.3 Exploit Instruction-Level Parallelism</h3><p id="e0bhpf_621"><span id="e0bhpf_641"><font style="color:#ff8c00">CPE (Cycle Per Element)</font></span></p><ul class="list _bullet" id="e0bhpf_622"><li class="list__item" id="e0bhpf_642"><p id="e0bhpf_644">Convenient way to express performance of program that operates on vectors or lists.</p></li><li class="list__item" id="e0bhpf_643"><p id="e0bhpf_645">Cycles = CPE*n + Overhead, CPE is slope of line.</p></li></ul><figure id="e0bhpf_623"><img alt="CPE" src="Computer-Science-Study-Notes/a8-3-1.png" title="CPE" width="1890" height="1076"></figure><p id="e0bhpf_624"><span id="e0bhpf_646"><font style="color:#8a2be2">Modern CPU Design</font></span></p><figure id="e0bhpf_625"><img alt="Modern CPU Design" src="Computer-Science-Study-Notes/a8-3-2.png" title="Modern CPU Design" width="2465" height="1756"></figure><p id="e0bhpf_626"><span id="e0bhpf_647"><font style="color:#8a2be2">Pipelined Functional Units</font></span></p><figure id="e0bhpf_627"><img alt="Pipelined Functional Units" src="Computer-Science-Study-Notes/a8-3-3.png" title="Pipelined Functional Units" width="2685" height="1397"></figure><ul class="list _bullet" id="e0bhpf_628"><li class="list__item" id="e0bhpf_648"><p id="e0bhpf_650">Divide computation into stages.</p></li><li class="list__item" id="e0bhpf_649"><p id="e0bhpf_651">Pass partial computations from stage to stage.</p></li></ul><p id="e0bhpf_629"><span id="e0bhpf_652"><font style="color:#8a2be2">Loop Unrolling:</font></span> Reason: Breaks sequential dependency</p><p id="e0bhpf_630"><span id="e0bhpf_653"><font style="color:#cd5c5c">No Loop Unrolling</font></span></p><div class="code-block" data-lang="c">
                for (i = 0; i &lt; length; i++) {
                x = x + d[i];
                }
            </div><figure id="e0bhpf_632"><img alt="No Loop Unrolling" src="Computer-Science-Study-Notes/a8-3-4.png" title="No Loop Unrolling" width="1077" height="1474"></figure><p id="e0bhpf_633"><span id="e0bhpf_654"><font style="color:#cd5c5c">Loop Unrolling (<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="4.023ex" height="1.507ex" role="img" focusable="false" viewBox="0 -666 1778 666"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(778,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1278,0)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container>)</font></span></p><div class="code-block" data-lang="c">
                for (int i = 0; i &lt; limit; i +=2)
                x = x + d[i] + d[i + 1];
                }
            </div><p id="e0bhpf_635"><span id="e0bhpf_656"><font style="color:#cd5c5c">Loop Unrolling (<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex;" xmlns="http://www.w3.org/2000/svg" width="5.219ex" height="1.529ex" role="img" focusable="false" viewBox="0 -666 2307 676"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(778,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1278,0)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g></g></g></g></svg></mjx-container>)</font></span></p><div class="code-block" data-lang="c">
                for (int i = 0; i &lt; limit; i +=2)
                x = x + (d[i] + d[i + 1]);
                }
            </div><figure id="e0bhpf_637"><img alt="Loop Unrolling (2*1a)" src="Computer-Science-Study-Notes/a8-3-5.png" title="Loop Unrolling (2*1a)" width="3000" height="2250"></figure><p id="e0bhpf_638"><span id="e0bhpf_658"><font style="color:#cd5c5c">Loop Unrolling (<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="4.023ex" height="1.507ex" role="img" focusable="false" viewBox="0 -666 1778 666"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(778,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1278,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g></svg></mjx-container>)</font></span></p><div class="code-block" data-lang="c">
                for (int i = 0; i &lt; limit; i +=4)
                x0 = x0 + d[i];
                x1 = x1 + d[i + 1];
                }
            </div><figure id="e0bhpf_640"><img alt="Loop Unrolling (2*2)" src="Computer-Science-Study-Notes/a8-3-6.png" title="Loop Unrolling (2*2)" width="1243" height="1000"></figure></section><section class="chapter"><h3 id="8-4-dealing-with-conditions" data-toc="8-4-dealing-with-conditions">8.4 Dealing with Conditions</h3><p id="e0bhpf_660"><span id="e0bhpf_662"><font style="color:#ff4500">Instruction Control Unit</font></span> must work well ahead of <span id="e0bhpf_663"><font style="color:#ff4500">Execution Unit</font></span> to generate enough operations to keep EU busy!</p><section class="procedure-steps"><h3 id="e0bhpf_661" data-toc="e0bhpf_661">Branch Prediction</h3><ol class="list _decimal"><li class="list__item" id="e0bhpf_664"><p id="e0bhpf_667">Guess which way branch will go.</p></li><li class="list__item" id="e0bhpf_665"><p id="e0bhpf_668">Begin executing instructions at predicted position, but don&rsquo;t actually modify register or memory data.</p></li><li class="list__item" id="e0bhpf_666"><p id="e0bhpf_669">If correct, execute; if mispredict, recover.</p></li></ol></section></section></section><section class="chapter"><h2 id="9-memory-hierarchy" data-toc="9-memory-hierarchy">9 Memory Hierarchy</h2></section><section class="chapter"><h2 id="10-linking" data-toc="10-linking">10 Linking</h2><p id="e0bhpf_670"><span id="e0bhpf_684"><font style="color:#cd5c5c">Example</font></span></p><p id="e0bhpf_671">main.c</p><div class="code-collapse" data-lang="c" data-is-expanded="false" data-synopsis="int sum(int *a, int n);">
            int sum(int *a, int n);

            int array[2] = {1, 2};

            int main() {
                int val = sum(array, 2);
                return val;
            }
        </div><p id="e0bhpf_673">sum.c</p><div class="code-collapse" data-lang="c" data-is-expanded="false" data-synopsis="int sum(int *a, int n) {">
            int sum(int *a, int n) {
                int i, s = 0;
                for (i = 0; i &lt; n; i++) {
                    s += a[i];
                }
                return s;
            }
        </div><p id="e0bhpf_675">Compile with the following command:</p><div class="code-block" data-lang="bash">
            $ gcc -Og -o prog main.c sum.c
            $ ./prog
        </div><figure id="e0bhpf_677"><img alt="Linking" src="Computer-Science-Study-Notes/ax10-1-1.png" title="Linking" width="2613" height="1100"></figure><p id="e0bhpf_678"><span id="e0bhpf_685"><font style="color:#8a2be2">Advantages of linkers</font></span></p><ol class="list _decimal" id="e0bhpf_679" type="1"><li class="list__item" id="e0bhpf_686"><p id="e0bhpf_688"><span id="e0bhpf_689"><font style="color:#ff00ff">Modularity:</font></span> Program can be written as a collection of smaller source files, rather than one monolithic mass. Can build libraries of common functions.</p></li><li class="list__item" id="e0bhpf_687"><p id="e0bhpf_690"><span id="e0bhpf_691"><font style="color:#ff00ff">Efficiency:</font></span> Separate compilation and libraries.</p></li></ol><p id="e0bhpf_680"><span id="e0bhpf_692"><font style="color:#8a2be2">Types of linking</font></span></p><ul class="list _bullet" id="e0bhpf_681"><li class="list__item" id="e0bhpf_693"><p id="e0bhpf_695"><span id="e0bhpf_696"><font style="color:#ff00ff">Static Linking:</font></span> Executable files and running memory images contain only the library code they actually use.</p></li><li class="list__item" id="e0bhpf_694"><p id="e0bhpf_697"><span id="e0bhpf_698"><font style="color:#ff00ff">Dynamic Linking:</font></span> Executable files contain no library code. During execution, single copy of library code can be shared across all executing processes.</p></li></ul><section class="chapter"><h3 id="10-1-static-linking" data-toc="10-1-static-linking">10.1 Static Linking</h3><section class="procedure-steps"><h3 id="e0bhpf_699" data-toc="e0bhpf_699">Static Linking</h3><ol class="list _decimal"><li class="list__item" id="e0bhpf_702"><p id="e0bhpf_704"><span id="e0bhpf_707"><font style="color:#ff00ff">Symbol resolution</font></span></p><p id="e0bhpf_705">Programs define and reference symbols (global variables, functions, <span id="e0bhpf_708"><i>static</i></span> variable (with static attribute)).</p><p id="e0bhpf_706">Symbol definitions are stored in object file (by assembler) in symbol table. During symbol resolution step, the linker associates each symbol reference with exactly one symbol definition.</p></li><li class="list__item" id="e0bhpf_703"><p id="e0bhpf_709"><span id="e0bhpf_711"><font style="color:#ff00ff">Relocation</font></span></p><ul class="list _bullet" id="e0bhpf_710"><li class="list__item" id="e0bhpf_712"><p id="e0bhpf_715">Merges separate code and data sections into single sections.</p></li><li class="list__item" id="e0bhpf_713"><p id="e0bhpf_716">Relocates symbols from their relative locations in the <code class="code" id="e0bhpf_717">.o</code> files to their final absolute memory locations in the executable.</p></li><li class="list__item" id="e0bhpf_714"><p id="e0bhpf_718">Updates all references to these symbols to reflect their new positions.</p></li></ul></li></ol></section><p id="e0bhpf_700"><span id="e0bhpf_719"><font style="color:#8a2be2">Three types of object files</font></span></p><ul class="list _bullet" id="e0bhpf_701"><li class="list__item" id="e0bhpf_720"><p id="e0bhpf_723"><span id="e0bhpf_724"><font style="color:#ff00ff">Relocatable object file (<code class="code" id="e0bhpf_725">.o</code> file):</font></span> Contains code and data in a form that can be combined with other relocatable object files to form executable object file.</p></li><li class="list__item" id="e0bhpf_721"><p id="e0bhpf_726"><span id="e0bhpf_727"><font style="color:#ff00ff">Executable object file (<code class="code" id="e0bhpf_728">a.out</code> file)</font></span> Contains code and data in a form that can be copied directly into memory and then executed.</p></li><li class="list__item" id="e0bhpf_722"><p id="e0bhpf_729"><span id="e0bhpf_730"><font style="color:#ff00ff">Shared object file (<code class="code" id="e0bhpf_731">.so</code> file):</font></span> Special type of relocatable object file that can be loaded into memory and linked dynamically, at either load time or run-time.</p></li></ul></section><section class="chapter"><h3 id="10-2-elf-object-files" data-toc="10-2-elf-object-files">10.2 ELF Object Files</h3><p id="e0bhpf_732"><span id="e0bhpf_747"><font style="color:#8a2be2">Executable and Linkable Format (ELF): One unified format for relocatable object files, executable object files &amp; shared object files</font></span></p><figure id="e0bhpf_733"><img alt="ELF" src="Computer-Science-Study-Notes/ax10-1-2.png" title="ELF" width="1470" height="1407"></figure><ul class="list _bullet" id="e0bhpf_734"><li class="list__item" id="e0bhpf_748"><p id="e0bhpf_759"><span id="e0bhpf_760"><font style="color:#ff00ff">Elf header:</font></span> Word size, byte ordering, file type (.o, exec, .so), machine type, etc.</p></li><li class="list__item" id="e0bhpf_749"><p id="e0bhpf_761"><span id="e0bhpf_762"><font style="color:#ff00ff">Segment header table (only for executable object file):</font></span> Page size, virtual address memory segments (sections), segment sizes (indicate where different segments of the code go, like stack, shared library, etc.).</p></li><li class="list__item" id="e0bhpf_750"><p id="e0bhpf_763"><span id="e0bhpf_764"><font style="color:#ff00ff">.text section (read only):</font></span> code.</p></li><li class="list__item" id="e0bhpf_751"><p id="e0bhpf_765"><span id="e0bhpf_766"><font style="color:#ff00ff">.rodata section (read only):</font></span> Read only data: jump tables, string constants, ...</p></li><li class="list__item" id="e0bhpf_752"><p id="e0bhpf_767"><span id="e0bhpf_768"><font style="color:#ff00ff">.data section:</font></span> Initialized global and static variables. Local C variables are maintained at run time on the stack and do not appear in either the .data or .bss sections.</p></li><li class="list__item" id="e0bhpf_753"><p id="e0bhpf_769"><span id="e0bhpf_770"><font style="color:#ff00ff">.bss section (Block Started by Symbol):</font></span> (Preciesly in modern gcc) Uninitialized and static variables, along with any global or static variables that are initialized to zero, has section header but occupies no space.</p></li><li class="list__item" id="e0bhpf_754"><p id="e0bhpf_771"><span id="e0bhpf_772"><font style="color:#ff00ff">.symtab section:</font></span> Symbol table for functions and global variables' names, section names and locations.</p></li><li class="list__item" id="e0bhpf_755"><p id="e0bhpf_773"><span id="e0bhpf_774"><font style="color:#ff00ff">.rel.text section:</font></span> Relocation info for .text section, addresses of instructions that will need to be modified in the executable.</p></li><li class="list__item" id="e0bhpf_756"><p id="e0bhpf_775"><span id="e0bhpf_776"><font style="color:#ff00ff">.rel.data section:</font></span> Relocation info for .data section, addresses of pointer data that will need to be modified in the merged executable.</p></li><li class="list__item" id="e0bhpf_757"><p id="e0bhpf_777"><span id="e0bhpf_778"><font style="color:#ff00ff">.debug section:</font></span> Info for symbolic debugging (gcc -g).</p></li><li class="list__item" id="e0bhpf_758"><p id="e0bhpf_779"><span id="e0bhpf_780"><font style="color:#ff00ff">Section header table:</font></span> Offsets and sizes of each section.</p></li></ul><p id="e0bhpf_735"><span id="e0bhpf_781"><font style="color:#8a2be2">Linker Symbols</font></span></p><ul class="list _bullet" id="e0bhpf_736"><li class="list__item" id="e0bhpf_782"><p id="e0bhpf_785"><span id="e0bhpf_786"><font style="color:#ff00ff">Global symbols:</font></span> Symbols defined by module m that can be referenced by other modules. These correspond to nonstatic C functions and global variables.</p></li><li class="list__item" id="e0bhpf_783"><p id="e0bhpf_787"><span id="e0bhpf_788"><font style="color:#ff00ff">External symbols:</font></span> Global symbols that are referenced by module m but defined by some other module. These correspond to nonstatic C functions and global variables that are defined in other modules.</p></li><li class="list__item" id="e0bhpf_784"><p id="e0bhpf_789"><span id="e0bhpf_790"><font style="color:#ff00ff">Local symbols:</font></span> Symbols that are defined and referenced exclusively by module m. These correspond to static C functions and global variables that are defined with the static attribute.</p></li></ul><p id="e0bhpf_737"><span id="e0bhpf_791"><font style="color:#cd5c5c">Example (symbols.c)</font></span></p><div class="code-collapse" data-lang="c" data-is-expanded="false" data-synopsis="int incr = 1;">
                int incr = 1;

                static int foo(int a) {
                    int b = a + incr;
                    return b;
                }

                int main(int argc, char* argv[]) {
                    printf(&quot;%d\n&quot;, foo(5));
                    return 0;
                }
            </div><p id="e0bhpf_739"><code class="code" id="e0bhpf_792">incr</code>, <code class="code" id="e0bhpf_793">foo</code>, <code class="code" id="e0bhpf_794">main</code>, <code class="code" id="e0bhpf_795">printf</code> will be on the symbol table of symbols.o.</p><aside class="prompt" data-type="tip" data-title="" id="e0bhpf_740"><p id="e0bhpf_796">You can find this with <code class="code" id="e0bhpf_798">readelf</code></p><div class="code-block" data-lang="bash">
                    $ readelf -s symbols.o
                </div></aside><p id="e0bhpf_741"><span id="e0bhpf_799"><font style="color:#8a2be2">Types of Duplicate Symbol Definitions</font></span></p><ul class="list _bullet" id="e0bhpf_742"><li class="list__item" id="e0bhpf_800"><p id="e0bhpf_802"><span id="e0bhpf_803"><font style="color:#ff00ff">strong:</font></span> procedures and initialized globals.</p></li><li class="list__item" id="e0bhpf_801"><p id="e0bhpf_804"><span id="e0bhpf_805"><font style="color:#ff00ff">weak:</font></span> uninitialized globals, or ones declared with specifier <code class="code" id="e0bhpf_806">extern</code>.</p></li></ul><p id="e0bhpf_743"><span id="e0bhpf_807"><font style="color:#cd5c5c">Linker's Symbol Rules</font></span></p><ul class="list _bullet" id="e0bhpf_744"><li class="list__item" id="e0bhpf_808"><p id="e0bhpf_811">Multiple strong symbols are not allowed. Each item can be defined only once, otherwise will cause linker error.</p></li><li class="list__item" id="e0bhpf_809"><p id="e0bhpf_812">Given a strong symbol and multiple weak symbols, choose the strong symbol.</p></li><li class="list__item" id="e0bhpf_810"><p id="e0bhpf_813">If there are multiple weak symbols, pick an arbitrary one (can override this with <code class="code" id="e0bhpf_814">gcc &ndash;fno-common</code>).</p></li></ul><p id="e0bhpf_745"><span id="e0bhpf_815"><font style="color:#8a2be2">Three types of symbols that do not have entries in the section header table</font></span></p><ul class="list _bullet" id="e0bhpf_746"><li class="list__item" id="e0bhpf_816"><p id="e0bhpf_819"><span id="e0bhpf_820"><font style="color:#ff00ff">ABS:</font></span> Symbols that should not be relocated</p></li><li class="list__item" id="e0bhpf_817"><p id="e0bhpf_821"><span id="e0bhpf_822"><font style="color:#ff00ff">UNDEF:</font></span> Symbols that are referenced in this object module but defined elsewhere.</p></li><li class="list__item" id="e0bhpf_818"><p id="e0bhpf_823"><span id="e0bhpf_824"><font style="color:#ff00ff">COMMON:</font></span> Uninitialized data objects that are not yet allocated (Precisely, uninitialized global variables).</p></li></ul></section></section><section class="chapter"><h2 id="11-exceptional-control-flow" data-toc="11-exceptional-control-flow">11 Exceptional Control Flow</h2><p id="e0bhpf_825">From startup to shutdown, each CPU core simply reads and executes (interprets) a sequence of instructions, one at a time (externally), but it is not sufficient to react to changes in system state, which are <span id="e0bhpf_830"><font style="color:#ff8c00">Exceptional Control Flow (ECF)</font></span>.</p><p id="e0bhpf_826"><span id="e0bhpf_831"><font style="color:#8a2be2">Exceptional Control Flow exists at all levels of a computer system</font></span></p><ul class="list _bullet" id="e0bhpf_827"><li class="list__item" id="e0bhpf_832"><p id="e0bhpf_834">Low Level Mechanisms</p><ul class="list _bullet" id="e0bhpf_835"><li class="list__item" id="e0bhpf_836"><p id="e0bhpf_837"><span id="e0bhpf_838"><font style="color:#ff00ff">Exceptions:</font></span> Change in control flow in response to a system event (i.e., change in system state), implemented using combination of hardware and OS software.</p></li></ul></li><li class="list__item" id="e0bhpf_833"><p id="e0bhpf_839">High Level Mechanisms</p><ul class="list _bullet" id="e0bhpf_840"><li class="list__item" id="e0bhpf_841"><p id="e0bhpf_844"><span id="e0bhpf_845"><font style="color:#ff00ff">Process context switch:</font></span> Implemented by OS software and hardware timer.</p></li><li class="list__item" id="e0bhpf_842"><p id="e0bhpf_846"><span id="e0bhpf_847"><font style="color:#ff00ff">Signals:</font></span> Implemented by OS software.</p></li><li class="list__item" id="e0bhpf_843"><p id="e0bhpf_848"><span id="e0bhpf_849"><font style="color:#ff00ff">Nonlocal jumps:</font></span> Implemented by C runtime library.</p></li></ul></li></ul><section class="chapter"><h3 id="11-1-exceptions" data-toc="11-1-exceptions">11.1 Exceptions</h3><p id="e0bhpf_850">An <span id="e0bhpf_867"><font style="color:#ff8c00">exception</font></span> is a transfer of control to the OS kernel in response to some event (i.e., change in processor state).</p><ul class="list _bullet" id="e0bhpf_851"><li class="list__item" id="e0bhpf_868"><p id="e0bhpf_870">Kernel is the memory-resident part of the OS.</p></li><li class="list__item" id="e0bhpf_869"><p id="e0bhpf_871">Examples of events: Divide by 0, arithmetic overflow, page fault, I/O request completes, typing <kbd class="keystroke" id="e0bhpf_872" data-bypass="true"><span class="keystroke__value">Ctrl-C</span></kbd></p></li></ul><figure id="e0bhpf_852"><img alt="Anatomy of an Exception" src="Computer-Science-Study-Notes/ax11-1-1.png" title="Anatomy of an Exception" width="2055" height="1061"></figure><p id="e0bhpf_853"><span id="e0bhpf_873"><font style="color:#8a2be2">Exception Handling</font></span></p><figure id="e0bhpf_854"><img alt="Exception Handling" src="Computer-Science-Study-Notes/ax11-1-2.png" title="Exception Handling" width="2249" height="1807"></figure><ul class="list _bullet" id="e0bhpf_855"><li class="list__item" id="e0bhpf_874"><p id="e0bhpf_877">Each type of event has a unique exception number <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g></svg></mjx-container>.</p></li><li class="list__item" id="e0bhpf_875"><p id="e0bhpf_879"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g></svg></mjx-container> = index into exception table (a.k.a. interrupt vector).</p></li><li class="list__item" id="e0bhpf_876"><p id="e0bhpf_881">Handler <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g></svg></mjx-container> is called each time exception <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g></svg></mjx-container> occurs.</p></li></ul><p id="e0bhpf_856"><span id="e0bhpf_884"><font style="color:#8a2be2">Classes of Exceptions</font></span></p><figure id="e0bhpf_857"><img alt="Taxonomy of Hardware ECF" src="Computer-Science-Study-Notes/ax11-1-3.png" title="Taxonomy of Hardware ECF" width="5423" height="2395"></figure><ol class="list _decimal" id="e0bhpf_858" type="1"><li class="list__item" id="e0bhpf_885"><p id="e0bhpf_887"><span id="e0bhpf_890"><font style="color:#ff00ff">Asynchronous Exceptions:</font></span> Caused by events external to the processor.</p><p id="e0bhpf_888">Interrupts:</p><ul class="list _bullet" id="e0bhpf_889"><li class="list__item" id="e0bhpf_891"><p id="e0bhpf_894">Indicated by setting the processor&rsquo;s interrupt pin.</p></li><li class="list__item" id="e0bhpf_892"><p id="e0bhpf_895">Handler returns to &quot;next&quot; instruction.</p></li><li class="list__item" id="e0bhpf_893"><p id="e0bhpf_896"><span id="e0bhpf_898"><font style="color:#cd5c5c">Examples</font></span></p><ul class="list _bullet" id="e0bhpf_897"><li class="list__item" id="e0bhpf_899"><p id="e0bhpf_901"><span id="e0bhpf_902"><font style="color:#adff2f">Timer interrupt:</font></span> Every few ms, an external timer chip triggers an interrupt, used by the kernel to take back control from user programs (avoiding infinite loops, etc.).</p></li><li class="list__item" id="e0bhpf_900"><p id="e0bhpf_903"><span id="e0bhpf_904"><font style="color:#adff2f">I/O interrupt from external device:</font></span> Hitting <kbd class="keystroke" id="e0bhpf_905" data-bypass="true"><span class="keystroke__value">Ctrl-C</span></kbd> at the keyboard, arrival of a packet from a network, arrival of data from a disk.</p></li></ul></li></ul></li><li class="list__item" id="e0bhpf_886"><p id="e0bhpf_906"><span id="e0bhpf_908"><font style="color:#ff00ff">Synchronous Exceptions:</font></span> Caused by events that occur as a result of executing an instruction.</p><ul class="list _bullet" id="e0bhpf_907"><li class="list__item" id="e0bhpf_909"><p id="e0bhpf_912"><span id="e0bhpf_914"><font style="color:#adff2f">Traps</font></span></p><ul class="list _bullet" id="e0bhpf_913"><li class="list__item" id="e0bhpf_915"><p id="e0bhpf_918">Intentional, set program up to &quot;trip the trap&quot; and do something.</p></li><li class="list__item" id="e0bhpf_916"><p id="e0bhpf_919"><span id="e0bhpf_920"><font style="color:#cd5c5c">Examples:</font></span> system calls, gdb breakpoints.</p></li><li class="list__item" id="e0bhpf_917"><p id="e0bhpf_921">Returns control to &quot;next&quot; instruction.</p></li></ul></li><li class="list__item" id="e0bhpf_910"><p id="e0bhpf_922"><span id="e0bhpf_924"><font style="color:#adff2f">Faults</font></span></p><ul class="list _bullet" id="e0bhpf_923"><li class="list__item" id="e0bhpf_925"><p id="e0bhpf_928">Unintentional but possibly recoverable.</p></li><li class="list__item" id="e0bhpf_926"><p id="e0bhpf_929"><span id="e0bhpf_930"><font style="color:#cd5c5c">Examples:</font></span> page faults (recoverable), protection faults (unrecoverable), floating point exceptions.</p></li><li class="list__item" id="e0bhpf_927"><p id="e0bhpf_931">Either re-executes faulting (&quot;current&quot;) instruction or aborts.</p></li></ul></li><li class="list__item" id="e0bhpf_911"><p id="e0bhpf_932"><span id="e0bhpf_934"><font style="color:#adff2f"></font></span></p><ul class="list _bullet" id="e0bhpf_933"><li class="list__item" id="e0bhpf_935"><p id="e0bhpf_938">Unintentional and unrecoverable.</p></li><li class="list__item" id="e0bhpf_936"><p id="e0bhpf_939"><span id="e0bhpf_940"><font style="color:#cd5c5c">Examples:</font></span> illegal instruction, parity error, machine check.</p></li><li class="list__item" id="e0bhpf_937"><p id="e0bhpf_941">Aborts current program.</p></li></ul></li></ul></li></ol><p id="e0bhpf_859"><span id="e0bhpf_942"><font style="color:#8a2be2">System Calls:</font></span> Whenever a program wants to cause an effect outside its own process, it must ask the kernel for help.</p><ul class="list _bullet" id="e0bhpf_860"><li class="list__item" id="e0bhpf_943"><p id="e0bhpf_947">Read/write files.</p></li><li class="list__item" id="e0bhpf_944"><p id="e0bhpf_948">Get current time.</p></li><li class="list__item" id="e0bhpf_945"><p id="e0bhpf_949">Allocate RAM (sbrk).</p></li><li class="list__item" id="e0bhpf_946"><p id="e0bhpf_950">Create new processes.</p></li></ul><p id="e0bhpf_861"><span id="e0bhpf_951"><font style="color:#cd5c5c">System Calls Examples: Opening Files</font></span></p><ul class="list _bullet" id="e0bhpf_862"><li class="list__item" id="e0bhpf_952"><p id="e0bhpf_956">User calls: <code class="code" id="e0bhpf_957">open(filename, options)</code></p></li><li class="list__item" id="e0bhpf_953"><p id="e0bhpf_958">Calls <code class="code" id="e0bhpf_959">__open</code> function, which invokes system call instruction <code class="code" id="e0bhpf_960">syscall</code>.</p></li><li class="list__item" id="e0bhpf_954"><p id="e0bhpf_961">%rax contains syscall number, and return value in %rax. Negative value is an error corresponding to negative errno.</p></li><li class="list__item" id="e0bhpf_955"><p id="e0bhpf_962">Almost like a function call, but executed by kernel. Plus, &quot;address&quot; of &quot;function&quot; is in %rax.</p></li></ul><p id="e0bhpf_863">open_examples.c</p><div class="code-collapse" data-lang="c" data-is-expanded="false" data-synopsis="#include &lt;fcntl.h&gt;  // For open flags (O_RDONLY, etc.)">
                #include &lt;fcntl.h&gt;  // For open flags (O_RDONLY, etc.)
                #include &lt;unistd.h&gt; // For close
                #include &lt;stdio.h&gt;  // For perror (error handling)

                int main() {
                    int fd;

                    fd = open(&quot;my_file.txt&quot;, O_RDONLY);

                    if (fd == -1) {
                        perror(&quot;open failed&quot;);
                        return 1;
                    }

                    if (close(fd) == -1) {
                        perror(&quot;close failed&quot;);
                        return 1;
                    }

                    return 0;
                }
            </div><p id="e0bhpf_865">open_examples.s</p><div class="code-collapse" data-lang="nasm" data-is-expanded="false" data-synopsis=".file	&quot;open_example.c&quot;">
                .file	&quot;open_example.c&quot;
                # GNU C17 (Ubuntu 13.2.0-23ubuntu4) version 13.2.0 (x86_64-linux-gnu)
                #	compiled by GNU C version 13.2.0, GMP version 6.3.0, MPFR version 4.2.1, MPC version 1.3.1, isl version isl-0.26-GMP

                # GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
                # options passed: -mtune=generic -march=x86-64 -O0 -fasynchronous-unwind-tables -fstack-protector-strong -fstack-clash-protection -fcf-protection
                    .text
                    .section	.rodata
                .LC0:
                    .string	&quot;my_file.txt&quot;
                .LC1:
                    .string	&quot;open failed&quot;
                .LC2:
                    .string	&quot;close failed&quot;
                    .text
                    .globl	main
                    .type	main, @function
                    main:
                .LFB0:
                .cfi_startproc
                endbr64
                pushq	%rbp	#
                .cfi_def_cfa_offset 16
                .cfi_offset 6, -16
                movq	%rsp, %rbp	#,
                .cfi_def_cfa_register 6
                subq	$16, %rsp	#,
                # open_example.c:8:     fd = open(&quot;my_file.txt&quot;, O_RDONLY);
                movl	$0, %esi	#,
                leaq	.LC0(%rip), %rax	#, tmp85
                movq	%rax, %rdi	# tmp85,
                movl	$0, %eax	#,
                call	open@PLT	#
                movl	%eax, -4(%rbp)	# tmp86, fd
                # open_example.c:10:     if (fd == -1) {
                cmpl	$-1, -4(%rbp)	#, fd
                jne	.L2	#,
                # open_example.c:11:         perror(&quot;open failed&quot;);
                leaq	.LC1(%rip), %rax	#, tmp87
                movq	%rax, %rdi	# tmp87,
                call	perror@PLT	#
                # open_example.c:12:         return 1;
                movl	$1, %eax	#, _2
                jmp	.L3	#
                .L2:
                # open_example.c:15:     if (close(fd) == -1) {
                movl	-4(%rbp), %eax	# fd, tmp88
                movl	%eax, %edi	# tmp88,
                call	close@PLT	#
                # open_example.c:15:     if (close(fd) == -1) {
                cmpl	$-1, %eax	#, _1
                jne	.L4	#,
                # open_example.c:16:         perror(&quot;close failed&quot;);
                leaq	.LC2(%rip), %rax	#, tmp89
                movq	%rax, %rdi	# tmp89,
                call	perror@PLT	#
                # open_example.c:17:         return 1;
                movl	$1, %eax	#, _2
                jmp	.L3	#
                .L4:
                # open_example.c:20:     return 0;
                movl	$0, %eax	#, _2
                .L3:
                # open_example.c:21: }
                leave
                .cfi_def_cfa 7, 8
                ret
                .cfi_endproc
                .LFE0:
                    .size	main, .-main
                    .ident	&quot;GCC: (Ubuntu 13.2.0-23ubuntu4) 13.2.0&quot;
                    .section	.note.GNU-stack,&quot;&quot;,@progbits
                    .section	.note.gnu.property,&quot;a&quot;
                    .align 8
                    .long	1f - 0f
                    .long	4f - 1f
                    .long	5
                0:
                    .string	&quot;GNU&quot;
                1:
                    .align 8
                    .long	0xc0000002
                    .long	3f - 2f
                2:
                    .long	0x3
                3:
                    .align 8
                4:

            </div></section><section class="chapter"><h3 id="11-2-processes" data-toc="11-2-processes">11.2 Processes</h3><p id="e0bhpf_963"><span id="e0bhpf_972"><font style="color:#ff8c00">Process:</font></span> An instance of a <span id="e0bhpf_973"><font style="color:#ff4500">running</font></span> program. It is identified by Process ID (PID), user account, command name.</p><p id="e0bhpf_964">Two key abtractions:</p><ul class="list _bullet" id="e0bhpf_965"><li class="list__item" id="e0bhpf_974"><p id="e0bhpf_976"><span id="e0bhpf_977"><font style="color:#ff00ff">Private address space:</font></span> Each program seems to have exclusive use of main memory. This is provided by kernel mechanism called virtual memory.</p></li><li class="list__item" id="e0bhpf_975"><p id="e0bhpf_978"><span id="e0bhpf_979"><font style="color:#ff00ff">Logical control flow:</font></span> Each program seems to have exclusive use of the CPU. This is provided by kernel mechanism called context switching.</p></li></ul><p id="e0bhpf_966">From startup to shutdown, each CPU core simply reads and executesa sequence of machine instructions, one at a time*. This sequence is the CPU&rsquo;s <span id="e0bhpf_980"><font style="color:#ff8c00">control flow</font></span> (or <span id="e0bhpf_981"><font style="color:#ff8c00">flow of control</font></span>).</p><aside class="prompt" data-type="note" data-title="" id="e0bhpf_967"><p id="e0bhpf_982">*: Many modern CPUs execute several instructions at once and/or out of program order, but this is invisible to the programmer.</p></aside><section class="chapter"><h4 id="11-2-1context-switch" data-toc="11-2-1context-switch">11.2.1 Context Switch</h4><p id="e0bhpf_983">Processes are managed by a shared chunk of memory-resident OS code called the kernel. The kernel is not a separate process, but rather runs as part of some existing process.</p><p id="e0bhpf_984">Control flow passes from one process to another via a <span id="e0bhpf_991"><font style="color:#ff8c00">context switch</font></span>.</p><figure id="e0bhpf_985"><img alt="Context Switch" src="Computer-Science-Study-Notes/ax11-2-1.png" title="Context Switch" width="5000" height="2066"></figure><p id="e0bhpf_986"><span id="e0bhpf_992"><font style="color:#8a2be2">Context Switching (Uniprocessor)</font></span></p><ul class="list _bullet" id="e0bhpf_987"><li class="list__item" id="e0bhpf_993"><p id="e0bhpf_996">Single processor executes multiple processes concurrently.</p></li><li class="list__item" id="e0bhpf_994"><p id="e0bhpf_997">Process executions interleaved (multitasking).</p></li><li class="list__item" id="e0bhpf_995"><p id="e0bhpf_998">Address spaces managed by virtual memory system.</p></li></ul><section class="procedure-steps"><h3 id="e0bhpf_988" data-toc="e0bhpf_988">Context Switching (Uniprocessor)</h3><ol class="list _decimal"><li class="list__item" id="e0bhpf_999"><p id="e0bhpf_1002">Save current registers in memory</p></li><li class="list__item" id="e0bhpf_1000"><p id="e0bhpf_1003">Schedule next process for execution</p></li><li class="list__item" id="e0bhpf_1001"><p id="e0bhpf_1004">Load saved registers and switch address space (context switch)</p></li></ol></section><p id="e0bhpf_989"><span id="e0bhpf_1005"><font style="color:#8a2be2">Context Switching (Multicore)</font></span></p><ul class="list _bullet" id="e0bhpf_990"><li class="list__item" id="e0bhpf_1006"><p id="e0bhpf_1009">Multiple CPUs on single chip.</p></li><li class="list__item" id="e0bhpf_1007"><p id="e0bhpf_1010">Share main memory (and some caches).</p></li><li class="list__item" id="e0bhpf_1008"><p id="e0bhpf_1011">Each can execute a separate process. Scheduling of processes onto cores done by kernel.</p></li></ul></section><section class="chapter"><h4 id="11-2-2-concurrent-flows" data-toc="11-2-2-concurrent-flows">11.2.2 Concurrent Flows</h4><figure id="e0bhpf_1012"><img alt="Concurrent Processes" src="Computer-Science-Study-Notes/ax11-2-2.png" title="Concurrent Processes" width="1789" height="814"></figure><p id="e0bhpf_1013"><span id="e0bhpf_1016"><font style="color:#ff8c00">Concurrent Flow:</font></span> A logical flow whose execution overlaps in time with another flow.</p><aside class="prompt" data-type="note" data-title="" id="e0bhpf_1014"><p id="e0bhpf_1017">Flows X and Y are concurrent with respect to each other if and only if X begins after Y begins and before Y finishes, or Y begins after X begins and before X finishes.</p><p id="e0bhpf_1018">In the example above, A and B, A and C run concurrently. However, B and C do not run concurrently.</p></aside><p id="e0bhpf_1015"><span id="e0bhpf_1019"><font style="color:#ff8c00">Parallel Flows:</font></span> Two flows are running concurrently on different processor cores or computers.</p></section><section class="chapter"><h4 id="11-2-3-system-calls" data-toc="11-2-3-system-calls">11.2.3 System Calls</h4><p id="e0bhpf_1020">On error, most system-level functions return &minus;1 and set global variable <code class="code" id="e0bhpf_1026">errno</code> to indicate cause.</p><div class="code-collapse" data-lang="c" data-is-expanded="false" data-synopsis="pid_t pid = fork();">
                    pid_t pid = fork();
                    if(pid == -1) {
                        fprintf(stderr, &quot;fork error: %s\n&quot;, strerror(errno));
                        exit(1);
                    }
                </div><p id="e0bhpf_1022">Can simplify somewhat using an error-reporting function:</p><div class="code-collapse" data-lang="c" data-is-expanded="false" data-synopsis="void unix_error(char *msg) /* Unix-style error */">
                    void unix_error(char *msg) /* Unix-style error */
                    {
                        fprintf(stderr, &quot;%s: %s\n&quot;, msg, strerror(errno));
                        exit(1);
                    }

                    /* Example of using unix_error */
                    if ((pid = fork()) &lt; 0)
                        unix_error(&quot;fork error&quot;);
                </div><p id="e0bhpf_1024">Simplify even further by using Stevens-style error-handling wrappers:</p><div class="code-collapse" data-lang="c" data-is-expanded="false" data-synopsis="pid_t Fork(void)">
                    pid_t Fork(void)
                    {
                        pid_t pid;
                        if ((pid = fork()) &lt; 0)
                            unix_error(&quot;Fork error&quot;);
                        return pid;
                    }

                    /* Example of using Fork */
                    pid = Fork();
                </div></section><section class="chapter"><h4 id="11-2-4-process-control" data-toc="11-2-4-process-control">11.2.4 Process Control</h4><p id="e0bhpf_1027"><span id="e0bhpf_1045"><font style="color:#8a2be2">Obtaining Process IDs</font></span></p><ul class="list _bullet" id="e0bhpf_1028"><li class="list__item" id="e0bhpf_1046"><p id="e0bhpf_1048"><code class="code" id="e0bhpf_1049">pid_t getpid(void)</code> Returns PID of current process.</p></li><li class="list__item" id="e0bhpf_1047"><p id="e0bhpf_1050"><code class="code" id="e0bhpf_1051">pid_t getppid(void)</code> Returns PID of parent process.</p></li></ul><p id="e0bhpf_1029"><span id="e0bhpf_1052"><font style="color:#8a2be2">Process States</font></span></p><ul class="list _bullet" id="e0bhpf_1030"><li class="list__item" id="e0bhpf_1053"><p id="e0bhpf_1057"><span id="e0bhpf_1058"><font style="color:#ff00ff">Running:</font></span> Process is either executing instructions, or it could be executing instructions if there were enough CPU cores.</p></li><li class="list__item" id="e0bhpf_1054"><p id="e0bhpf_1059"><span id="e0bhpf_1060"><font style="color:#ff00ff">Blocked/Sleeping:</font></span> Process cannot execute any more instructions until some external event happens (usually I/O).</p></li><li class="list__item" id="e0bhpf_1055"><p id="e0bhpf_1061"><span id="e0bhpf_1062"><font style="color:#ff00ff">Stopped:</font></span> Process has been prevented from executing by user action (control-Z).</p></li><li class="list__item" id="e0bhpf_1056"><p id="e0bhpf_1063"><span id="e0bhpf_1064"><font style="color:#ff00ff">Terminated/Zombie:</font></span> Process is finished. Parent process has not yet been notified.</p></li></ul><p id="e0bhpf_1031"><span id="e0bhpf_1065"><font style="color:#8a2be2">Terminating Processes</font></span></p><ul class="list _bullet" id="e0bhpf_1032"><li class="list__item" id="e0bhpf_1066"><p id="e0bhpf_1069">Receiving a signal whose default action is to terminate.</p></li><li class="list__item" id="e0bhpf_1067"><p id="e0bhpf_1070">Returning from the <code class="code" id="e0bhpf_1071">main</code> routine.</p></li><li class="list__item" id="e0bhpf_1068"><p id="e0bhpf_1072">Calling the <code class="code" id="e0bhpf_1073">exit</code> function.</p></li></ul><p id="e0bhpf_1033"><code class="code" id="e0bhpf_1074">void exit(int status):</code> Terminates with an exit status of <code class="code" id="e0bhpf_1075">status</code>. Convention is that normal return status is 0, nonzero on error. Another way to explicitly set the exit status is to return an integer value from the main routine.</p><aside class="prompt" data-type="note" data-title="" id="e0bhpf_1034"><p id="e0bhpf_1076"><code class="code" id="e0bhpf_1077">exit</code> is called once but never returns!</p></aside><p id="e0bhpf_1035"><span id="e0bhpf_1078"><font style="color:#8a2be2">Creating Processes:</font></span> Parent process creates a new running child process by calling <code class="code" id="e0bhpf_1079">int fork(void)</code></p><ul class="list _bullet" id="e0bhpf_1036"><li class="list__item" id="e0bhpf_1080"><p id="e0bhpf_1082">Returns 0 to the child process, and child's PID to parent process.</p></li><li class="list__item" id="e0bhpf_1081"><p id="e0bhpf_1083">Child is almost identical to parent:</p><ul class="list _bullet" id="e0bhpf_1084"><li class="list__item" id="e0bhpf_1085"><p id="e0bhpf_1088">Child get an identical (but separate) copy of the parent's virtual address space.</p></li><li class="list__item" id="e0bhpf_1086"><p id="e0bhpf_1089">Child gets identical copies of the parent's open file descriptors.</p></li><li class="list__item" id="e0bhpf_1087"><p id="e0bhpf_1090">Child has a different PID than the parent.</p></li></ul></li></ul><aside class="prompt" data-type="note" data-title="" id="e0bhpf_1037"><p id="e0bhpf_1091"><code class="code" id="e0bhpf_1092">fork</code> is called once but returns twice!</p></aside><figure id="e0bhpf_1038"><img alt="Conceptual View of fork" src="Computer-Science-Study-Notes/ax11-2-3.png" title="Conceptual View of fork" width="6000" height="2562"></figure><p id="e0bhpf_1039"><span id="e0bhpf_1093"><font style="color:#cd5c5c">Example</font></span></p><div class="code-collapse" data-lang="c" data-is-expanded="false" data-synopsis="/* fork.c */">
                    /* fork.c */
                    int main(int argc, char** argv)
                    {
                        pid_t pid;
                        int x = 1;

                        pid = Fork();
                        if (pid == 0) { /* Child */
                            printf(&quot;child : x=%d\n&quot;, ++x);
                            return 0;
                        }

                        /* Parent */
                        printf(&quot;parent: x=%d\n&quot;, --x);
                        return 0;
                    }
                </div><div class="code-block" data-lang="bash">
                    $ ./fork
                    parent: x=0
                    child : x=2
                </div><ul class="list _bullet" id="e0bhpf_1042"><li class="list__item" id="e0bhpf_1094"><p id="e0bhpf_1098">Call once, return twice.</p></li><li class="list__item" id="e0bhpf_1095"><p id="e0bhpf_1099">Concurrent execution: Can't predict execution order of parent and child.</p></li><li class="list__item" id="e0bhpf_1096"><p id="e0bhpf_1100">Duplicate but separate address space: x has a value of 1 when fork returns in parent and child, and subsequent changes to x are independent.</p></li><li class="list__item" id="e0bhpf_1097"><p id="e0bhpf_1101">Shared open files: <code class="code" id="e0bhpf_1102">stdout</code> is the same in both parent and child.</p></li></ul><p id="e0bhpf_1043">Process Graphs: Topological sort of the graph corresponds to a feasible total ordering.</p><figure id="e0bhpf_1044"><img alt="Process Graphs" src="Computer-Science-Study-Notes/ax11-2-4.png" title="Process Graphs" width="6000" height="2259"></figure></section></section></section><div class="last-modified">Last modified: 14 November 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="computer-architecture-risc-v.html" class="navigation-links__prev">RISC-Ⅴ Architecture</a><a href="data-structures-and-algorithms.html" class="navigation-links__next">Data Structures and Algorithms</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b518/app.js"></script></body></html>