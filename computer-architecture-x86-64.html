<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#6860F6" data-link-color="#307FFF" data-resizable-sidebar="true" data-sidebar-width="260"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2024-11-06T08:46:22.6004231"><title>x86-64 Architecture | Computer Science Study Notes</title><script type="application/json" id="virtual-toc-data">[{"id":"6-introduction-to-assembly-language-x86","level":0,"title":"6 Introduction to Assembly Language","anchor":"#6-introduction-to-assembly-language-x86"},{"id":"6-1-assembly-language-x86","level":1,"title":"6.1 Assembly Language","anchor":"#6-1-assembly-language-x86"},{"id":"6-2-registers-x86","level":1,"title":"6.2 Registers","anchor":"#6-2-registers-x86"},{"id":"6-3-instructions-x86","level":1,"title":"6.3 x86-64 Instructions","anchor":"#6-3-instructions-x86"},{"id":"6-3-1-moving-data-instructions","level":2,"title":"6.3.1 Moving Data Instructions","anchor":"#6-3-1-moving-data-instructions"},{"id":"6-3-2-address-aomputation-instructions","level":2,"title":"6.3.2 Address Computation Instructions","anchor":"#6-3-2-address-aomputation-instructions"},{"id":"6-3-3-arithmetic-instructions","level":2,"title":"6.3.3 Arithmetic Instructions","anchor":"#6-3-3-arithmetic-instructions"},{"id":"6-4-c-assembly-machine-code-x86","level":1,"title":"6.4 C, Assembly \u0026 Machine Code","anchor":"#6-4-c-assembly-machine-code-x86"},{"id":"7-control-flow-instructions-x86","level":0,"title":"7 Control Flow Instructions","anchor":"#7-control-flow-instructions-x86"},{"id":"7-1-conditional-codes-x86","level":1,"title":"7.1 Conditional Codes","anchor":"#7-1-conditional-codes-x86"},{"id":"7-2-conditional-Branches-x86","level":1,"title":"7.2 Conditional Branches","anchor":"#7-2-conditional-Branches-x86"},{"id":"7-3-loops-x86","level":1,"title":"7.3 Loops","anchor":"#7-3-loops-x86"},{"id":"7-4-switch-statements-x86","level":1,"title":"7.4 Switch Statements","anchor":"#7-4-switch-statements-x86"},{"id":"8-program-optimization","level":0,"title":"8 Program Optimization","anchor":"#8-program-optimization"},{"id":"8-1-generally-useful-optimizations","level":1,"title":"8.1 Generally Useful Optimizations","anchor":"#8-1-generally-useful-optimizations"},{"id":"8-2-optimization-blockers","level":1,"title":"8.2 Optimization Blockers","anchor":"#8-2-optimization-blockers"},{"id":"8-3-exploit-instruction-level-parallelism","level":1,"title":"8.3 Exploit Instruction-Level Parallelism","anchor":"#8-3-exploit-instruction-level-parallelism"},{"id":"8-4-dealing-with-conditions","level":1,"title":"8.4 Dealing with Conditions","anchor":"#8-4-dealing-with-conditions"},{"id":"9-memory-hierarchy","level":0,"title":"9 Memory Hierarchy","anchor":"#9-memory-hierarchy"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b419/app.css" rel="stylesheet"><link href="static/custom.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="Computer-Science-Study-Notes/photo.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="x86-64 Architecture | Computer Science Study Notes"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Computer Science Study Notes Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/computer-architecture-x86-64.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="x86-64 Architecture | Computer Science Study Notes"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/computer-architecture-x86-64.html#webpage",
    "url": "writerside-documentation/computer-architecture-x86-64.html",
    "name": "x86-64 Architecture | Computer Science Study Notes",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Computer Science Study Notes Help"
}</script><!-- End Schema.org --></head><body data-id="Computer-Architecture-x86-64" data-main-title="x86-64 Architecture" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Computer-Architecture.topic|Computer Architecture"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Computer Science Study Notes  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Computer-Architecture-x86-64" id="Computer-Architecture-x86-64.topic">x86-64 Architecture</h1><section class="chapter"><h2 id="6-introduction-to-assembly-language-x86" data-toc="6-introduction-to-assembly-language-x86">6 Introduction to Assembly Language</h2><section class="chapter"><h3 id="6-1-assembly-language-x86" data-toc="6-1-assembly-language-x86">6.1 Assembly Language</h3><p id="z1k213e_12"><span id="z1k213e_18"><font style="color:#ff8c00">Assembly (also known as Assembly language, ASM):</font></span> A low-level programming language where the program instructions match a particular architecture's operations.</p><p id="z1k213e_13"><span id="z1k213e_19"><font style="color:#ff8c00">Architecture:</font></span> (also ISA: instruction set architecture) The parts of a processor design that one needs to understand for writing assembly/machine code.</p><p id="z1k213e_14"><span id="z1k213e_20"><font style="color:#8a2be2">Properties:</font></span></p><ul class="list _bullet" id="z1k213e_15"><li class="list__item" id="z1k213e_21"><p id="z1k213e_24">Splits a program into many small instructions that each do one single part of the process.</p></li><li class="list__item" id="z1k213e_22"><p id="z1k213e_25">Each architecture will have a different set of operations that it supports (although there are similarities).</p></li><li class="list__item" id="z1k213e_23"><p id="z1k213e_26">Assembly is not <span id="z1k213e_27"><i>portable</i></span> to other architectures.</p></li></ul><p id="z1k213e_16"><span id="z1k213e_28"><font style="color:#8a2be2">Complex/Reduced Instruction Set Computing</font></span></p><ol class="list _alpha-lower" id="z1k213e_17" type="a"><li class="list__item" id="z1k213e_29"><p id="z1k213e_31">Early trend - add more and more instructions to do elaborate operations</p><p id="z1k213e_32"><span id="z1k213e_34"><font style="color:#ff00ff">Complex Instruction Set Computing (CISC)</font></span></p><ul class="list _bullet" id="z1k213e_33"><li class="list__item" id="z1k213e_35"><p id="z1k213e_38">Difficult to learn and comprehend language</p></li><li class="list__item" id="z1k213e_36"><p id="z1k213e_39">Less work for the compiler</p></li><li class="list__item" id="z1k213e_37"><p id="z1k213e_40">Complicated hardware runs more slowly</p></li></ul></li><li class="list__item" id="z1k213e_30"><p id="z1k213e_41">Opposite philosophy later began to dominate</p><p id="z1k213e_42"><span id="z1k213e_44"><font style="color:#ff00ff">Reduced Instruction Set Computing (RISC)</font></span></p><ul class="list _bullet" id="z1k213e_43"><li class="list__item" id="z1k213e_45"><p id="z1k213e_47">Simple (and smaller) instruction set makes it easier to build fast hardware.</p></li><li class="list__item" id="z1k213e_46"><p id="z1k213e_48">Let software do the complicated operations by composing simpler ones.</p></li></ul></li></ol></section><section class="chapter"><h3 id="6-2-registers-x86" data-toc="6-2-registers-x86">6.2 Registers</h3><p id="z1k213e_49">Assembly uses registers to store values. Registers are:</p><ul class="list _bullet" id="z1k213e_50"><li class="list__item" id="z1k213e_56"><p id="z1k213e_60">Small memories of a fixed size.</p></li><li class="list__item" id="z1k213e_57"><p id="z1k213e_61">Can be read or written.</p></li><li class="list__item" id="z1k213e_58"><p id="z1k213e_62">Limited in number.</p></li><li class="list__item" id="z1k213e_59"><p id="z1k213e_63">Very fast and low power to access.</p></li></ul><div class="table-wrapper"><table class="left_header wide" id="z1k213e_51"><thead><tr class="ijRowHead" id="z1k213e_64"><th id="z1k213e_68"><p>Registers</p></th><th id="z1k213e_69"><p>Memory</p></th></tr></thead><tbody><tr id="z1k213e_65"><th id="z1k213e_70"><p>Speed</p></th><td id="z1k213e_71"><p>Fast</p></td><td id="z1k213e_72"><p>Slow</p></td></tr><tr id="z1k213e_66"><th id="z1k213e_73"><p>Size</p></th><td id="z1k213e_74"><p id="z1k213e_76">Small</p><p id="z1k213e_77">e.g., 32 registers * 32 bit = 128 bytes</p></td><td id="z1k213e_75"><p id="z1k213e_78">Big</p><p id="z1k213e_79">4-32 GB</p></td></tr><tr id="z1k213e_67"><th id="z1k213e_80"><p>Connection</p></th><td id="z1k213e_81" colspan="2"><p id="z1k213e_82">More variables than registers?</p><p id="z1k213e_83">Keep most frequently used in registers and move the rest to memory</p></td></tr></tbody></table></div><figure id="z1k213e_52"><img alt="Registers" src="Computer-Science-Study-Notes/a6-2-1.png" title="Registers" width="2207" height="1307"></figure><p id="z1k213e_53"><span id="z1k213e_84"><font style="color:#8a2be2">x86-84 Registers</font></span></p><div class="table-wrapper"><table class="no_header wide" id="z1k213e_54"><tbody><tr id="z1k213e_85"><td id="z1k213e_93"><p>%rax&nbsp;&nbsp;%eax</p></td><td id="z1k213e_94"><p>%r8&nbsp;&nbsp;%r8d</p></td></tr><tr id="z1k213e_86"><td id="z1k213e_95"><p>%rbx&nbsp;&nbsp;%ebx</p></td><td id="z1k213e_96"><p>%r9&nbsp;&nbsp;%r9d</p></td></tr><tr id="z1k213e_87"><td id="z1k213e_97"><p>%rcx&nbsp;&nbsp;%ecx</p></td><td id="z1k213e_98"><p>%r10&nbsp;&nbsp;%r10d</p></td></tr><tr id="z1k213e_88"><td id="z1k213e_99"><p>%rdx&nbsp;&nbsp;%edx</p></td><td id="z1k213e_100"><p>%r11&nbsp;&nbsp;%r11d</p></td></tr><tr id="z1k213e_89"><td id="z1k213e_101"><p>%rsi&nbsp;&nbsp;%esi</p></td><td id="z1k213e_102"><p>%r12&nbsp;&nbsp;%r12d</p></td></tr><tr id="z1k213e_90"><td id="z1k213e_103"><p>%rdi&nbsp;&nbsp;%edi</p></td><td id="z1k213e_104"><p>%r13&nbsp;&nbsp;%r13d</p></td></tr><tr id="z1k213e_91"><td id="z1k213e_105"><p>%rsp&nbsp;&nbsp;%esp</p></td><td id="z1k213e_106"><p>%r14&nbsp;&nbsp;%r14d</p></td></tr><tr id="z1k213e_92"><td id="z1k213e_107"><p>%rbp&nbsp;&nbsp;%ebp</p></td><td id="z1k213e_108"><p>%r15&nbsp;&nbsp;%r15d</p></td></tr></tbody></table></div><aside class="prompt" data-type="note" data-title="" id="z1k213e_55"><p id="z1k213e_109">Usages for the LHS:</p><ul class="list _bullet" id="z1k213e_110"><li class="list__item" id="z1k213e_114"><p id="z1k213e_119"><span id="z1k213e_120"><font style="color:#ff00ff">%rax:</font></span> 64 bits</p></li><li class="list__item" id="z1k213e_115"><p id="z1k213e_121"><span id="z1k213e_122"><font style="color:#ff00ff">%eax:</font></span> lower 32 bits of rax ( can also be used for storing smaller integers)</p></li><li class="list__item" id="z1k213e_116"><p id="z1k213e_123"><span id="z1k213e_124"><font style="color:#ff00ff">%ax:</font></span> lower 16 bits of eax</p></li><li class="list__item" id="z1k213e_117"><p id="z1k213e_125"><span id="z1k213e_126"><font style="color:#ff00ff">%al:</font></span> lower 8 bits of ax</p></li><li class="list__item" id="z1k213e_118"><p id="z1k213e_127"><span id="z1k213e_128"><font style="color:#ff00ff">%ah:</font></span> upper 8 bits of ax</p></li></ul><p id="z1k213e_111">Usages for the RHS</p><ul class="list _bullet" id="z1k213e_112"><li class="list__item" id="z1k213e_129"><p id="z1k213e_133"><span id="z1k213e_134"><font style="color:#ff00ff">%r13:</font></span> 64 bits</p></li><li class="list__item" id="z1k213e_130"><p id="z1k213e_135"><span id="z1k213e_136"><font style="color:#ff00ff">%r13d (doubleword):</font></span> lower 32 bits of rax ( can also be used for storing smaller integers)</p></li><li class="list__item" id="z1k213e_131"><p id="z1k213e_137"><span id="z1k213e_138"><font style="color:#ff00ff">%r13w (word):</font></span> lower 16 bits of eax</p></li><li class="list__item" id="z1k213e_132"><p id="z1k213e_139"><span id="z1k213e_140"><font style="color:#ff00ff">%r13b (byte):</font></span> lower 8 bits of ax</p></li></ul><p id="z1k213e_113">Stack pointer: %rsp (%esp), you cannot use it!</p></aside></section><section class="chapter"><h3 id="6-3-instructions-x86" data-toc="6-3-instructions-x86">6.3 x86-64 Instructions</h3><p id="z1k213e_141">In high-level languages, variable types determine operation.</p><p id="z1k213e_142">In assembly, operation determines type, i.e., how register contents are treated.</p><p id="z1k213e_143"><span id="z1k213e_148"><font style="color:#8a2be2">Operations</font></span></p><ul class="list _bullet" id="z1k213e_144"><li class="list__item" id="z1k213e_149"><p id="z1k213e_152"><span id="z1k213e_154"><font style="color:#ff00ff">Transfer data between memory and register</font></span></p><ul class="list _bullet" id="z1k213e_153"><li class="list__item" id="z1k213e_155"><p id="z1k213e_157">Load data from memory into register</p></li><li class="list__item" id="z1k213e_156"><p id="z1k213e_158">Store register data into memory</p></li></ul></li><li class="list__item" id="z1k213e_150"><p id="z1k213e_159"><span id="z1k213e_160"><font style="color:#ff00ff">Perform arithmetic function on register or memory data</font></span></p></li><li class="list__item" id="z1k213e_151"><p id="z1k213e_161"><span id="z1k213e_163"><font style="color:#ff00ff">Transfer control</font></span></p><ul class="list _bullet" id="z1k213e_162"><li class="list__item" id="z1k213e_164"><p id="z1k213e_167">Unconditional jumps to/from procedures</p></li><li class="list__item" id="z1k213e_165"><p id="z1k213e_168">Conditional branches</p></li><li class="list__item" id="z1k213e_166"><p id="z1k213e_169">Indirect branches</p></li></ul></li></ul><section class="chapter"><h4 id="6-3-1-moving-data-instructions" data-toc="6-3-1-moving-data-instructions">6.3.1 Moving Data Instructions</h4><p id="z1k213e_170">movq source, dest</p><p id="z1k213e_171"><span id="z1k213e_176"><font style="color:#8a2be2">Operand Types</font></span></p><ul class="list _bullet" id="z1k213e_172"><li class="list__item" id="z1k213e_177"><p id="z1k213e_179"><span id="z1k213e_180"><font style="color:#ff00ff">Immediate:</font></span> Constant integer data. Like C constants, but prefix with '$'.</p></li><li class="list__item" id="z1k213e_178"><p id="z1k213e_181"><span id="z1k213e_184"><font style="color:#ff00ff">Memory:</font></span>: 8 consecutive bytes of memory at address given by register (for movq).</p><p id="z1k213e_182">This is corresponding to <code class="code" id="z1k213e_185">movq</code>. The <code class="code" id="z1k213e_186">mov</code> instruction without a suffix is size-dependent. <code class="code" id="z1k213e_187">mov</code> defaults to 32-bit operations when the size isn't explicitly indicated.</p><p id="z1k213e_183">Recommend to use the explicit suffixes (movq, movl, movw, movb) whenever possible</p></li></ul><figure id="z1k213e_173"><img alt="movq Operand Combinations" src="Computer-Science-Study-Notes/a6-2-2.png" title="movq Operand Combinations" width="2824" height="1150"></figure><p id="z1k213e_174"><span id="z1k213e_188"><font style="color:#8a2be2">Memory Addressing Mode</font></span></p><ol class="list _decimal" id="z1k213e_175" type="1"><li class="list__item" id="z1k213e_189"><p id="z1k213e_192">Normal (R) =&gt; pointer dereferencing in C</p><p> <code class="code" id="z1k213e_193">movq (%rcx),%rax</code> equals: </p><div class="code-block" data-lang="c">
                            rax = *rcx
                        </div></li><li class="list__item" id="z1k213e_190"><p id="z1k213e_195">Displacement D(R) =&gt; accessing data at a fixed offset from a base address</p><p id="z1k213e_196"><code class="code" id="z1k213e_198">movq 8(%rbp), %rdx</code> equals:</p><div class="code-block" data-lang="c">
                            rdx = *(((char*)rbp) + 8)
                        </div></li><li class="list__item" id="z1k213e_191"><p id="z1k213e_199"><span id="z1k213e_203"><font style="color:#ff00ff">Complete Mode:</font></span> D(Rb,Ri,S)</p><ul class="list _bullet" id="z1k213e_200"><li class="list__item" id="z1k213e_204"><p id="z1k213e_208"><span id="z1k213e_209"><font style="color:#7cfc00">D:</font></span> Constant &quot;displacement&quot; 1, 2, or 4 bytes</p></li><li class="list__item" id="z1k213e_205"><p id="z1k213e_210"><span id="z1k213e_211"><font style="color:#7cfc00">Rb:</font></span> Base register: Any of 16 integer registers</p></li><li class="list__item" id="z1k213e_206"><p id="z1k213e_212"><span id="z1k213e_213"><font style="color:#7cfc00">Ri:</font></span> Index register: Any, except for %rsp</p></li><li class="list__item" id="z1k213e_207"><p id="z1k213e_214"><span id="z1k213e_215"><font style="color:#7cfc00">S:</font></span> Scale: 1, 2, 4, or 8</p></li></ul><p id="z1k213e_201"><span id="z1k213e_216"><font style="color:#ff69b4">Example:</font></span> <code class="code" id="z1k213e_217">movl (&amp;#37;rbx,&amp;#37;rdi,4), %eax</code></p><ol class="list _decimal" id="z1k213e_202" type="1"><li class="list__item" id="z1k213e_218"><p id="z1k213e_221">Calculate the address: %rbx + (4 * %rdi) (e.g., base address + 4 * 5 = base address + 20).</p></li><li class="list__item" id="z1k213e_219"><p id="z1k213e_222">Access the 32-bit value at that calculated address.</p></li><li class="list__item" id="z1k213e_220"><p id="z1k213e_223">Move the retrieved value into the %eax register.</p></li></ol></li></ol></section><section class="chapter"><h4 id="6-3-2-address-aomputation-instructions" data-toc="6-3-2-address-aomputation-instructions">6.3.2 Address Computation Instructions</h4><p id="z1k213e_224"><code class="code" id="z1k213e_228">leaq src, dst</code></p><div class="code-block" data-lang="plaintext">
                    leaq (%rdi,%rdi,2), %rax ; Calculate the address of the element at index rdx in an array of integers pointed to by rsi (assuming 4 bytes per integer)
                </div><p id="z1k213e_226">It can also be used for arithmetic expressions.</p><div class="code-block" data-lang="plaintext">
                    leaq (%rdi,%rdi,2), %rax  ; Calculate rax = rdi + (rdi * 2) = 3 * rdi
                </div></section><section class="chapter"><h4 id="6-3-3-arithmetic-instructions" data-toc="6-3-3-arithmetic-instructions">6.3.3 Arithmetic Instructions</h4><p id="z1k213e_229"><span id="z1k213e_237"><font style="color:#8a2be2">Two Operand Instructions:</font></span></p><div class="table-wrapper"><table class="wide" id="z1k213e_230"><thead><tr class="ijRowHead" id="z1k213e_238"><th id="z1k213e_248"><p>Format</p></th><th id="z1k213e_249"><p>Computation</p></th></tr></thead><tbody><tr id="z1k213e_239"><td id="z1k213e_250"><p><code class="code" id="z1k213e_252">addq src, dest</code></p></td><td id="z1k213e_251"><p>dest = dest + src</p></td></tr><tr id="z1k213e_240"><td id="z1k213e_253"><p><code class="code" id="z1k213e_255">subq src, dest</code></p></td><td id="z1k213e_254"><p>dest = dest - src</p></td></tr><tr id="z1k213e_241"><td id="z1k213e_256"><p><code class="code" id="z1k213e_258">imulq src, dest</code></p></td><td id="z1k213e_257"><p>dest = dest * src</p></td></tr><tr id="z1k213e_242"><td id="z1k213e_259"><p><code class="code" id="z1k213e_261">salq src, dest</code></p></td><td id="z1k213e_260"><p>dest = dest &lt;&lt; src</p></td></tr><tr id="z1k213e_243"><td id="z1k213e_262"><p><code class="code" id="z1k213e_264">sarq src, dest</code> (Arithmetic Shift)</p></td><td id="z1k213e_263"><p>dest = dest &gt;&gt; src</p></td></tr><tr id="z1k213e_244"><td id="z1k213e_265"><p><code class="code" id="z1k213e_267">shrq src, dest</code> (Logical Shift)</p></td><td id="z1k213e_266"><p>dest = dest &gt;&gt; src</p></td></tr><tr id="z1k213e_245"><td id="z1k213e_268"><p><code class="code" id="z1k213e_270">xorq src, dest</code></p></td><td id="z1k213e_269"><p>dest = dest ^ src</p></td></tr><tr id="z1k213e_246"><td id="z1k213e_271"><p><code class="code" id="z1k213e_273">andq src, dest</code></p></td><td id="z1k213e_272"><p>dest = dest &amp; src</p></td></tr><tr id="z1k213e_247"><td id="z1k213e_274"><p><code class="code" id="z1k213e_276">orq src, dest</code></p></td><td id="z1k213e_275"><p>dest = dest | src</p></td></tr></tbody></table></div><aside class="prompt" data-type="note" data-title="" id="z1k213e_231"><p id="z1k213e_277">Watch out for the argument order!</p><p id="z1k213e_278">Intel docs use &quot;op dest, src&quot;!</p></aside><p id="z1k213e_232"><span id="z1k213e_279"><font style="color:#8a2be2">One Operand Instructions:</font></span></p><div class="table-wrapper"><table class="wide" id="z1k213e_233"><thead><tr class="ijRowHead" id="z1k213e_280"><th id="z1k213e_290"><p>Format</p></th><th id="z1k213e_291"><p>Computation</p></th></tr></thead><tbody><tr id="z1k213e_281"><td id="z1k213e_292"><p><code class="code" id="z1k213e_294">incq dest</code></p></td><td id="z1k213e_293"><p>dest = dest + 1</p></td></tr><tr id="z1k213e_282"><td id="z1k213e_295"><p><code class="code" id="z1k213e_297">decq src, dest</code></p></td><td id="z1k213e_296"><p>dest = dest - 1</p></td></tr><tr id="z1k213e_283"><td id="z1k213e_298"><p><code class="code" id="z1k213e_300">negq src, dest</code></p></td><td id="z1k213e_299"><p>dest = - dest</p></td></tr><tr id="z1k213e_284"><td id="z1k213e_301"><p><code class="code" id="z1k213e_303">notq dest</code></p></td><td id="z1k213e_302"><p>dest = ~ dest</p></td></tr><tr id="z1k213e_285"><td id="z1k213e_304"><p><code class="code" id="z1k213e_306">sarq src, dest</code> (Arithmetic Shift)</p></td><td id="z1k213e_305"><p>dest = dest &gt;&gt; src</p></td></tr><tr id="z1k213e_286"><td id="z1k213e_307"><p><code class="code" id="z1k213e_309">shrq src, dest</code> (Logical Shift)</p></td><td id="z1k213e_308"><p>dest = dest &gt;&gt; src</p></td></tr><tr id="z1k213e_287"><td id="z1k213e_310"><p><code class="code" id="z1k213e_312">xorq src, dest</code></p></td><td id="z1k213e_311"><p>dest = dest ^ src</p></td></tr><tr id="z1k213e_288"><td id="z1k213e_313"><p><code class="code" id="z1k213e_315">andq src, dest</code></p></td><td id="z1k213e_314"><p>dest = dest &amp; src</p></td></tr><tr id="z1k213e_289"><td id="z1k213e_316"><p><code class="code" id="z1k213e_318">orq src, dest</code></p></td><td id="z1k213e_317"><p>dest = dest | src</p></td></tr></tbody></table></div><p id="z1k213e_234"><span id="z1k213e_319"><font style="color:#ff69b4">Example</font></span></p><div class="code-collapse" data-lang="c" data-is-expanded="false" data-synopsis="long arith(long x, long y, long z) {">
                    long arith(long x, long y, long z) {
                    long t1 = x + y;
                    long t2 = z + t1;
                    long t3 = x + 4;
                    long t4 = y * 48;
                    long t5 = t3 + t4;
                    long rval = t2 * t5;
                    return rval;
                    }
                </div><div class="code-collapse" data-lang="plaintext" data-is-expanded="false" data-synopsis="0000000000001149 &lt;arith&gt;:">
                    0000000000001149 &lt;arith&gt;:
                    1149:	f3 0f 1e fa          	endbr64
                    114d:	55                   	push   %rbp
                    114e:	48 89 e5             	mov    %rsp,%rbp
                    1151:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)   # Store x on the stack
                    1155:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)   # Store y on the stack
                    1159:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)   # Store z on the stack
                    115d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx  # Load x into rdx
                    1161:	48 8b 45 c0          	mov    -0x40(%rbp),%rax  # Load y into rax
                    1165:	48 01 d0             	add    %rdx,%rax         # t1 = x + y
                    1168:	48 89 45 d0          	mov    %rax,-0x30(%rbp)   # Store t1 on the stack
                    116c:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx  # Load z into rdx
                    1170:	48 8b 45 d0          	mov    -0x30(%rbp),%rax  # Load t1 into rax
                    1174:	48 01 d0             	add    %rdx,%rax         # t2 = z + t1
                    1177:	48 89 45 d8          	mov    %rax,-0x28(%rbp)   # Store t2 on the stack
                    117b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax  # Load x into rax
                    117f:	48 83 c0 04          	add    $0x4,%rax         # t3 = x + 4
                    1183:	48 89 45 e0          	mov    %rax,-0x20(%rbp)   # Store t3 on the stack
                    1187:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx  # Load y into rdx
                    118b:	48 89 d0             	mov    %rdx,%rax         # Copy y into rax (for multiplication)
                    118e:	48 01 c0             	add    %rax,%rax         # Multiply y by 2 (left shift)
                    1191:	48 01 d0             	add    %rdx,%rax         # Add y (original value) so now its 3y
                    1194:	48 c1 e0 04          	shl    $0x4,%rax         # Multiply by 16 (left shift 4) 3y*16 = 48y
                    1198:	48 89 45 e8          	mov    %rax,-0x18(%rbp)   # Store t4 = 48 * y on the stack
                    119c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx  # Load t3 into rdx
                    11a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax  # Load t4 into rax
                    11a4:	48 01 d0             	add    %rdx,%rax         # t5 = t3 + t4
                    11a7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)   # Store t5 on the stack
                    11ab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax  # Load t2 into rax
                    11af:	48 0f af 45 f0       	imul   -0x10(%rbp),%rax  # rval = t2 * t5
                    11b4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)    # Store rval on the stack
                    11b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax   # Move rval into rax (return value)
                    11bc:	5d                   	pop    %rbp              # Restore the caller's base pointer
                    11bd:	c3                   	ret                      # Return from the function
                </div></section></section><section class="chapter"><h3 id="6-4-c-assembly-machine-code-x86" data-toc="6-4-c-assembly-machine-code-x86">6.4 C, Assembly &amp; Machine Code</h3><p id="z1k213e_320">Compile with the following code (debugging-friendly):</p><div class="code-block" data-lang="plaintext">
                gcc –Og p1.c -o p
            </div><figure id="z1k213e_322"><img alt="C, Assembly &amp; Machine Code" src="Computer-Science-Study-Notes/a6-4-1.png" title="C, Assembly &amp; Machine Code" width="2631" height="1242"></figure><p id="z1k213e_323">Use the following command to generate the assembly code:</p><div class="code-block" data-lang="plaintext">
                gcc –Og –S p1.c
            </div><p id="z1k213e_325">Use the following command to disassembly the machine code:</p><div class="code-block" data-lang="plaintext">
                objdump –d p1
            </div></section></section><section class="chapter"><h2 id="7-control-flow-instructions-x86" data-toc="7-control-flow-instructions-x86">7 Control Flow Instructions</h2><section class="chapter"><h3 id="7-1-conditional-codes-x86" data-toc="7-1-conditional-codes-x86">7.1 Conditional Codes</h3><p id="z1k213e_331"><span id="z1k213e_337"><font style="color:#8a2be2">Processor State (Partial)</font></span></p><ul class="list _bullet" id="z1k213e_332"><li class="list__item" id="z1k213e_338"><p id="z1k213e_342"><span id="z1k213e_343"><font style="color:#ff00ff">Temporary Data:</font></span> %rax, ...</p></li><li class="list__item" id="z1k213e_339"><p id="z1k213e_344"><span id="z1k213e_345"><font style="color:#ff00ff">Location of runtime stack:</font></span> %rsp, ...</p></li><li class="list__item" id="z1k213e_340"><p id="z1k213e_346"><span id="z1k213e_347"><font style="color:#ff00ff">Location of current code control point:</font></span> %rip, ...</p></li><li class="list__item" id="z1k213e_341"><p id="z1k213e_348"><span id="z1k213e_349"><font style="color:#ff00ff">Status of recent tests:</font></span> CF, ZF, SF, OF, ... =&gt; Conditional Codes!</p></li></ul><p id="z1k213e_333"><span id="z1k213e_350"><font style="color:#8a2be2">Conditional Codes</font></span></p><ul class="list _bullet" id="z1k213e_334"><li class="list__item" id="z1k213e_351"><p id="z1k213e_353">Single bit registers, GDB prints these as one &quot;rflags&quot; register or &quot;eflags&quot;(more commonly used, lower 32 bits).</p></li><li class="list__item" id="z1k213e_352"><p id="z1k213e_354">Implicitly set (as side effect) of arithmetic operations.</p><ul class="list _bullet" id="z1k213e_355"><li class="list__item" id="z1k213e_356"><p id="z1k213e_360"><span id="z1k213e_361"><font style="color:#ff00ff">CF (Carry Flag):</font></span> Overflowing or underflowing in an unsigned range.</p></li><li class="list__item" id="z1k213e_357"><p id="z1k213e_362"><span id="z1k213e_363"><font style="color:#ff00ff">ZF (Zero Flag):</font></span> The result of an operation is zero</p></li><li class="list__item" id="z1k213e_358"><p id="z1k213e_364"><span id="z1k213e_365"><font style="color:#ff00ff">SF (Sign Flag):</font></span> The result of an operation, interpreted as a signed two's complement number, is negative (MSB is 1).</p></li><li class="list__item" id="z1k213e_359"><p id="z1k213e_366"><span id="z1k213e_367"><font style="color:#ff00ff">OF (Overflow FLag):</font></span> Overflow in signed two's complement.</p></li></ul></li></ul><p id="z1k213e_335"><span id="z1k213e_368"><font style="color:#8a2be2">Instructions</font></span></p><ol class="list _decimal" id="z1k213e_336" type="1"><li class="list__item" id="z1k213e_369"><p id="z1k213e_371"><code class="code" id="z1k213e_374">cmp a, b</code></p><p id="z1k213e_372">Computes <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="4.933ex" height="1.756ex" role="img" focusable="false" viewBox="0 -694 2180.4 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(651.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(1651.4,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g></g></g></svg></mjx-container>, set conditional codes based on result, <span id="z1k213e_376"><font style="color:#ff4500">but does not change b!</font></span></p><p id="z1k213e_373">Used for <code class="code" id="z1k213e_377">if (a &lt; b)</code></p></li><li class="list__item" id="z1k213e_370"><p id="z1k213e_378"><code class="code" id="z1k213e_382">test a, b</code></p><p id="z1k213e_379">Computes <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="4.072ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 1800 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="merror" data-mjx-error="Misplaced &" title="Misplaced &"><rect data-background="true" width="1800" height="950" y="-200"></rect><title>Misplaced &</title><g data-mml-node="mtext" style="font-family: serif;"><text data-variant="-explicitFont" transform="scale(1,-1)" font-size="884px">b&amp;a</text></g></g></g></g></svg></mjx-container>, set conditional codes based on the result, <span id="z1k213e_384"><font style="color:#ff4500">but does not change b!</font></span></p><p id="z1k213e_380"><span id="z1k213e_385"><font style="color:#ff00ff">Most common use:</font></span> <code class="code" id="z1k213e_386">test %rx, %rx</code> to compare %rx to zero</p><p id="z1k213e_381"><span id="z1k213e_387"><font style="color:#ff00ff">Second most common use:</font></span> <code class="code" id="z1k213e_388">test %rX, %rY</code> to test if any of the 1-bits in <code class="code" id="z1k213e_389">%rY</code> are also 1 in <code class="code" id="z1k213e_390">%rX</code>.</p></li></ol></section><section class="chapter"><h3 id="7-2-conditional-Branches-x86" data-toc="7-2-conditional-Branches-x86">7.2 Conditional Branches</h3><p id="z1k213e_391"><span id="z1k213e_400"><font style="color:#8a2be2">Jumping</font></span></p><div class="table-wrapper"><table class="wide" id="z1k213e_392"><thead><tr class="ijRowHead" id="z1k213e_401"><th id="z1k213e_413"><p><code class="code" id="z1k213e_416">jX</code></p></th><th id="z1k213e_414"><p>Condition</p></th><th id="z1k213e_415"><p>Description</p></th></tr></thead><tbody><tr id="z1k213e_402"><td id="z1k213e_417"><p><code class="code" id="z1k213e_420">jmp</code></p></td><td id="z1k213e_418"><p>1</p></td><td id="z1k213e_419"><p>Unconditional</p></td></tr><tr id="z1k213e_403"><td id="z1k213e_421"><p><code class="code" id="z1k213e_424">je</code></p></td><td id="z1k213e_422"><p><code class="code" id="z1k213e_425">ZF</code></p></td><td id="z1k213e_423"><p>Equal/Zero</p></td></tr><tr id="z1k213e_404"><td id="z1k213e_426"><p><code class="code" id="z1k213e_429">jne</code></p></td><td id="z1k213e_427"><p><code class="code" id="z1k213e_430">~ZF</code></p></td><td id="z1k213e_428"><p>Not Equal/Not Zero</p></td></tr><tr id="z1k213e_405"><td id="z1k213e_431"><p><code class="code" id="z1k213e_434">js</code></p></td><td id="z1k213e_432"><p><code class="code" id="z1k213e_435">SF</code></p></td><td id="z1k213e_433"><p>Negative</p></td></tr><tr id="z1k213e_406"><td id="z1k213e_436"><p><code class="code" id="z1k213e_439">jns</code></p></td><td id="z1k213e_437"><p><code class="code" id="z1k213e_440">~SF</code></p></td><td id="z1k213e_438"><p>Non-Negative</p></td></tr><tr id="z1k213e_407"><td id="z1k213e_441"><p><code class="code" id="z1k213e_444">jq</code></p></td><td id="z1k213e_442"><p><code class="code" id="z1k213e_445">~(SF^OF)&amp;~ZF</code></p></td><td id="z1k213e_443"><p>Greater (Signed)</p></td></tr><tr id="z1k213e_408"><td id="z1k213e_446"><p><code class="code" id="z1k213e_449">jqe</code></p></td><td id="z1k213e_447"><p><code class="code" id="z1k213e_450">~(SF^OF)</code></p></td><td id="z1k213e_448"><p>Greater or Equal (Signed)</p></td></tr><tr id="z1k213e_409"><td id="z1k213e_451"><p><code class="code" id="z1k213e_454">jl</code></p></td><td id="z1k213e_452"><p><code class="code" id="z1k213e_455">(SF^OF)</code></p></td><td id="z1k213e_453"><p>Less (Signed)</p></td></tr><tr id="z1k213e_410"><td id="z1k213e_456"><p><code class="code" id="z1k213e_459">jle</code></p></td><td id="z1k213e_457"><p><code class="code" id="z1k213e_460">(SF^OF)|ZF</code></p></td><td id="z1k213e_458"><p>Less or Equal (Signed)</p></td></tr><tr id="z1k213e_411"><td id="z1k213e_461"><p><code class="code" id="z1k213e_464">ja</code></p></td><td id="z1k213e_462"><p><code class="code" id="z1k213e_465">~CF&amp;~ZF</code></p></td><td id="z1k213e_463"><p>Above (unsigned)</p></td></tr><tr id="z1k213e_412"><td id="z1k213e_466"><p><code class="code" id="z1k213e_469">jb</code></p></td><td id="z1k213e_467"><p><code class="code" id="z1k213e_470">CF</code></p></td><td id="z1k213e_468"><p>Below (unsigned)</p></td></tr></tbody></table></div><p id="z1k213e_393"><span id="z1k213e_471"><font style="color:#8a2be2"><code class="code" id="z1k213e_473">SetX</code> Instructions:</font></span> Set low-order byte of destination to 0 or 1 based on combinations of condition codes. <span id="z1k213e_472"><font style="color:#ff4500">Does not alter remaining 7 bytes!</font></span></p><div class="table-wrapper"><table class="wide" id="z1k213e_394"><thead><tr class="ijRowHead" id="z1k213e_474"><th id="z1k213e_485"><p><code class="code" id="z1k213e_488">SetX</code></p></th><th id="z1k213e_486"><p>Condition</p></th><th id="z1k213e_487"><p>Description</p></th></tr></thead><tbody><tr id="z1k213e_475"><td id="z1k213e_489"><p><code class="code" id="z1k213e_492">sete</code></p></td><td id="z1k213e_490"><p><code class="code" id="z1k213e_493">ZF</code></p></td><td id="z1k213e_491"><p>Equal/Zero</p></td></tr><tr id="z1k213e_476"><td id="z1k213e_494"><p><code class="code" id="z1k213e_497">setne</code></p></td><td id="z1k213e_495"><p><code class="code" id="z1k213e_498">~ZF</code></p></td><td id="z1k213e_496"><p>Not Equal/Not Zero</p></td></tr><tr id="z1k213e_477"><td id="z1k213e_499"><p><code class="code" id="z1k213e_502">sets</code></p></td><td id="z1k213e_500"><p><code class="code" id="z1k213e_503">SF</code></p></td><td id="z1k213e_501"><p>Negative</p></td></tr><tr id="z1k213e_478"><td id="z1k213e_504"><p><code class="code" id="z1k213e_507">setns</code></p></td><td id="z1k213e_505"><p><code class="code" id="z1k213e_508">~SF</code></p></td><td id="z1k213e_506"><p>Non-Negative</p></td></tr><tr id="z1k213e_479"><td id="z1k213e_509"><p><code class="code" id="z1k213e_512">setg</code></p></td><td id="z1k213e_510"><p><code class="code" id="z1k213e_513">~(SF^OF)&amp;~ZF</code></p></td><td id="z1k213e_511"><p>Greater (Signed)</p></td></tr><tr id="z1k213e_480"><td id="z1k213e_514"><p><code class="code" id="z1k213e_517">setge</code></p></td><td id="z1k213e_515"><p><code class="code" id="z1k213e_518">~(SF^OF)</code></p></td><td id="z1k213e_516"><p>Greater or Equal (Signed)</p></td></tr><tr id="z1k213e_481"><td id="z1k213e_519"><p><code class="code" id="z1k213e_522">setl</code></p></td><td id="z1k213e_520"><p><code class="code" id="z1k213e_523">(SF^OF)</code></p></td><td id="z1k213e_521"><p>Less (Signed)</p></td></tr><tr id="z1k213e_482"><td id="z1k213e_524"><p><code class="code" id="z1k213e_527">setle</code></p></td><td id="z1k213e_525"><p><code class="code" id="z1k213e_528">(SF^OF)|ZF</code></p></td><td id="z1k213e_526"><p>Less or Equal (Signed)</p></td></tr><tr id="z1k213e_483"><td id="z1k213e_529"><p><code class="code" id="z1k213e_532">seta</code></p></td><td id="z1k213e_530"><p><code class="code" id="z1k213e_533">~CF&amp;~ZF</code></p></td><td id="z1k213e_531"><p>Above (unsigned)</p></td></tr><tr id="z1k213e_484"><td id="z1k213e_534"><p><code class="code" id="z1k213e_537">setb</code></p></td><td id="z1k213e_535"><p><code class="code" id="z1k213e_538">CF</code></p></td><td id="z1k213e_536"><p>Below (unsigned)</p></td></tr></tbody></table></div><aside class="prompt" data-type="note" data-title="" id="z1k213e_395"><p id="z1k213e_539">Typically use <code class="code" id="z1k213e_541">movzbl</code> to finish job</p><p id="z1k213e_540"><code class="code" id="z1k213e_542">movzbl</code> takes this byte and zero-extends it into a larger 32-bit register or memory location. Zero-extending means it copies the byte into the lower 8 bits of the destination and fills the remaining higher bits with zeros.</p></aside><p id="z1k213e_396"><span id="z1k213e_543"><font style="color:#8a2be2">Normal version vs. goto version</font></span></p><div class="code-comparer" id="z1k213e_397" data-comparing="vertically"><div class="code-block" data-lang="c" data-title="Normal version">
                    #include &lt;stdio.h&gt;

                    int main() {
                    int x = 5;

                    if (x &gt; 3) {
                    printf(&quot;x is greater than 3\n&quot;);
                    } else {
                    printf(&quot;x is less than or equal to 3\n&quot;);
                    }

                    return 0;
                    }
                </div><div class="code-block" data-lang="c" data-title="goto version">
                    #include &lt;stdio.h&gt;

                    int main() {
                    int x = 5;

                    if (x &gt; 3) {
                    goto greater_than_three;
                    } else {
                    goto less_than_or_equal_to_three;
                    }

                    greater_than_three:
                    printf(&quot;x is greater than 3\n&quot;);
                    goto end; // Jump to the end to avoid the other block

                    less_than_or_equal_to_three:
                    printf(&quot;x is less than or equal to 3\n&quot;);

                    end:
                    return 0;
                    }
                </div></div><p id="z1k213e_398"><span id="z1k213e_546"><font style="color:#cd5c5c">Example</font></span></p><div class="code-collapse" data-lang="plaintext" data-is-expanded="false" data-synopsis="0000000000000000 &lt;main&gt;:">
                0000000000000000 &lt;main&gt;:
                #include &lt;stdio.h&gt;

                int main() {
                0:	f3 0f 1e fa          	endbr64
                4:	55                   	push   %rbp
                5:	48 89 e5             	mov    %rsp,%rbp
                8:	48 83 ec 10          	sub    $0x10,%rsp
                int y = 15;
                c:	c7 45 fc 0f 00 00 00 	movl   $0xf,-0x4(%rbp)

                if (y &lt; 10) {
                13:	83 7d fc 09          	cmpl   $0x9,-0x4(%rbp)
                17:	7f 05                	jg     1e &lt;main+0x1e&gt;
                y = y * 2;
                19:	d1 65 fc             	shll   $1,-0x4(%rbp)
                1c:	eb 04                	jmp    22 &lt;main+0x22&gt;
                } else {
                y = y + 1;
                1e:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
                }

                printf(&quot;y = %d\n&quot;, y);
                22:	8b 45 fc             	mov    -0x4(%rbp),%eax
                25:	89 c6                	mov    %eax,%esi
                27:	48 8d 05 00 00 00 00 	lea    0x0(%rip),%rax        # 2e &lt;main+0x2e&gt;
                2e:	48 89 c7             	mov    %rax,%rdi
                31:	b8 00 00 00 00       	mov    $0x0,%eax
                36:	e8 00 00 00 00       	call   3b &lt;main+0x3b&gt;
                return 0;
                3b:	b8 00 00 00 00       	mov    $0x0,%eax
                40:	c9                   	leave
                41:	c3                   	ret
            </div></section><section class="chapter"><h3 id="7-3-loops-x86" data-toc="7-3-loops-x86">7.3 Loops</h3><p id="z1k213e_547"><span id="z1k213e_549"><font style="color:#cd5c5c">Example</font></span></p><div class="code-collapse" data-lang="plaintext" data-is-expanded="false" data-synopsis="0000000000000000 &lt;main&gt;:">
                0000000000000000 &lt;main&gt;:
                #include &lt;stdio.h&gt;

                int main() {
                0:	f3 0f 1e fa          	endbr64
                4:	55                   	push   %rbp
                5:	48 89 e5             	mov    %rsp,%rbp
                8:	48 83 ec 10          	sub    $0x10,%rsp
                int i;
                for (i = 0; i &lt; 5; i++) {
                c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
                13:	eb 1d                	jmp    32 &lt;main+0x32&gt;
                printf(&quot;Iteration: %d\n&quot;, i);
                15:	8b 45 fc             	mov    -0x4(%rbp),%eax
                18:	89 c6                	mov    %eax,%esi
                1a:	48 8d 05 00 00 00 00 	lea    0x0(%rip),%rax        # 21 &lt;main+0x21&gt;
                21:	48 89 c7             	mov    %rax,%rdi
                24:	b8 00 00 00 00       	mov    $0x0,%eax
                29:	e8 00 00 00 00       	call   2e &lt;main+0x2e&gt;
                for (i = 0; i &lt; 5; i++) {
                2e:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
                32:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
                36:	7e dd                	jle    15 &lt;main+0x15&gt;
                }
                return 0;
                38:	b8 00 00 00 00       	mov    $0x0,%eax
                3d:	c9                   	leave
                3e:	c3                   	ret
            </div></section><section class="chapter"><h3 id="7-4-switch-statements-x86" data-toc="7-4-switch-statements-x86">7.4 Switch Statements</h3><p id="z1k213e_550"><span id="z1k213e_552"><font style="color:#cd5c5c">Example</font></span></p><div class="code-collapse" data-lang="plaintext" data-is-expanded="false" data-synopsis="0000000000000000 &lt;main&gt;:">
                0000000000000000 &lt;main&gt;:
                #include &lt;stdio.h&gt;

                int main() {
                0:	f3 0f 1e fa          	endbr64
                4:	55                   	push   %rbp
                5:	48 89 e5             	mov    %rsp,%rbp
                8:	48 83 ec 10          	sub    $0x10,%rsp
                int x = 2;
                c:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%rbp)
                int result = 0;
                13:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)

                switch (x) {
                1a:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
                1e:	74 26                	je     46 &lt;main+0x46&gt;
                20:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
                24:	7f 29                	jg     4f &lt;main+0x4f&gt;
                26:	83 7d fc 01          	cmpl   $0x1,-0x4(%rbp)
                2a:	74 08                	je     34 &lt;main+0x34&gt;
                2c:	83 7d fc 02          	cmpl   $0x2,-0x4(%rbp)
                30:	74 0b                	je     3d &lt;main+0x3d&gt;
                32:	eb 1b                	jmp    4f &lt;main+0x4f&gt;
                case 1:
                result = 10;
                34:	c7 45 f8 0a 00 00 00 	movl   $0xa,-0x8(%rbp)
                break;
                3b:	eb 19                	jmp    56 &lt;main+0x56&gt;
                case 2:
                result = 20;
                3d:	c7 45 f8 14 00 00 00 	movl   $0x14,-0x8(%rbp)
                break;
                44:	eb 10                	jmp    56 &lt;main+0x56&gt;
                case 3:
                result = 30;
                46:	c7 45 f8 1e 00 00 00 	movl   $0x1e,-0x8(%rbp)
                break;
                4d:	eb 07                	jmp    56 &lt;main+0x56&gt;
                default:
                result = 0;
                4f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
                }

                printf(&quot;Result: %d\n&quot;, result);
                56:	8b 45 f8             	mov    -0x8(%rbp),%eax
                59:	89 c6                	mov    %eax,%esi
                5b:	48 8d 05 00 00 00 00 	lea    0x0(%rip),%rax        # 62 &lt;main+0x62&gt;
                62:	48 89 c7             	mov    %rax,%rdi
                65:	b8 00 00 00 00       	mov    $0x0,%eax
                6a:	e8 00 00 00 00       	call   6f &lt;main+0x6f&gt;
                return 0;
                6f:	b8 00 00 00 00       	mov    $0x0,%eax
                74:	c9                   	leave
                75:	c3                   	ret
            </div></section></section><section class="chapter"><h2 id="8-program-optimization" data-toc="8-program-optimization">8 Program Optimization</h2><p id="z1k213e_553"><span id="z1k213e_559"><font style="color:#8a2be2">Limitations of Optimizing Compilers</font></span></p><ul class="list _bullet" id="z1k213e_554"><li class="list__item" id="z1k213e_560"><p id="z1k213e_564">Operate under fundamental constraint.</p></li><li class="list__item" id="z1k213e_561"><p id="z1k213e_565">Behavior that may be obvious to programmers can be obfuscated by languages and code styles.</p></li><li class="list__item" id="z1k213e_562"><p id="z1k213e_566">When in doubt, the compiler must be conservative.</p></li><li class="list__item" id="z1k213e_563"><p id="z1k213e_567">...</p></li></ul><section class="chapter"><h3 id="8-1-generally-useful-optimizations" data-toc="8-1-generally-useful-optimizations">8.1 Generally Useful Optimizations</h3><ul class="list _bullet" id="z1k213e_568"><li class="list__item" id="z1k213e_569"><p id="z1k213e_573"><span id="z1k213e_575"><font style="color:#ff00ff">Reduce frequency with which computation performed</font></span></p><div class="code-comparer" id="z1k213e_574" data-comparing="vertically"><div class="code-block" data-lang="c" data-title="Raw">
                            void set_row(double *a, double *b, long i, long n) {
                            long j;
                            for (j = 0; j &lt; n; j++) {
                            a[i * n + j] = b[j];
                            }
                            }
                        </div><div class="code-block" data-lang="c" data-title="Optimized">
                            void set_row(double *a, double *b, long i, long n) {
                            long j;
                            int ni = n + i;
                            for (j = 0; j &lt; n; j++) {
                            a[ni + j] = b[j];
                            }
                            }
                        </div></div></li><li class="list__item" id="z1k213e_570"><p id="z1k213e_578"><span id="z1k213e_580"><font style="color:#ff00ff">Reduction in Strength: Shift, add instead of multiply or divide</font></span></p><div class="code-comparer" id="z1k213e_579" data-comparing="vertically"><div class="code-block" data-lang="c" data-title="Raw">
                            for (int i = 0; i &lt; n; i++) {
                            int ni = n * i;
                            for (int j = 0; j &lt; n; j++)
                            a[ni + j] = b[j];
                            }
                        </div><div class="code-block" data-lang="c" data-title="Optimized">
                            int ni = 0;
                            for (int i = 0; i &lt; n; i++) {
                            for (int j = 0; j &lt; n; j++)
                            a[ni + j] = b[j];
                            ni += n;
                            }
                        </div></div></li><li class="list__item" id="z1k213e_571"><p id="z1k213e_583"><span id="z1k213e_585"><font style="color:#ff00ff">Share Common Subexpressions</font></span></p><div class="code-comparer" id="z1k213e_584" data-comparing="vertically"><div class="code-block" data-lang="c" data-title="Raw">
                            /* Sum neighbors of i, j */
                            up = val[(i - 1) * n + j];
                            down = val[(i + 1) * n + j];
                            left = val[i * n + j - 1];
                            down = val[i * n + j + 1];
                            sum = up + down + left + right;
                            // 3 multiplications
                        </div><div class="code-block" data-lang="c" data-title="Optimized">
                            long inj = i * n + j;
                            up = val[inj - n];
                            down = val[inj + n];
                            left = val[inj - 1];
                            down = val[inj + 1];
                            sum = up + down + left + right;
                            // 1 multiplication
                        </div></div></li><li class="list__item" id="z1k213e_572"><p id="z1k213e_588"><span id="z1k213e_589"><font style="color:#ff00ff">Remove unnecessary procedure calls</font></span></p></li></ul></section><section class="chapter"><h3 id="8-2-optimization-blockers" data-toc="8-2-optimization-blockers">8.2 Optimization Blockers</h3><ul class="list _bullet" id="z1k213e_590"><li class="list__item" id="procedure-calls"><p id="z1k213e_593"><span id="z1k213e_596"><font style="color:#ff00ff">Procedure Calls</font></span></p><div class="code-comparer" id="z1k213e_594" data-comparing="vertically"><div class="code-block" data-lang="none" data-title="Raw">
                            /* Convert string to lower case with quadratic performance*/
                            void lower(char* s) {
                            size_t i;
                            for (i = 0; i &lt; strlen(s); i++) {
                            if (s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z')
                            s[i] += 'a' - 'A';
                            }
                            }
                        </div><div class="code-block" data-lang="none" data-title="Optimized">
                            /* Optimized code */
                            void lower(char* s) {
                            size_t i;
                            size_t len = strlen(s);
                            for (i = 0; i &lt; len; i++) {
                            if (s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z')
                            s[i] += 'a' - 'A';
                            }
                            }
                        </div></div><ul class="list _bullet" id="z1k213e_595"><li class="list__item" id="z1k213e_599"><p id="z1k213e_601"><code class="code" id="z1k213e_602">strlen()</code> takes linear time to scan the string until it reaches the null character.</p></li><li class="list__item" id="z1k213e_600"><p id="z1k213e_603">Why couldn't compiler move <code class="code" id="z1k213e_605">strlen()</code> out of inner loop?</p><ul class="list _bullet" id="z1k213e_604"><li class="list__item" id="z1k213e_606"><p id="z1k213e_610">Procedure may have side effects.</p></li><li class="list__item" id="z1k213e_607"><p id="z1k213e_611">Function may not return the same value for a given argument.</p></li><li class="list__item" id="z1k213e_608"><p id="z1k213e_612">Compiler treats procedure call as a black box =&gt; weak optimizaion!</p></li><li class="list__item" id="z1k213e_609"><p id="z1k213e_613">You can use GCC with inline functions and optimization O1, but better do yur own code motion.</p></li></ul></li></ul></li><li class="list__item" id="z1k213e_592"><p id="z1k213e_614"><span id="z1k213e_618"><font style="color:#ff00ff">Memory Alias</font></span></p><div class="code-block" data-lang="c">
                        void sum_rows1(double *a, double *b, long n)  {
                        long i, j;
                        for (i = 0; i &lt; n; i++) {
                        b[i] = 0;
                        for (j = 0; j &lt; n; j++) {
                        b[i] += a[i * n + j];
                        }
                        }
                        }

                        int main() {
                        double A[9] =
                        {0, 1, 2,
                        4, 8, 16,
                        32, 64, 128};
                        double B[3] = A + 3;
                        sum_rows1(A, B, 3);
                        return 0;
                        }
                    </div><p id="z1k213e_616">Memory and registers have to pass values over and over again!</p><p id="z1k213e_617">The optimizer cannot optimize because the code may updates a[i] on every iteration!</p></li></ul></section><section class="chapter"><h3 id="8-3-exploit-instruction-level-parallelism" data-toc="8-3-exploit-instruction-level-parallelism">8.3 Exploit Instruction-Level Parallelism</h3><p id="z1k213e_619"><span id="z1k213e_639"><font style="color:#ff8c00">CPE (Cycle Per Element)</font></span></p><ul class="list _bullet" id="z1k213e_620"><li class="list__item" id="z1k213e_640"><p id="z1k213e_642">Convenient way to express performance of program that operates on vectors or lists.</p></li><li class="list__item" id="z1k213e_641"><p id="z1k213e_643">Cycles = CPE*n + Overhead, CPE is slope of line.</p></li></ul><figure id="z1k213e_621"><img alt="CPE" src="Computer-Science-Study-Notes/a8-3-1.png" title="CPE" width="1890" height="1076"></figure><p id="z1k213e_622"><span id="z1k213e_644"><font style="color:#8a2be2">Modern CPU Design</font></span></p><figure id="z1k213e_623"><img alt="Modern CPU Design" src="Computer-Science-Study-Notes/a8-3-2.png" title="Modern CPU Design" width="2465" height="1756"></figure><p id="z1k213e_624"><span id="z1k213e_645"><font style="color:#8a2be2">Pipelined Functional Units</font></span></p><figure id="z1k213e_625"><img alt="Pipelined Functional Units" src="Computer-Science-Study-Notes/a8-3-3.png" title="Pipelined Functional Units" width="2685" height="1397"></figure><ul class="list _bullet" id="z1k213e_626"><li class="list__item" id="z1k213e_646"><p id="z1k213e_648">Divide computation into stages.</p></li><li class="list__item" id="z1k213e_647"><p id="z1k213e_649">Pass partial computations from stage to stage.</p></li></ul><p id="z1k213e_627"><span id="z1k213e_650"><font style="color:#8a2be2">Loop Unrolling:</font></span> Reason: Breaks sequential dependency</p><p id="z1k213e_628"><span id="z1k213e_651"><font style="color:#cd5c5c">No Loop Unrolling</font></span></p><div class="code-block" data-lang="c">
                for (i = 0; i &lt; length; i++) {
                x = x + d[i];
                }
            </div><figure id="z1k213e_630"><img alt="No Loop Unrolling" src="Computer-Science-Study-Notes/a8-3-4.png" title="No Loop Unrolling" width="1077" height="1474"></figure><p id="z1k213e_631"><span id="z1k213e_652"><font style="color:#cd5c5c">Loop Unrolling (<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="4.023ex" height="1.507ex" role="img" focusable="false" viewBox="0 -666 1778 666"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(778,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1278,0)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container>)</font></span></p><div class="code-block" data-lang="c">
                for (int i = 0; i &lt; limit; i +=2)
                x = x + d[i] + d[i + 1];
                }
            </div><p id="z1k213e_633"><span id="z1k213e_654"><font style="color:#cd5c5c">Loop Unrolling (<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex;" xmlns="http://www.w3.org/2000/svg" width="5.219ex" height="1.529ex" role="img" focusable="false" viewBox="0 -666 2307 676"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(778,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1278,0)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g></g></g></g></svg></mjx-container>)</font></span></p><div class="code-block" data-lang="c">
                for (int i = 0; i &lt; limit; i +=2)
                x = x + (d[i] + d[i + 1]);
                }
            </div><figure id="z1k213e_635"><img alt="Loop Unrolling (2*1a)" src="Computer-Science-Study-Notes/a8-3-5.png" title="Loop Unrolling (2*1a)" width="3000" height="2250"></figure><p id="z1k213e_636"><span id="z1k213e_656"><font style="color:#cd5c5c">Loop Unrolling (<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="4.023ex" height="1.507ex" role="img" focusable="false" viewBox="0 -666 1778 666"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(778,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1278,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g></svg></mjx-container>)</font></span></p><div class="code-block" data-lang="c">
                for (int i = 0; i &lt; limit; i +=4)
                x0 = x0 + d[i];
                x1 = x1 + d[i + 1];
                }
            </div><figure id="z1k213e_638"><img alt="Loop Unrolling (2*2)" src="Computer-Science-Study-Notes/a8-3-6.png" title="Loop Unrolling (2*2)" width="1243" height="1000"></figure></section><section class="chapter"><h3 id="8-4-dealing-with-conditions" data-toc="8-4-dealing-with-conditions">8.4 Dealing with Conditions</h3><p id="z1k213e_658"><span id="z1k213e_660"><font style="color:#ff4500">Instruction Control Unit</font></span> must work well ahead of <span id="z1k213e_661"><font style="color:#ff4500">Execution Unit</font></span> to generate enough operations to keep EU busy!</p><section class="procedure-steps"><h3 id="z1k213e_659" data-toc="z1k213e_659">Branch Prediction</h3><ol class="list _decimal"><li class="list__item" id="z1k213e_662"><p id="z1k213e_665">Guess which way branch will go.</p></li><li class="list__item" id="z1k213e_663"><p id="z1k213e_666">Begin executing instructions at predicted position, but don&rsquo;t actually modify register or memory data.</p></li><li class="list__item" id="z1k213e_664"><p id="z1k213e_667">If correct, execute; if mispredict, recover.</p></li></ol></section></section></section><section class="chapter"><h2 id="9-memory-hierarchy" data-toc="9-memory-hierarchy">9 Memory Hierarchy</h2></section><div class="last-modified">Last modified: 06 November 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="computer-architecture-risc-v.html" class="navigation-links__prev">RISC-Ⅴ Architecture</a><a href="data-structures-and-algorithms.html" class="navigation-links__next">Data Structures and Algorithms</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b419/app.js"></script></body></html>