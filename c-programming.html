<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#6860F6" data-link-color="#307FFF" data-resizable-sidebar="true" data-sidebar-width="260"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2024-12-08T19:49:03.0891964"><title>C++ Programming | Computer Science Study Notes</title><script type="application/json" id="virtual-toc-data">[{"id":"c-fundamentals","level":0,"title":"Ⅰ C++ Fundamentals","anchor":"#c-fundamentals"},{"id":"intro","level":1,"title":"1 C \u0026 C++ Introduction","anchor":"#intro"},{"id":"2-types-and-structs","level":1,"title":"2 Types and Structs","anchor":"#2-types-and-structs"},{"id":"2-1-primitive-types","level":2,"title":"2.1 Primitive Types","anchor":"#2-1-primitive-types"},{"id":"structs","level":2,"title":"2.2 Structs","anchor":"#structs"},{"id":"3-initialization-references","level":1,"title":"3 Initialization \u0026 References","anchor":"#3-initialization-references"},{"id":"3-1-initialization","level":2,"title":"3.1 Initialization","anchor":"#3-1-initialization"},{"id":"3-2-references","level":2,"title":"3.2 References","anchor":"#3-2-references"},{"id":"4-streams","level":1,"title":"4 Streams","anchor":"#4-streams"},{"id":"4-1-strings","level":2,"title":"4.1 Strings","anchor":"#4-1-strings"},{"id":"4-2-stringstreams","level":2,"title":"4.2 Stringstreams","anchor":"#4-2-stringstreams"},{"id":"4-3-input-streams","level":2,"title":"4.3 Input Streams","anchor":"#4-3-input-streams"},{"id":"4-4-output-streams","level":2,"title":"4.4 Output Streams","anchor":"#4-4-output-streams"},{"id":"5-modern-c-types","level":1,"title":"5 Modern C++ Types","anchor":"#5-modern-c-types"},{"id":"5-1-auto","level":2,"title":"5.1 Auto","anchor":"#5-1-auto"},{"id":"5-2-pair-tuple","level":2,"title":"5.2 Pair/Tuple","anchor":"#5-2-pair-tuple"},{"id":"5-3-conversions","level":2,"title":"5.3 Conversions","anchor":"#5-3-conversions"},{"id":"5-4-initializer-list","level":2,"title":"5.4 initializer_list","anchor":"#5-4-initializer-list"},{"id":"5-5-using","level":2,"title":"5.5 using","anchor":"#5-5-using"},{"id":"standard-template-library-stl","level":0,"title":"Ⅱ Standard Template Library (STL)","anchor":"#standard-template-library-stl"},{"id":"6-containers","level":1,"title":"6 Containers","anchor":"#6-containers"},{"id":"6-1-sequence-containers","level":2,"title":"6.1 Sequence Containers","anchor":"#6-1-sequence-containers"},{"id":"6-2-container-adapters","level":2,"title":"6.2 Container Adapters","anchor":"#6-2-container-adapters"},{"id":"6-3-associative-containers","level":2,"title":"6.3 Associative Containers","anchor":"#6-3-associative-containers"},{"id":"iterators","level":2,"title":"6.4 Iterators","anchor":"#iterators"},{"id":"7-templates","level":1,"title":"7 Templates","anchor":"#7-templates"},{"id":"7-1-template-functions","level":2,"title":"7.1 Template Functions","anchor":"#7-1-template-functions"},{"id":"7-2-template-classes","level":2,"title":"7.2 Template Classes","anchor":"#7-2-template-classes"},{"id":"8-functions-and-algorithms","level":1,"title":"8 Functions and Algorithms","anchor":"#8-functions-and-algorithms"},{"id":"Lambda","level":2,"title":"8.1 Lambda Functions","anchor":"#Lambda"},{"id":"8-2-algorithms","level":2,"title":"8.2 Algorithms","anchor":"#8-2-algorithms"},{"id":"object","level":0,"title":"Ⅲ Object-Oriented Programming","anchor":"#object"},{"id":"9-classes-and-consts","level":1,"title":"9 Classes and Consts","anchor":"#9-classes-and-consts"},{"id":"9-1-classes","level":2,"title":"9.1 Classes","anchor":"#9-1-classes"},{"id":"9-2-consts","level":2,"title":"9.2 Consts","anchor":"#9-2-consts"},{"id":"10-operators","level":1,"title":"10 Operators","anchor":"#10-operators"},{"id":"10-1-basic-operators","level":2,"title":"10.1 Basic Operators","anchor":"#10-1-basic-operators"},{"id":"10-2-operator-overloading","level":2,"title":"10.2 Operator Overloading","anchor":"#10-2-operator-overloading"},{"id":"10-3-principle-of-least-astonishment-pola","level":2,"title":"10.3 Principle of Least Astonishment (POLA)","anchor":"#10-3-principle-of-least-astonishment-pola"},{"id":"10-4-interesting-operators","level":2,"title":"10.4 Interesting Operators","anchor":"#10-4-interesting-operators"},{"id":"11-special-member-functions","level":1,"title":"11 Special Member Functions","anchor":"#11-special-member-functions"},{"id":"11-1-copy-constructor-copy-assignment-operator","level":2,"title":"11.1 Copy Constructor \u0026 Copy Assignment Operator","anchor":"#11-1-copy-constructor-copy-assignment-operator"},{"id":"11-2-delete-operations","level":2,"title":"11.2 Delete Operations","anchor":"#11-2-delete-operations"},{"id":"11-3-rule-of-zero-three","level":2,"title":"11.3 Rule of Zero/Three","anchor":"#11-3-rule-of-zero-three"},{"id":"11-4-copy-elision-and-return-value-optimization-rvo","level":2,"title":"11.4 Copy Elision and Return Value Optimization (RVO)","anchor":"#11-4-copy-elision-and-return-value-optimization-rvo"},{"id":"12-move-semantics","level":1,"title":"12 Move Semantics","anchor":"#12-move-semantics"},{"id":"12-1-lvalues-rvalues","level":2,"title":"12.1 lvalues \u0026 rvalues","anchor":"#12-1-lvalues-rvalues"},{"id":"12-2-move-semantics","level":2,"title":"12.2 Move Semantics","anchor":"#12-2-move-semantics"},{"id":"inheritance","level":1,"title":"13 Inheritance","anchor":"#inheritance"},{"id":"13-1-namespace","level":2,"title":"13.1 Namespace","anchor":"#13-1-namespace"},{"id":"13-1-overriding-and-overloading","level":2,"title":"13.1 Overriding and Overloading","anchor":"#13-1-overriding-and-overloading"},{"id":"13-2-types-of-inheritance","level":2,"title":"13.2 Types of Inheritance","anchor":"#13-2-types-of-inheritance"},{"id":"modern-c","level":0,"title":"Ⅳ Modern C++","anchor":"#modern-c"},{"id":"14-raii","level":1,"title":"14 RAII","anchor":"#14-raii"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b518/app.css" rel="stylesheet"><link href="static/custom.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="Computer-Science-Study-Notes/photo.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="C++ Programming | Computer Science Study Notes"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Computer Science Study Notes Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/c-programming.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="C++ Programming | Computer Science Study Notes"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/c-programming.html#webpage",
    "url": "writerside-documentation/c-programming.html",
    "name": "C++ Programming | Computer Science Study Notes",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Computer Science Study Notes Help"
}</script><!-- End Schema.org --></head><body data-id="C-Programming" data-main-title="C++ Programming" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs=""><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Computer Science Study Notes  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="C-Programming" id="C-Programming.topic">C++ Programming</h1><section class="chapter"><h2 id="c-fundamentals" data-toc="c-fundamentals">Ⅰ C++ Fundamentals</h2><section class="chapter"><h3 id="intro" data-toc="intro">1 C &amp; C++ Introduction</h3><p id="ntmcv5_14"><span id="ntmcv5_22"><font style="color:#8a2be2">Properties:</font></span></p><ul class="list _bullet" id="ntmcv5_15"><li class="list__item" id="ntmcv5_23"><p id="ntmcv5_25">C/C++ is a <span id="ntmcv5_26"><font style="color:#ff4500">compiled</font></span> language.</p></li><li class="list__item" id="ntmcv5_24"><p id="ntmcv5_27">C/C++ <span id="ntmcv5_29"><i>compilers</i></span> map C/C++ programs into architecture-specific machine code (string of 0s and 1s).</p><ul class="list _bullet" id="ntmcv5_28"><li class="list__item" id="ntmcv5_30"><p id="ntmcv5_33">Unlike Java, which converts to architecture-independent bytecode (run by JVM =&gt; Java Virtual Machine).</p></li><li class="list__item" id="ntmcv5_31"><p id="ntmcv5_34">Unlike Python, which directly <span id="ntmcv5_35"><i>interprets</i></span> the code.</p></li><li class="list__item" id="ntmcv5_32"><p id="ntmcv5_36">Main difference is when your program is mapped to low-level machine instructions, CPU will directly interprets and runs.</p></li></ul></li></ul><p id="ntmcv5_16"><span id="ntmcv5_37"><font style="color:#8a2be2">Compilation Advantages:</font></span></p><ul class="list _bullet" id="ntmcv5_17"><li class="list__item" id="ntmcv5_38"><p id="ntmcv5_40"><span id="ntmcv5_42"><font style="color:#ff00ff">Excellent run-time performance:</font></span></p><p id="ntmcv5_41">Generally much faster than Python or Java for comparable code because it <span id="ntmcv5_43"><font style="color:#ff4500">optimizes for the given architecture</font></span>.</p></li><li class="list__item" id="ntmcv5_39"><p id="ntmcv5_44"><span id="ntmcv5_46"><font style="color:#ff00ff">Fair compilation time:</font></span></p><p id="ntmcv5_45">Enhancements in compilation procedure (Makefiles) allow us to <span id="ntmcv5_47"><font style="color:#ff4500">recompile only the modified files</font></span>.</p></li></ul><p id="ntmcv5_18"><span id="ntmcv5_48"><font style="color:#8a2be2">Compilation Disadvantages:</font></span></p><ul class="list _bullet" id="ntmcv5_19"><li class="list__item" id="ntmcv5_49"><p id="ntmcv5_51">Compiled files, including the executable, are arcitecture-specific (CPU type and OS).</p><ul class="list _bullet" id="ntmcv5_52"><li class="list__item" id="ntmcv5_53"><p id="ntmcv5_55">Executable must be <span id="ntmcv5_56"><font style="color:#ff4500">rebuilt</font></span> on each new system.</p></li><li class="list__item" id="ntmcv5_54"><p id="ntmcv5_57">i.e. &quot;porting your code&quot; to a new architecture.</p></li></ul></li><li class="list__item" id="ntmcv5_50"><p id="ntmcv5_58">Instead of &quot;Edit -&gt; Run [repeat]&quot; cycle, &quot;Edit -&gt; Compile -&gt; Run [repeat]&quot; iteration cycle can be slow.</p></li></ul><figure id="ntmcv5_20"><img alt="Compilation" src="Computer-Science-Study-Notes/c1-1.png" title="Compilation" width="4332" height="987"></figure><aside class="prompt" data-type="note" data-title="" id="ntmcv5_21"><p id="ntmcv5_59">For more information about how to compile and run the code, please refer to Computer Architecture part.</p></aside></section><section class="chapter"><h3 id="2-types-and-structs" data-toc="2-types-and-structs">2 Types and Structs</h3><section class="chapter"><h4 id="2-1-primitive-types" data-toc="2-1-primitive-types">2.1 Primitive Types</h4><div class="table-wrapper"><table class="wide" id="ntmcv5_62"><thead><tr class="ijRowHead" id="ntmcv5_63"><th id="ntmcv5_70"><p>Fundamental Types</p></th><th id="ntmcv5_71"><p>Example</p></th><th id="ntmcv5_72"><p>Memory</p></th></tr></thead><tbody><tr id="ntmcv5_64"><td id="ntmcv5_73"><p>int</p></td><td id="ntmcv5_74"><div class="code-block" data-lang="cpp">int val = 5;</div></td><td id="ntmcv5_75"><p>32 bits (usually)</p></td></tr><tr id="ntmcv5_65"><td id="ntmcv5_77"><p>char</p></td><td id="ntmcv5_78"><div class="code-block" data-lang="cpp">char ch = 'F';</div></td><td id="ntmcv5_79"><p>8 bits (usually)</p></td></tr><tr id="ntmcv5_66"><td id="ntmcv5_81"><p>float</p></td><td id="ntmcv5_82"><div class="code-block" data-lang="cpp">float decimalVal1 = 5.0;</div></td><td id="ntmcv5_83"><p>32 bits (usually)</p></td></tr><tr id="ntmcv5_67"><td id="ntmcv5_85"><p>double</p></td><td id="ntmcv5_86"><div class="code-block" data-lang="cpp">double decimalVal2 = 5.0;</div></td><td id="ntmcv5_87"><p>64 bits (usually)</p></td></tr><tr id="ntmcv5_68"><td id="ntmcv5_89"><p>bool</p></td><td id="ntmcv5_90"><div class="code-block" data-lang="cpp">bool bVal = true;</div></td><td id="ntmcv5_91"><p>1 bit</p></td></tr><tr id="ntmcv5_69"><td id="ntmcv5_93"><p>std::string</p></td><td id="ntmcv5_94"><div class="code-block" data-lang="cpp">std::string str = &quot;Haven&quot;;</div></td><td id="ntmcv5_95"><p>Depends on architecture</p></td></tr></tbody></table></div></section><section class="chapter"><h4 id="structs" data-toc="structs">2.2 Structs</h4><p id="ntmcv5_97"><span id="ntmcv5_101"><font style="color:#8a2be2">Definition:</font></span></p><p id="ntmcv5_98"><span id="ntmcv5_102"><font style="color:#ff8c00">Struct:</font></span> A <span id="ntmcv5_103"><b>struct</b></span> is a group of <span id="ntmcv5_104"><b>named variables</b></span>, each with their own type, that allows programmers to <span id="ntmcv5_105"><b>bundle different types</b></span> together!</p><p id="ntmcv5_99"><span id="ntmcv5_106"><font style="color:#8a2be2">Example:</font></span></p><div class="code-comparer" id="ntmcv5_100" data-comparing="horizontally"><div class="code-block" data-lang="cpp" data-title="C++">
                        struct Student {
                            string name; // these are called fields
                            string state; // separate these by semicolons
                            int age;
                        };
                        
                        Student s;
                        s.name = &quot;Haven&quot;;
                        s.state = &quot;AR&quot;;
                        s.age = 22; // use . to access fields
                    </div><div class="code-block" data-lang="c" data-title="C">
                        typedef struct {
                            char name[50];
                            char state[3];
                            int age;
                        } Student;
                        
                        Student s;
                        strcpy(s.name, &quot;Haven&quot;);
                        strcpy(s.state, &quot;AR&quot;);
                        s.age = 22; // use . to access fields
                    </div></div></section></section><section class="chapter"><h3 id="3-initialization-references" data-toc="3-initialization-references">3 Initialization &amp; References</h3><section class="chapter"><h4 id="3-1-initialization" data-toc="3-1-initialization">3.1 Initialization</h4><p id="ntmcv5_111">There are three types of initialization:</p><ol class="list _alpha-lower" id="ntmcv5_112" type="a"><li class="list__item" id="ntmcv5_115"><p id="ntmcv5_118"><span id="ntmcv5_120"><font style="color:#ff00ff">Direct Initialization:</font></span></p><div class="code-block" data-lang="cpp">
                            int numOne = 12.0;
                            // numOne = 12, doesn't type check with direct initialization
                        </div></li><li class="list__item" id="ntmcv5_116"><p id="ntmcv5_121"><span id="ntmcv5_123"><font style="color:#ff00ff">Uniform Initialization (C++ 11):</font></span></p><div class="code-block" data-lang="cpp">
                            int numTwo {12.0};
                            // narrowing conversion of '1.2e+1' from 'double' to 'int'
                            // type checks with uniform initialization
                        </div></li><li class="list__item" id="ntmcv5_117"><p id="ntmcv5_124"><span id="ntmcv5_126"><font style="color:#ff00ff">Structured binding (C++ 17):</font></span> Can access multiple values returned by a function.</p><div class="code-block" data-lang="cpp">
                            #include &lt;iostream&gt;
                            #include &lt;tuple&gt;
                            #include &lt;string&gt;
                            
                            std::tuple&lt;std::string, std::string, std::string&gt; getclassInfo() {
                                std::string className = &quot;CS106L&quot;;
                                std::string buildingName = &quot;Turing Auditorium&quot;;
                                std::string language = &quot;C++&quot;;
                                return {className, buildingName, language};
                            }
                            
                            int main() {
                                auto [className, buildingName, language] = getclassInfo();
                                
                                std::cout &lt;&lt; &quot;Come to &quot; &lt;&lt; buildingName &lt;&lt; &quot; and join us for &quot; &lt;&lt;
                                className &lt;&lt; &quot; to learn &quot; &lt;&lt; language &lt;&lt; &quot;!&quot; &lt;&lt; std::endl;
                                // Output: Come to Turing Auditorium and join us for CS106L to learn C++!
                            
                                return 0;
                            }
                        </div></li></ol><p id="ntmcv5_113"><span id="ntmcv5_127"><font style="color:#8a2be2">Advantages for Uniform Initialization:</font></span></p><ol class="list _decimal" id="ntmcv5_114" type="1"><li class="list__item" id="ntmcv5_128"><p id="ntmcv5_130">It's safe! It doesn't allow for narrowing conversions &mdash; which can lead to unexpected behaviour (or critical system failures)</p></li><li class="list__item" id="ntmcv5_129"><p id="ntmcv5_131">It's ubiquitous! it works for all types like vectors, maps, and custom classes, among other things!</p></li></ol></section><section class="chapter"><h4 id="3-2-references" data-toc="3-2-references">3.2 References</h4><p id="ntmcv5_132"><span id="ntmcv5_136"><font style="color:#8a2be2">Example:</font></span></p><div class="code-block" data-lang="cpp">
                    int x = 5;
                    int&amp; ref = x; // ref is a reference to x
                    ref = 10; // x is now 10
                </div><p id="ntmcv5_134"><span id="ntmcv5_137"><font style="color:#8a2be2">A classic reference-copy bug:</font></span></p><div class="code-comparer" id="ntmcv5_135" data-comparing="horizontally"><div class="code-block" data-lang="cpp" data-title="Bug">
                        // We are modifying the std::pair's inside of nums
                        void shift(std::vector&lt;std::pair&lt;int, int&amp;gtl&gt; &amp;nums) { // nums passed by reference
                            for (auto [num1, num2] : nums) { // num1 and num2 are copies
                                num1++;
                                num2++;
                            }
                        }
                    </div><div class="code-block" data-lang="cpp" data-title="Fixed">
                        // Correct Way
                        void shift(std::vector&lt;std::pair&lt;int, int&gt;&gt; &amp;nums) {
                            for (auto&amp; [num1, num2] : nums) {
                                num1++;
                                num2++;
                            }
                        }
                    </div></div></section></section><section class="chapter"><h3 id="4-streams" data-toc="4-streams">4 Streams</h3><section class="chapter"><h4 id="4-1-strings" data-toc="4-1-strings">4.1 Strings</h4><p id="ntmcv5_144">For more information on strings, please visit <a href="data-structures-and-algorithms-3.html#strings-in-java" id="ntmcv5_147" data-tooltip="Strings in Java">strings in Java</a>.</p><p id="ntmcv5_145"><span id="ntmcv5_148"><font style="color:#8a2be2">Examples in C++:</font></span></p><div class="code-block" data-lang="cpp">
                    std::string str = &quot;Hello, World!&quot;;
                    std::cout &lt;&lt; str[1] &lt;&lt; std::endl; // e
                    str[1] = 'a'; // Hallo, World!
                </div></section><section class="chapter"><h4 id="4-2-stringstreams" data-toc="4-2-stringstreams">4.2 Stringstreams</h4><ul class="list _bullet" id="ntmcv5_149"><li class="list__item" id="ntmcv5_154"><p id="ntmcv5_156">Constructors with initialtext in the buffer.</p></li><li class="list__item" id="ntmcv5_155"><p id="ntmcv5_157">Can optionally provide &quot;modes&quot; such as ate (start at end) or bin (read as binary).</p></li></ul><section class="chapter"><h5 id="4-2-1-output-stringstreams" data-toc="4-2-1-output-stringstreams">4.2.1 Output Stringstreams</h5><p id="ntmcv5_158"><span id="ntmcv5_162"><font style="color:#cd5c5c">Examples</font></span></p><div class="code-block" data-lang="cpp">
                        std::ostringstream oss(&quot;Ito-En Green Tea&quot;);
                        std::cout &lt;&lt; oss.str() &lt;&lt; std::endl; // Ito-En Green Tea
                        oss &lt;&lt; &quot;16.9 Ounces&quot;;
                        std::cout &lt;&lt; oss.str() &lt;&lt; std::endl; // 16.9 Ouncesn Tea
                        
                        std::ostringstream oss(&quot;Ito-En Green Tea&quot;, std::ostringstream::ate);
                        oss &lt;&lt; &quot;16.9 Ounces&quot;;
                        std::cout &lt;&lt; oss.str() &lt;&lt; std::endl; // Ito-En Green Tea16.9 Ounces
                    </div><p id="ntmcv5_160"><span id="ntmcv5_163"><font style="color:#8a2be2">Positioning Functions:</font></span></p><ol class="list _decimal" id="ntmcv5_161" type="1"><li class="list__item" id="ntmcv5_164"><p id="ntmcv5_166"><span id="ntmcv5_169"><font style="color:#ff00ff">tellp()</font></span></p><p id="ntmcv5_167">Returns the current position of the put pointer in the output string stream.</p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="#include &lt;iostream&gt;">
                                #include &lt;iostream&gt;
                                #include &lt;sstream&gt;
                                
                                int main() {
                                    std::ostringstream oss;
                                    oss &lt;&lt; &quot;Hello&quot;;
                                
                                    std::streampos currentPos = oss.tellp();
                                    std::cout &lt;&lt; &quot;Current put pointer position: &quot; &lt;&lt; currentPos &lt;&lt;
                                    std::endl; // Output: 5
                                
                                    oss &lt;&lt; &quot; World!&quot;;
                                    currentPos = oss.tellp();
                                    std::cout &lt;&lt; &quot;New put pointer position: &quot; &lt;&lt; currentPos &lt;&lt; std::endl;
                                    // Output: 12
                                
                                    return 0;
                                }
                            </div></li><li class="list__item" id="ntmcv5_165"><p id="ntmcv5_170"><span id="ntmcv5_174"><font style="color:#ff00ff">seekp(pos)</font></span></p><p id="ntmcv5_171">Moves the put pointer to a specific position within the output string stream.</p><p id="ntmcv5_172">The position can be an absolute offset from the beginning of the stream, or a relative offset from the current position (using std::ios::beg, std::ios::cur, or std::ios::end as a second argument).</p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="#include &lt;iostream&gt;">
                                #include &lt;iostream&gt;
                                #include &lt;sstream&gt;
                                
                                int main() {
                                    std::ostringstream oss;
                                    oss &lt;&lt; &quot;Hello World!&quot;;
                                
                                    // 1. Absolute positioning (from the beginning)
                                    oss.seekp(0); // Move to the beginning
                                    oss &lt;&lt; &quot;Hi&quot;; // Overwrite &quot;Hello&quot;
                                
                                    std::cout &lt;&lt; oss.str() &lt;&lt; std::endl; // Output: Hi World!
                                
                                    // 2. Relative positioning (from the end)
                                    oss.seekp(-2, std::ios::end); // Move 2 positions back from the end
                                    oss &lt;&lt; &quot;???&quot;; // Overwrite &quot;d!&quot;
                                
                                    std::cout &lt;&lt; oss.str() &lt;&lt; std::endl; // Output: Hi Worl???
                                
                                    // 3. Using std::ios::beg (from the beginning)
                                    oss.seekp(5, std::ios::beg); // Move 5 positions from the beginning
                                    oss &lt;&lt; &quot;-&quot;; // Insert &quot;-&quot;
                                
                                    std::cout &lt;&lt; oss.str() &lt;&lt; std::endl; // Output: Hi Worl-???
                                    
                                    // 4. Using std::ios::cur (from the current position)
                                    oss.seekp(2, std::ios::cur); // Move 2 positions forward from the current position
                                    oss &lt;&lt; &quot;+&quot;; // Insert &quot;+&quot;
                                
                                    std::cout &lt;&lt; oss.str() &lt;&lt; std::endl; // Output: Hi Worl-?+??
                                
                                    return 0;
                                }
                            </div></li></ol></section><section class="chapter"><h5 id="4-2-2-input-stringstreams" data-toc="4-2-2-input-stringstreams">4.2.2 Input Stringstreams</h5><aside class="prompt" data-type="warning" data-title="" id="ntmcv5_175"><p id="ntmcv5_181">Types matter! Stream stops reading at any whitespace or any invalid character for the type.</p></aside><p id="ntmcv5_176"><span id="ntmcv5_182"><font style="color:#cd5c5c">Examples</font></span></p><div class="code-block" data-lang="cpp">
                        std::istringstream iss(&quot;16.9 Ounces&quot;);
                        double amount;
                        std::string unit;
                        iss &gt;&gt; amount &gt;&gt; unit; // amount = 16.9, unit = Ounces
                        
                        std::istringstream iss(&quot;16.9 Ounces&quot;);
                        int amount;
                        std::string unit;
                        iss &gt;&gt; amount &gt;&gt; unit; // amount = 16, unit = &quot;.9&quot;
                    </div><p id="ntmcv5_178"><span id="ntmcv5_183"><font style="color:#8a2be2">Positioning Functions:</font></span></p><ol class="list _decimal" id="ntmcv5_179" type="1"><li class="list__item" id="ntmcv5_184"><p id="ntmcv5_186"><span id="ntmcv5_189"><font style="color:#ff00ff">tellg()</font></span></p><p id="ntmcv5_187">Returns the current position of the get pointer in the input string stream.</p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="#include &lt;iostream&gt;">
                                #include &lt;iostream&gt;
                                #include &lt;sstream&gt;
                                
                                int main() {
                                    std::istringstream iss(&quot;Hello World&quot;);
                                
                                    iss &gt;&gt; std::ws; // Skip leading whitespaces
                                
                                    std::cout &lt;&lt; &quot;Current position: &quot; &lt;&lt; iss.tellg() &lt;&lt; std::endl; // Output: 0
                                
                                    std::string word;
                                    iss &gt;&gt; word; // Read &quot;Hello&quot;
                                
                                    std::cout &lt;&lt; &quot;Current position after reading 'Hello': &quot; &lt;&lt; iss.tellg() &lt;&lt;
                                    std::endl; // Output: 5 (or 6 if there's a space after Hello)
                               
                                    return 0;
                                }
                            </div></li><li class="list__item" id="ntmcv5_185"><p id="ntmcv5_190"><span id="ntmcv5_194"><font style="color:#ff00ff">seekg(pos)</font></span></p><p id="ntmcv5_191">Moves the put pointer to a specific position within the output string stream.</p><p id="ntmcv5_192">The position can be an absolute offset from the beginning of the stream, or a relative offset from the current position (using std::ios::beg, std::ios::cur, or std::ios::end as a second argument).</p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="#include &lt;iostream&gt;">
                                #include &lt;iostream&gt;
                                #include &lt;sstream&gt;
                                
                                int main() {
                                    std::istringstream iss(&quot;Hello World&quot;);
                                
                                    // Using absolute position from the beginning
                                    iss.seekg(7); // Move to the 7th position from the beginning (equivalent to iss.seekg(7, std::ios::beg))
                                    char char1;
                                    iss.get(char1);
                                    std::cout &lt;&lt; &quot;Character read after seeking to absolute position 7: &quot; &lt;&lt;
                                    char1 &lt;&lt; std::endl; // Output: o
                                
                                    // Using ios::beg (beginning)
                                    iss.seekg(6, std::ios::beg); // Move to the 6th position from the beginning
                                    std::string word1;
                                    iss &gt;&gt; word1;
                                    std::cout &lt;&lt; &quot;Word read after seeking from beginning: &quot; &lt;&lt; word1 &lt;&lt;
                                    std::endl; // Output: World
                                
                                    // Using ios::cur (current)
                                    iss.seekg(2, std::ios::cur); // Move 2 positions forward from the current position (which is after &quot;World&quot;)
                                    char char2;
                                    iss.get(char2);
                                    std::cout &lt;&lt; &quot;Character read after seeking from current: &quot; &lt;&lt; char2 &lt;&lt;
                                    std::endl; // Output: d
                                 
                                    // Using ios::end (end)
                                    iss.seekg(-5, std::ios::end); // Move 5 positions backward from the end
                                    std::string word2;
                                    iss &gt;&gt; word2;
                                    std::cout &lt;&lt; &quot;Word read after seeking from end: &quot; &lt;&lt; word2 &lt;&lt;
                                    std::endl; // Output: World
                                    
                                    return 0;
                                }
                            </div></li></ol><aside class="prompt" data-type="tip" data-title="" id="ntmcv5_180"><p id="ntmcv5_195">Two data types:</p><ol class="list _decimal" id="ntmcv5_196" type="1"><li class="list__item" id="ntmcv5_199"><p id="ntmcv5_201"><span id="ntmcv5_202"><font style="color:#ff00ff">streampos:</font></span> Represents the position of the get pointer.</p></li><li class="list__item" id="ntmcv5_200"><p id="ntmcv5_203"><span id="ntmcv5_204"><font style="color:#ff00ff">streamoff:</font></span> Represents the difference (offset) between two streampos values.</p></li></ol><p id="ntmcv5_197"><span id="ntmcv5_205"><font style="color:#8a2be2">Example</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="#include &lt;iostream&gt;">
                            #include &lt;iostream&gt;
                            #include &lt;sstream&gt;
                            
                            int main() {
                                // Create an output string stream
                                std::ostringstream oss;
                                oss &lt;&lt; &quot;Hello, world!&quot;;
                                
                                // Get the current position using streampos
                                std::streampos pos = oss.tellp();
                                std::cout &lt;&lt; &quot;Current position in output stream: &quot; &lt;&lt; pos &lt;&lt; std::endl; // Outputs: 13
                                
                                // Move the position using streamoff
                                oss.seekp(5, std::ios::beg);
                                pos = oss.tellp();
                                std::cout &lt;&lt; &quot;New position in output stream after seekp: &quot; &lt;&lt; pos &lt;&lt;
                                std::endl; // Outputs: 5
                                
                                // Create an input string stream with the data from the output stream
                                std::istringstream iss(oss.str());
                                
                                // Get the current position using streampos
                                pos = iss.tellg();
                                std::cout &lt;&lt; &quot;Current position in input stream: &quot; &lt;&lt; pos &lt;&lt; std::endl; //
                                Outputs: 0
                                
                                // Move the position using streamoff
                                iss.seekg(7, std::ios::beg);
                                pos = iss.tellg();
                                std::cout &lt;&lt; &quot;New position in input stream after seekg: &quot; &lt;&lt; pos &lt;&lt;
                                std::endl; // Outputs: 7
                                
                                return 0;
                            }
                        </div></aside></section><section class="chapter"><h5 id="4-2-3-getline" data-toc="4-2-3-getline">4.2.3 Getline</h5><div class="code-block" data-lang="cpp">
                        std::istream&amp; getline(std::istream&amp; is, std::string&amp; str, char delim);
                    </div><ul class="list _bullet" id="ntmcv5_207"><li class="list__item" id="ntmcv5_211"><p id="ntmcv5_214"><span id="ntmcv5_215"><font style="color:#ff00ff">is:</font></span> The input stream from which to read.</p></li><li class="list__item" id="ntmcv5_212"><p id="ntmcv5_216"><span id="ntmcv5_217"><font style="color:#ff00ff">str:</font></span> The string where the read line will be stored.</p></li><li class="list__item" id="ntmcv5_213"><p id="ntmcv5_218"><span id="ntmcv5_219"><font style="color:#ff00ff">delim:</font></span> The delimiter character that specifies where to stop reading (optional, by default '\n').</p></li></ul><aside class="prompt" data-type="note" data-title="" id="ntmcv5_208"><p id="ntmcv5_220">getline() <span id="ntmcv5_221"><font style="color:#ff4500">consumes</font></span> the delim character!</p></aside><p id="ntmcv5_209"><span id="ntmcv5_222"><font style="color:#cd5c5c">Exampless</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="std::string input;">
                        std::string input;
                        std::cout &lt;&lt; &quot;Enter a line of text: &quot;;
                        std::getline(std::cin, input);
                        std::cout &lt;&lt; &quot;You entered: &quot; &lt;&lt; input &lt;&lt; std::endl;
                    </div></section><section class="chapter"><h5 id="4-2-4-state-bits" data-toc="4-2-4-state-bits">4.2.4 State Bits</h5><ol class="list _alpha-lower" id="ntmcv5_223" type="a"><li class="list__item" id="ntmcv5_227"><p id="ntmcv5_231"><span id="ntmcv5_232"><font style="color:#ff00ff">Good bit</font></span> - ready for read /write. (Nothing unusal, on when other bits are off)</p></li><li class="list__item" id="ntmcv5_228"><p id="ntmcv5_233"><span id="ntmcv5_234"><font style="color:#ff00ff">Fail bit</font></span> - previous operation failed, all future operations frozen. (Type mismatch, file can't be opened, seekg failed)</p></li><li class="list__item" id="ntmcv5_229"><p id="ntmcv5_235"><span id="ntmcv5_236"><font style="color:#ff00ff">EOF bit</font></span> - previous operation reached the end of buffer content (reached the end of buffer).</p></li><li class="list__item" id="ntmcv5_230"><p id="ntmcv5_237"><span id="ntmcv5_238"><font style="color:#ff00ff">Bad bit</font></span> - external error, like irrecoverable.(e.g. the file you are reading from suddenly is deleted)</p></li></ol><aside class="prompt" data-type="note" data-title="" id="ntmcv5_224"><p id="ntmcv5_239">Good and bad are not opposites! (e.g. type mismatch)</p><p id="ntmcv5_240">Good and fail are not opposites! (e.g. end of file)</p><p id="ntmcv5_241">Fail and EOF are normally the ones you will be checking.</p></aside><p id="ntmcv5_225"><span id="ntmcv5_242"><font style="color:#cd5c5c">Examples</font></span></p><div class="code-block" data-lang="cpp">
                        std::istringstream iss(&quot;17&quot;);
                        int amount;
                        iss &gt;&gt; amount;
                        std::cout &lt;&lt; (iss.eof() ? &quot;EOF&quot; : &quot;Not EOF&quot;) &lt;&lt; std::endl;
                        // There also exist iss.good(), iss.fail() &amp; iss.bad()
                    </div></section></section><section class="chapter"><h4 id="4-3-input-streams" data-toc="4-3-input-streams">4.3 Input Streams</h4><p id="ntmcv5_243"><span id="ntmcv5_250"><font style="color:#8a2be2">There are four standard iostreams</font></span></p><ul class="list _bullet" id="ntmcv5_244"><li class="list__item" id="ntmcv5_251"><p id="ntmcv5_255"><span id="ntmcv5_256"><font style="color:#ff00ff">cout:</font></span> Standard Output Stream .</p></li><li class="list__item" id="ntmcv5_252"><p id="ntmcv5_257"><span id="ntmcv5_258"><font style="color:#ff00ff">cin:</font></span> Standard Input Stream (buffered).</p></li><li class="list__item" id="ntmcv5_253"><p id="ntmcv5_259"><span id="ntmcv5_260"><font style="color:#ff00ff">cerr (Standard Error Stream):</font></span> used to output errors (unbuffered).</p></li><li class="list__item" id="ntmcv5_254"><p id="ntmcv5_261"><span id="ntmcv5_262"><font style="color:#ff00ff">clog (Standard Logging Stream):</font></span> used for non-critical event logging (buffered).</p></li></ul><p id="ntmcv5_245"><span id="ntmcv5_263"><font style="color:#8a2be2">cin</font></span></p><ul class="list _bullet" id="ntmcv5_246"><li class="list__item" id="ntmcv5_264"><p id="ntmcv5_267">The program hangs and waits for user input when the position reaches EOF, past the last token in the buffer.</p></li><li class="list__item" id="ntmcv5_265"><p id="ntmcv5_268">The position pointer skips whitespace <span id="ntmcv5_269"><font style="color:#ff4500">after</font></span> the token with each &gt;&gt; operation.</p></li><li class="list__item" id="ntmcv5_266"><p id="ntmcv5_270">The position pointer does the following:</p><ul class="list _bullet" id="ntmcv5_271"><li class="list__item" id="ntmcv5_272"><p id="ntmcv5_274">consume all whitespaces (spaces, newlines, '\t', '\n', etc .)</p></li><li class="list__item" id="ntmcv5_273"><p id="ntmcv5_275">reads as many characters until:</p><ul class="list _bullet" id="ntmcv5_276"><li class="list__item" id="ntmcv5_277"><p id="ntmcv5_280">a whitespace is reached, or...</p></li><li class="list__item" id="ntmcv5_278"><p id="ntmcv5_281">for primitives, the maximum number of bytes necessary to form a valid variable.</p></li><li class="list__item" id="ntmcv5_279"><p id="ntmcv5_282">Example: if we extract an int from &quot;86.2&quot;, we'll get 86, with pos at the decimal point.</p></li></ul></li></ul></li></ul><p id="ntmcv5_247"><span id="ntmcv5_283"><font style="color:#cd5c5c">Examples</font></span></p><div class="code-comparer" id="ntmcv5_248" data-comparing="horizontally"><div class="code-block" data-lang="cpp" data-title="Example 1">
                        #include &lt;iostream&gt;
                        #include &lt;string&gt;
                        
                        int main() {
                            double pi, r;
                            std::string name;
                            std::cin &gt;&gt; pi;
                            std::cin.ignore(); // ignore the newline character
                            std::getline(std::cin, name);
                            std::cin &gt;&gt; r;
                            std::cout &lt;&lt; &quot;Hello, &quot; &lt;&lt; name &lt;&lt; &quot;!&quot; &lt;&lt; std::endl;
                            std::cout &lt;&lt; &quot;Value of pi: &quot; &lt;&lt; pi &lt;&lt; std::endl;
                            std::cout &lt;&lt; &quot;Value of r: &quot; &lt;&lt; r &lt;&lt; std::endl;
                            return 0;
                        }
                    </div><div class="code-block" data-lang="cpp" data-title="Example 2">
                        #include &lt;iostream&gt;
                        #include &lt;string&gt;
                        
                        int main() {
                            double pi, r;
                            std::string name;
                            std::cin &gt;&gt; pi;
                            std::getline(std::cin, name); // read '\n' from previous input
                            std::getline(std::cin, name); // read name
                            std::cin &gt;&gt; r;
                            std::cout &lt;&lt; &quot;Hello, &quot; &lt;&lt; name &lt;&lt; &quot;!&quot; &lt;&lt; std::endl;
                            std::cout &lt;&lt; &quot;Value of pi: &quot; &lt;&lt; pi &lt;&lt; std::endl;
                            std::cout &lt;&lt; &quot;Value of r: &quot; &lt;&lt; r &lt;&lt; std::endl;
                            return 0;
                        }
                    </div></div><aside class="prompt" data-type="warning" data-title="" id="ntmcv5_249"><p id="ntmcv5_286">Don&rsquo;t use getline() and std::cin() together, unless you really really have to!</p></aside></section><section class="chapter"><h4 id="4-4-output-streams" data-toc="4-4-output-streams">4.4 Output Streams</h4><p id="ntmcv5_287"><span id="ntmcv5_293"><font style="color:#8a2be2">cerr &amp; clog</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="#include &lt;iostream&gt;">
                    #include &lt;iostream&gt;
                    
                    int main() {
                        std::cerr &lt;&lt; &quot;Error: Could not open the file!&quot; &lt;&lt; std::endl;

                        std::clog &lt;&lt; &quot;Log: User logged in successfully.&quot; &lt;&lt; std::endl;

                        return 0;
                    }
                </div><p id="ntmcv5_289"><span id="ntmcv5_294"><font style="color:#8a2be2">Input File Streams &amp; Output File Streams</font></span></p><div class="table-wrapper"><table class="left_header wide" id="ntmcv5_290"><thead><tr class="ijRowHead" id="ntmcv5_295"><th id="ntmcv5_301"></th><th id="ntmcv5_302"><p>ifstream</p></th><th id="ntmcv5_303"><p>ofstream</p></th></tr></thead><tbody><tr id="ntmcv5_296"><th id="ntmcv5_304"><p>Purpose</p></th><td id="ntmcv5_305"><p>Input from a file</p></td><td id="ntmcv5_306"><p>Output to a file</p></td></tr><tr id="ntmcv5_297"><th id="ntmcv5_307"><p>Mode</p></th><td id="ntmcv5_308"><p>Opens a file in read mode</p></td><td id="ntmcv5_309"><p>Opens a file in write mode</p></td></tr><tr id="ntmcv5_298"><th id="ntmcv5_310"><p>Default behavior</p></th><td id="ntmcv5_311"><p>If the file doesn't exist, it fails to open.</p></td><td id="ntmcv5_312"><p>If the file doesn't exist, it creates a new one. If it exists, it overwrites the content by default.</p></td></tr><tr id="ntmcv5_299"><th id="ntmcv5_313"><p>Operators</p></th><td id="ntmcv5_314"><p>Primarily used with the extraction operator (&gt;&gt;) to read data from the file.</p></td><td id="ntmcv5_315"><p>Primarily used with the insertion operator (&lt;&lt;) to write data to the file.</p></td></tr><tr id="ntmcv5_300"><th id="ntmcv5_316"><p>Similarities</p></th><td id="ntmcv5_317" colspan="2"><ol class="list _alpha-lower" id="ntmcv5_318" type="a"><li class="list__item" id="ntmcv5_319"><p id="ntmcv5_321">They share many common methods like open(), close(), is_open() , good(), bad(), fail(), eof(), etc. for managing the file stream .</p></li><li class="list__item" id="ntmcv5_320"><p id="ntmcv5_322">Both inherit properties and methods from the base class fstream .</p></li></ol></td></tr></tbody></table></div><p id="ntmcv5_291"><span id="ntmcv5_323"><font style="color:#8a2be2">Example:</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="#include &lt;iostream&gt;">
                    #include &lt;iostream&gt;
                    #include &lt;fstream&gt;
                    
                    int main() {
                        // ifstream for reading from a file
                        std::ifstream inputFile(&quot;myInput.txt&quot;);

                        if (inputFile.is_open()) {
                            std::string line;
                            while (std::getline(inputFile, line)) {
                                std::cout &lt;&lt; line &lt;&lt; std::endl;
                            }
                            inputFile.close();
                        } else {
                            std::cerr &lt;&lt; &quot;Unable to open input file.&quot; &lt;&lt; std::endl;
                        }

                        // ofstream for writing to a file
                        std::ofstream outputFile(&quot;myOutput.txt&quot;);

                        if (outputFile.is_open()) {
                            outputFile &lt;&lt; &quot;This is some text for the output file.&quot; &lt;&lt; std::endl;
                            outputFile.close();
                        } else {
                            std::cerr &lt;&lt; &quot;Unable to open output file.&quot; &lt;&lt; std::endl;
                        }
                    
                        return 0;
                    }
                </div></section></section><section class="chapter"><h3 id="5-modern-c-types" data-toc="5-modern-c-types">5 Modern C++ Types</h3><section class="chapter"><h4 id="5-1-auto" data-toc="5-1-auto">5.1 Auto</h4><ul class="list _bullet" id="ntmcv5_329"><li class="list__item" id="ntmcv5_331"><p id="ntmcv5_333">When a type name is too long and a simpler alias makes the code more readable, use it.</p></li><li class="list__item" id="ntmcv5_332"><p id="ntmcv5_334">In libraries there is a common name for a type within each class. Example:</p><ul class="list _bullet" id="ntmcv5_335"><li class="list__item" id="ntmcv5_336"><p id="ntmcv5_338">vector::iterator, map::iterator, string::iterator</p></li><li class="list__item" id="ntmcv5_337"><p id="ntmcv5_339">vector::reference, map::reference, string::reference</p></li></ul></li></ul><aside class="prompt" data-type="warning" data-title="" id="ntmcv5_330"><p id="ntmcv5_340">Auto discards const and references!</p></aside></section><section class="chapter"><h4 id="5-2-pair-tuple" data-toc="5-2-pair-tuple">5.2 Pair/Tuple</h4><p id="ntmcv5_341">A pair is simply two objects bundled together.</p><aside class="prompt" data-type="note" data-title="" id="ntmcv5_342"><p id="ntmcv5_345">Remember to include &lt; utility &gt; and &lt; tuple &gt;</p></aside><p id="ntmcv5_343"><span id="ntmcv5_346"><font style="color:#cd5c5c">Examples</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="std::pair&lt;double, int&gt; price(3.4, 5);">
                    std::pair&lt;double, int&gt; price(3.4, 5);
                    
                    // make_pair/tuple (C++ 11) automatically deduces the type!
                    auto prices = std::make_pair(3.4, 5);
                    auto values = std::make_tuple(3, 4, &quot;hi&quot;);
                    
                    // access via get/set
                    prices.first = prices.second; // prices = {5, 5}
                    get&lt;0&gt;(values) = get&lt;1&gt;(values); // values = {4, 4, &quot;hi&quot;}
                    
                    // structured binding (C++ 17) - extract each binding
                    auto [a, b] = prices; // a = 5, b = 5
                    const auto&amp; [c, d, e] = values; // c = 4, d = 4, e = &quot;hi&quot;
                </div></section><section class="chapter"><h4 id="5-3-conversions" data-toc="5-3-conversions">5.3 Conversions</h4><p id="ntmcv5_347"><span id="ntmcv5_350"><font style="color:#cd5c5c">Exampless</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="int v1 = static_cast&lt;double&gt;(3.14); // v1 = 3">
                    int v1 = static_cast&lt;double&gt;(3.14); // v1 = 3
                </div><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="const int v3 = 3;">
                    const int v3 = 3;
                    int* v4 = const_cast&lt;int*&gt; (&amp;v3); // v4 = 3
                </div></section><section class="chapter"><h4 id="5-4-initializer-list" data-toc="5-4-initializer-list">5.4 initializer_list</h4><p id="ntmcv5_351"><span id="ntmcv5_356"><font style="color:#8a2be2">Definition</font></span>: An initializer list is a lightweight vector that can be used as a parameter.</p><p id="ntmcv5_352"><span id="ntmcv5_357"><font style="color:#8a2be2">Example:</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="#include &lt;iostream&gt;">
                    #include &lt;iostream&gt;
                    #include &lt;vector&gt;
                    #include &lt;initializer_list&gt;
                    
                    class MyContainer {
                    private:
                        std::vector&lt;int&gt; data;
                    
                    public:
                        // Constructor using initializer_list
                        MyContainer(std::initializer_list&lt;int&gt; values) {
                        // Iterate through the initializer_list and populate the vector
                            for (int value : values) {
                                data.push_back(value);
                            }
                        }

                        void print() const {
                            for (int value : data) {
                                std::cout &lt;&lt; value &lt;&lt; &quot; &quot;;
                            }
                            std::cout &lt;&lt; std::endl;
                        }
                        };
                    
                    int main() {
                        // Using initializer_list to initialize MyContainer
                        MyContainer container1 = {1, 2, 3, 4, 5};
                        container1.print();

                        MyContainer container2{6, 7, 8};
                        container2.print();

                        return 0;
                    }
                </div><aside class="prompt" data-type="warning" data-title="" id="ntmcv5_354"><p id="ntmcv5_358">C++ 11 provides a uniform initialization syntax. Using the uniform initialization syntax, the initializer list constructor is preferred over constructor.</p></aside><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="std::vector&lt;int&gt; v1(3, 10) // v1 = {10, 10, 10}">
                    std::vector&lt;int&gt; v1(3, 10) // v1 = {10, 10, 10}
                    std::vector&lt;int&gt; v2{3, 10} // v2 = {3, 10}
                </div></section><section class="chapter"><h4 id="5-5-using" data-toc="5-5-using">5.5 using</h4><p id="ntmcv5_359">Create type aliases with the using keyword.</p><div class="code-comparer" id="ntmcv5_360" data-comparing="horizontally"><div class="code-block" data-lang="cpp" data-title="Types">
                        std::pair&lt;bool, std::pair&lt;double, double&gt;&gt;;
                    </div><div class="code-block" data-lang="cpp" data-title="Using keyword">
                        using Zeros = std::pair&lt;double, double&gt;;
                        using Solution = std::pair&lt;bool, Zeros&gt;;
                    </div></div></section></section></section><section class="chapter"><h2 id="standard-template-library-stl" data-toc="standard-template-library-stl">Ⅱ Standard Template Library (STL)</h2><p id="ntmcv5_364">The <span id="ntmcv5_370"><font style="color:#ff8c00">Standard Template Library (STL)</font></span> is a software library originally designed by Alexander Stepanov for the C++ programming language that influenced many parts of the C++ Standard Library. It provides four components called algorithms, containers, functions, and iterators.</p><p id="ntmcv5_365">The <span id="ntmcv5_371"><font style="color:#ff8c00">C++ Standard Library</font></span> is a collection of classes and functions, which are written in the core language and part of the C++ ISO Standard itself.</p><aside class="prompt" data-type="note" data-title="" id="ntmcv5_366"><p id="ntmcv5_372">The STL and the C++ Standard Library are two distinct entities.</p><p id="ntmcv5_373">However, due to the popular use of &quot;STL&quot; and &quot;Standard Template Library&quot; in search engines, we occasionally use those names to make it easier to find our documentation.</p><p id="ntmcv5_374">In this documentation, Standard Template Library (STL) refers to the C++ Standard Library as a whole.</p></aside><section class="chapter"><h3 id="6-containers" data-toc="6-containers">6 Containers</h3><section class="chapter"><h4 id="6-1-sequence-containers" data-toc="6-1-sequence-containers">6.1 Sequence Containers</h4><p id="ntmcv5_379"><span id="ntmcv5_383"><font style="color:#ff8c00">Sequence Containers:</font></span> Containers which provide access to a linear sequence of elements.</p><ul class="list _bullet" id="ntmcv5_380"><li class="list__item" id="ntmcv5_384"><p id="ntmcv5_389"><code class="code" id="ntmcv5_390">std::vector&lt;T&gt;</code></p></li><li class="list__item" id="ntmcv5_385"><p id="ntmcv5_391"><code class="code" id="ntmcv5_392">std::deque&lt;T&gt;</code></p></li><li class="list__item" id="ntmcv5_386"><p id="ntmcv5_393"><code class="code" id="ntmcv5_394">std::array&lt;T&gt;</code></p></li><li class="list__item" id="ntmcv5_387"><p id="ntmcv5_395"><code class="code" id="ntmcv5_396">std::list&lt;T&gt;</code></p></li><li class="list__item" id="ntmcv5_388"><p id="ntmcv5_397"><code class="code" id="ntmcv5_398">std::forward_list&lt;T&gt;</code></p></li></ul><section class="chapter"><h5 id="6-1-1-vector" data-toc="6-1-1-vector">6.1.1 Vector</h5><p id="ntmcv5_399"><span id="ntmcv5_408"><font style="color:#ff8c00">Vector:</font></span> An array with changeable size.</p><p id="ntmcv5_400"><span id="ntmcv5_409"><font style="color:#cd5c5c">Example</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="#include &lt;iostream&gt;">
                        #include &lt;iostream&gt;
                        #include &lt;vector&gt;
                        
                        int main() {
                            std::vector&lt;int&gt; vec; // Create an empty vector
                            std::vector&lt;int&gt; vec2(5); // Create a vector with 5 copies of 0
                            std::vector&lt;int&gt; vec3{5, 1}; // Create a vector with 5 copies of value 1

                            vec.push_back(1); // Add 1 to the end of the vector
                            vec.clear(); // Clear vector

                            if (vec.empty()) { // Check if vector is empty
                                std::cout &lt;&lt; &quot;Vector is empty&quot; &lt;&lt; std::endl;
                            }

                            int k = vec2[0]; // Get the element of index 0
                            int l = vec2.at(0); // Get the element of index 0
                            vec2.at(0) = 2; // Replace the element at index 0
                            vec2[0] = 2; // Replace the element at index 0
                            return 0;
                        }
                    </div><div class="table-wrapper"><table class="left_header wide" id="ntmcv5_402"><thead><tr class="ijRowHead" id="ntmcv5_410"><th id="ntmcv5_413"></th><th id="ntmcv5_414"><p><code class="code" id="ntmcv5_416">vec[index]</code></p></th><th id="ntmcv5_415"><p><code class="code" id="ntmcv5_417">vec.at(index)</code></p></th></tr></thead><tbody><tr id="ntmcv5_411"><th id="ntmcv5_418"><p>Bounds Checking</p></th><td id="ntmcv5_419"><p>No</p></td><td id="ntmcv5_420"><p>Yes</p></td></tr><tr id="ntmcv5_412"><th id="ntmcv5_421"><p>Speed</p></th><td id="ntmcv5_422"><p>Fast</p></td><td id="ntmcv5_423"><p>Slow</p></td></tr></tbody></table></div><aside class="prompt" data-type="warning" data-title="" id="ntmcv5_403"><p id="ntmcv5_424">If you write your program <span id="ntmcv5_426"><font style="color:#adff2f">correctly</font></span>, bounds checking will just <span id="ntmcv5_427"><font style="color:#ff4500">slow</font></span> you down.</p><p id="ntmcv5_425">Use range-based for &amp; <code class="code" id="ntmcv5_428">const auto&amp;</code> when possible.</p></aside><p id="ntmcv5_404"><span id="ntmcv5_429"><font style="color:#8a2be2">Advantages:</font></span></p><ul class="list _bullet" id="ntmcv5_405"><li class="list__item" id="ntmcv5_430"><p id="ntmcv5_432">Fast, lightweight &amp; intuitive.</p></li><li class="list__item" id="ntmcv5_431"><p id="ntmcv5_433">Grow efficiently <span id="ntmcv5_434"><font style="color:#adff2f">in one direction</font></span>.</p></li></ul><p id="ntmcv5_406"><span id="ntmcv5_435"><font style="color:#8a2be2">Disadvantages:</font></span></p><ul class="list _bullet" id="ntmcv5_407"><li class="list__item" id="ntmcv5_436"><p id="ntmcv5_437">cannot <code class="code" id="ntmcv5_438">push_front</code>!</p></li></ul></section><section class="chapter"><h5 id="6-1-2-deque" data-toc="6-1-2-deque">6.1.2 Deque</h5><p id="ntmcv5_439"><span id="ntmcv5_448"><font style="color:#ff8c00">Deque:</font></span> A deque is a doubly ended queue.</p><p id="ntmcv5_440"><span id="ntmcv5_449"><font style="color:#8a2be2">Implementation</font></span></p><p id="ntmcv5_441">Instead of storing all elements in a single contiguous block, deque internally manages a collection of fixed-size arrays called &quot;chunks&quot; or &quot;buffers.&quot; =&gt; separate subarrays and allocated independently.</p><p id="ntmcv5_442">Deque maintains a dynamic array (usually a small array or a tree-like structure) called a &quot;map&quot; or &quot;central index&quot;. This map stores pointers to the beginning of each chunk.</p><figure id="ntmcv5_443"><img alt="Deque Implementation" src="Computer-Science-Study-Notes/c6-1.png" title="Deque Implementation" width="6932" height="1486"></figure><p id="ntmcv5_444"><span id="ntmcv5_450"><font style="color:#8a2be2">Advantages:</font></span></p><ul class="list _bullet" id="ntmcv5_445"><li class="list__item" id="ntmcv5_451"><p id="ntmcv5_452">Can <code class="code" id="ntmcv5_453">push_front</code>!</p></li></ul><p id="ntmcv5_446"><span id="ntmcv5_454"><font style="color:#8a2be2">Disadvantages:</font></span></p><ul class="list _bullet" id="ntmcv5_447"><li class="list__item" id="ntmcv5_455"><p id="ntmcv5_456">For other operations, vector outperform deque.</p></li></ul></section></section><section class="chapter"><h4 id="6-2-container-adapters" data-toc="6-2-container-adapters">6.2 Container Adapters</h4><ol class="list _alpha-lower" id="ntmcv5_457" type="a"><li class="list__item" id="ntmcv5_458"><p id="ntmcv5_460"><span id="ntmcv5_462"><font style="color:#ff00ff">Stacks:</font></span></p><ul class="list _bullet" id="ntmcv5_461"><li class="list__item" id="ntmcv5_463"><p id="ntmcv5_465">Just limit the functionality of a vector/deque to only allow <code class="code" id="ntmcv5_466">push_back</code> and <code class="code" id="ntmcv5_467">pop_back</code>.</p></li><li class="list__item" id="ntmcv5_464"><p id="ntmcv5_468">The standard containers <code class="code" id="ntmcv5_469">std::vector</code> (including <code class="code" id="ntmcv5_470">std::vector&lt;bool&gt;</code>), <code class="code" id="ntmcv5_471">std::deque</code> and <code class="code" id="ntmcv5_472">std::list</code> satisfy these requirements. By default, if no container class is specified for a particular stack class instantiation, the standard container <code class="code" id="ntmcv5_473">std::deque</code> is used.</p></li></ul></li><li class="list__item" id="ntmcv5_459"><p id="ntmcv5_474"><span id="ntmcv5_476"><font style="color:#ff00ff">Queues:</font></span></p><ul class="list _bullet" id="ntmcv5_475"><li class="list__item" id="ntmcv5_477"><p id="ntmcv5_479">The standard containers <code class="code" id="ntmcv5_480">std::deque</code> and <code class="code" id="ntmcv5_481">std::list</code> satisfy these requirements.</p></li><li class="list__item" id="ntmcv5_478"><p id="ntmcv5_482">Just limit the functionality of a deque to only allow <code class="code" id="ntmcv5_483">push_back</code> and <code class="code" id="ntmcv5_484">pop_front</code>.</p></li></ul></li></ol></section><section class="chapter"><h4 id="6-3-associative-containers" data-toc="6-3-associative-containers">6.3 Associative Containers</h4><p id="ntmcv5_485"><span id="ntmcv5_489"><font style="color:#ff8c00">Associative containers:</font></span> Data is accessed using the <span id="ntmcv5_490"><font style="color:#ff4500">key</font></span> instead of index.</p><style>.theme-dark .plantuml > svg {filter: hue-rotate(180deg) invert(0.9);}div.plantuml {overflow-x: auto;}</style><div class="plantuml"><?xml version="1.0" encoding="us-ascii" standalone="no"?><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" height="256px" preserveAspectRatio="none" style="width:770px;height:256px;background:#FFFFFF;" version="1.1" viewBox="0 0 770 256" width="770px" zoomAndPan="magnify"><defs/><g><rect fill="#F1F1F1" height="38.6211" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:1.5;" width="125" x="10" y="107.9316"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="105" x="20" y="133.0391">Class Templates</text><rect fill="#F1F1F1" height="57.2422" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:1.5;" width="309" x="185" y="40"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="223" x="199" y="65.1074">Based on ordering property of keys</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="289" x="195" y="83.7285">Keys need to be comparable using &lt; operator</text><rect fill="#F1F1F1" height="38.6211" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:1.5;" width="132" x="544" y="20"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="112" x="554" y="45.1074">std::map&lt;T1, T2&gt;</text><path d="M494,68.6211 L504,68.6211 C519,68.6211 519,39.3105 534,39.3105 L544,39.3105 " fill="none" style="stroke:#181818;stroke-width:1.0;"/><rect fill="#F1F1F1" height="38.6211" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:1.5;" width="91" x="544" y="78.6211"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="71" x="554" y="103.7285">std::set&lt;T&gt;</text><path d="M494,68.6211 L504,68.6211 C519,68.6211 519,97.9316 534,97.9316 L544,97.9316 " fill="none" style="stroke:#181818;stroke-width:1.0;"/><path d="M135,127.2422 L145,127.2422 C160,127.2422 160,68.6211 175,68.6211 L185,68.6211 " fill="none" style="stroke:#181818;stroke-width:1.0;"/><rect fill="#F1F1F1" height="57.2422" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:1.5;" width="317" x="185" y="157.2422"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="149" x="199" y="182.3496">Based on hash function</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="297" x="195" y="200.9707">You need to define how the key can be hashed</text><rect fill="#F1F1F1" height="38.6211" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:1.5;" width="206" x="552" y="137.2422"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="186" x="562" y="162.3496">std::unordered_map&lt;T1, T2&gt;</text><path d="M502,185.8633 L512,185.8633 C527,185.8633 527,156.5527 542,156.5527 L552,156.5527 " fill="none" style="stroke:#181818;stroke-width:1.0;"/><rect fill="#F1F1F1" height="38.6211" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:1.5;" width="165" x="552" y="195.8633"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="145" x="562" y="220.9707">std::unordered_set&lt;T&gt;</text><path d="M502,185.8633 L512,185.8633 C527,185.8633 527,215.1738 542,215.1738 L552,215.1738 " fill="none" style="stroke:#181818;stroke-width:1.0;"/><path d="M135,127.2422 L145,127.2422 C160,127.2422 160,185.8633 175,185.8633 L185,185.8633 " fill="none" style="stroke:#181818;stroke-width:1.0;"/><!--SRC=[RP11Jm8n48Nl_HNl24ICh6Xq9SQ8aeWYHXOIJwPi1xPnjzsqKmp-Uhi6HHClFSpCU-_hk_8i7LVQg4hMeeDXARr7HbLTIYOlEfqKrzAJWZMmJf7JPetQsPeSRs5NUAEj5_VnWQ5unXPBGcwhMZgvB0d1Due16eLawowYPmUULPh6o47MEq2MNEw7ddYGNVuDBgGli0ecPssDUB7X9qlHIXj2OT_11JKmoALf41eDgLzfmNpnathzDtU_tX5SKInbLunuAgNX-UG16t8-Gg1tc1mbnuUzf3Lo6jESaHmXwQNzy_IaZ-4iGxDlYzRaBeEtmUK4fJqxlGpDBzfYB3SIpy6mhYZ5j2Oplhd_7k3MRBIpfYB3OhoOx0zE-zrhpPYHYoXOJCGDhMGeEIfogsBNAURPg7ic7gHP1xcEtX-56DhewxOfXe-V]--></g></svg></div><aside class="prompt" data-type="warning" data-title="" id="ntmcv5_487"><p id="ntmcv5_491"><code class="code" id="ntmcv5_492">std::map&lt;K, V&gt;</code> stores <code class="code" id="ntmcv5_493">std::pair&lt;const K, V&gt;</code></p></aside><aside class="prompt" data-type="tip" data-title="" id="ntmcv5_488"><p id="ntmcv5_494">For more information on the implementation of these assocative adaptators, please visit <a href="data-structures-and-algorithms-1.html" id="ntmcv5_495" data-tooltip="Data Structures and Algorithms">Data Structures and Algorithms</a> for more!</p></aside></section><section class="chapter"><h4 id="iterators" data-toc="iterators">6.4 Iterators</h4><p id="ntmcv5_496"><span id="ntmcv5_506"><font style="color:#8a2be2">Four iterator operations:</font></span></p><ul class="list _bullet" id="ntmcv5_497"><li class="list__item" id="ntmcv5_507"><p id="ntmcv5_511"><span id="ntmcv5_513"><font style="color:#ff00ff">Create iterator:</font></span></p><p id="ntmcv5_512"><code class="code" id="ntmcv5_514">std::set&lt;int&gt;::iterator iter = mySet.begin()</code></p></li><li class="list__item" id="ntmcv5_508"><p id="ntmcv5_515"><span id="ntmcv5_517"><font style="color:#ff00ff">Dereference iterator to read value currently pointed to:</font></span></p><p id="ntmcv5_516"><code class="code" id="ntmcv5_518">int val = *iter</code></p></li><li class="list__item" id="ntmcv5_509"><p id="ntmcv5_519"><span id="ntmcv5_521"><font style="color:#ff00ff">Advance iterator:</font></span></p><p id="ntmcv5_520"><code class="code" id="ntmcv5_522">iter++</code>; or <code class="code" id="ntmcv5_523">++iter</code></p></li><li class="list__item" id="ntmcv5_510"><p id="ntmcv5_524"><span id="ntmcv5_525"><font style="color:#ff00ff">Compare against another iterator</font></span> (especially <code class="code" id="ntmcv5_526">.end()</code> iterator)</p></li></ul><p id="ntmcv5_498"><span id="ntmcv5_527"><font style="color:#8a2be2">Map Iterators:</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="std::map&lt;int, int&gt; m;">
                    std::map&lt;int, int&gt; m;
                    std::map&lt;int, int&gt;::iterator i = m.begin();
                    std::map&lt;int, int&gt;::iterator end = m.end();
                    while (i != end) {
                        std::cout &lt;&lt; (*i).first &lt;&lt; &quot; &quot; &lt;&lt; (*i).second &lt;&lt; std::endl;
                        i++;
                    }
                </div><svg aria-roledescription="stateDiagram" role="graphics-document document" viewBox="0 0 543.390625 146" style="max-width: 543.390625px;" class="statediagram" xmlns="http://www.w3.org/2000/svg" width="100%" id="mermaid"><g><defs><marker orient="auto" markerUnits="userSpaceOnUse" markerHeight="14" markerWidth="20" refY="7" refX="19" id="mermaid_stateDiagram-barbEnd"><path d="M 19,7 L9,13 L14,7 L9,1 Z"></path></marker></defs><g class="root"><g class="clusters"></g><g class="edgePaths"><path marker-end="url(#mermaid_stateDiagram-barbEnd)" style=";fill:none" class="edge-thickness-normal edge-pattern-solid transition" id="edge0" d="M136.906,73L141.073,73C145.24,73,153.573,73,159.823,73C166.073,73,170.24,73,174.406,73C178.573,73,182.74,73,184.823,73L186.906,73"></path><path marker-end="url(#mermaid_stateDiagram-barbEnd)" style=";fill:none" class="edge-thickness-normal edge-pattern-solid transition" id="edge1" d="M294.547,73L298.714,73C302.88,73,311.214,73,317.464,73C323.714,73,327.88,73,332.047,73C336.214,73,340.38,73,342.464,73L344.547,73"></path><path marker-end="url(#mermaid_stateDiagram-barbEnd)" style=";fill:none" class="edge-thickness-normal edge-pattern-solid transition" id="edge2" d="M409.701,53L415.48,48.833C421.259,44.667,432.817,36.333,441.208,32.167C449.599,28,454.823,28,460.047,28C465.271,28,470.495,28,473.107,28L475.719,28"></path><path marker-end="url(#mermaid_stateDiagram-barbEnd)" style=";fill:none" class="edge-thickness-normal edge-pattern-solid transition" id="edge3" d="M409.701,93L415.48,97.167C421.259,101.333,432.817,109.667,440.679,113.833C448.542,118,452.708,118,456.875,118C461.042,118,465.208,118,467.292,118L469.375,118"></path></g><g class="edgeLabels"><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g></g><g class="nodes"><g transform="translate(72.453125, 73)" id="state-Random_Access-0" class="node  statediagram-state"><rect height="40" width="128.90625" y="-20" x="-64.453125" ry="5" data-et="node" data-id="abc" rx="5" style="" class="basic label-container"></rect><g transform="translate(-56.453125, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="112.90625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Random_Access</p></span></div></foreignObject></g></g><g transform="translate(240.7265625, 73)" id="state-Bidirectional-1" class="node  statediagram-state"><rect height="40" width="107.640625" y="-20" x="-53.8203125" ry="5" data-et="node" data-id="abc" rx="5" style="" class="basic label-container"></rect><g transform="translate(-45.8203125, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="91.640625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Bidirectional</p></span></div></foreignObject></g></g><g transform="translate(381.9609375, 73)" id="state-Forward-3" class="node  statediagram-state"><rect height="40" width="74.828125" y="-20" x="-37.4140625" ry="5" data-et="node" data-id="abc" rx="5" style="" class="basic label-container"></rect><g transform="translate(-29.4140625, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="58.828125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Forward</p></span></div></foreignObject></g></g><g transform="translate(502.3828125, 28)" id="state-Input-2" class="node  statediagram-state"><rect height="40" width="53.328125" y="-20" x="-26.6640625" ry="5" data-et="node" data-id="abc" rx="5" style="" class="basic label-container"></rect><g transform="translate(-18.6640625, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="37.328125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Input</p></span></div></foreignObject></g></g><g transform="translate(502.3828125, 118)" id="state-Output-3" class="node  statediagram-state"><rect height="40" width="66.015625" y="-20" x="-33.0078125" ry="5" data-et="node" data-id="abc" rx="5" style="" class="basic label-container"></rect><g transform="translate(-25.0078125, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="50.015625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Output</p></span></div></foreignObject></g></g></g></g></g></svg><section class="chapter"><h5 id="6-4-1-input-iterators" data-toc="6-4-1-input-iterators">6.4.1 Input Iterators</h5><p id="ntmcv5_528">For sequential, single-pass input.</p><p id="ntmcv5_529">Read only, i.e. can only be dereferenced on <span id="ntmcv5_532"><font style="color:#ff4500">right</font></span> side of expression.</p><p id="ntmcv5_530"><span id="ntmcv5_533"><font style="color:#8a2be2">Example:</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="vector&lt;int&gt;::iterator iter = myVector.begin();">
                        vector&lt;int&gt;::iterator iter = myVector.begin();
                        int val = *iter;
                    </div></section><section class="chapter"><h5 id="6-4-2-output-iterators" data-toc="6-4-2-output-iterators">6.4.2 Output Iterators</h5><p id="ntmcv5_534">For sequential, single-pass output.</p><p id="ntmcv5_535">Read only, i.e. can only be dereferenced on <span id="ntmcv5_538"><font style="color:#ff4500">left</font></span> side of expression.</p><p id="ntmcv5_536"><span id="ntmcv5_539"><font style="color:#8a2be2">Example:</font></span></p><div class="code-block" data-lang="cpp">
                        vector&lt;int&gt;::iterator iter = myVector.begin();
                        *iter = 5;
                    </div></section><section class="chapter"><h5 id="6-4-3-forward-iterators" data-toc="6-4-3-forward-iterators">6.4.3 Forward Iterators</h5><p id="ntmcv5_540">Combines input and output, plus can make multiple passes.</p><p id="ntmcv5_541">Can read from and write to (if not const iterator).</p><p id="ntmcv5_542"><span id="ntmcv5_544"><font style="color:#8a2be2">Example:</font></span></p><div class="code-block" data-lang="cpp">
                        // multiple passes
                        vector&lt;int&gt;::iterator iter1 = myVector.begin();
                        vector&lt;int&gt;::iterator iter2 = myVector.begin();
                        iter1++;
                        iter2++;
                        if (iter1 == iter2) { cout &lt;&lt; &quot;Equal&quot; &lt;&lt; endl; } // Equal
                    </div></section><section class="chapter"><h5 id="6-4-4-bidirectional-iterators" data-toc="6-4-4-bidirectional-iterators">6.4.4 Bidirectional Iterators</h5><p id="ntmcv5_545">Same as forward iterators, plus can go backwards with the decrement operator (--).</p><p id="ntmcv5_546"><span id="ntmcv5_547"><font style="color:#8a2be2">Use cases:</font></span> <code class="code" id="ntmcv5_548">std::map</code>, <code class="code" id="ntmcv5_549">std::set</code>, <code class="code" id="ntmcv5_550">std::list</code></p></section><section class="chapter"><h5 id="6-4-5-random-access-iterators" data-toc="6-4-5-random-access-iterators">6.4.5 Random Access Iterators</h5><p id="ntmcv5_551">Same as bidirectional iterators, plus can be implemented or decremented by arbitrary amounts using + and -.</p><p id="ntmcv5_552"><span id="ntmcv5_553"><font style="color:#8a2be2">Use cases:</font></span> <code class="code" id="ntmcv5_554">std::vector</code>, <code class="code" id="ntmcv5_555">std::deque</code>, <code class="code" id="ntmcv5_556">std::string</code></p></section></section></section><section class="chapter"><h3 id="7-templates" data-toc="7-templates">7 Templates</h3><p id="ntmcv5_557">We can use templates to keep the logic, but change the type!</p><section class="chapter"><h4 id="7-1-template-functions" data-toc="7-1-template-functions">7.1 Template Functions</h4><p id="ntmcv5_560"><span id="ntmcv5_572"><font style="color:#cd5c5c">Example</font></span></p><div class="code-block" data-lang="cpp">
                    template &lt;typename T&gt;
                    std::pair&lt;T, T&gt; my_minmax(T a, T b) {
                        if (a &lt; b) return {a, b};
                        else return {b, a};
                    }
                </div><p id="ntmcv5_562">The following code:</p><div class="code-block" data-lang="cpp">
                    my_minmax(cout, cout);
                </div><p id="ntmcv5_564"><span id="ntmcv5_573"><font style="color:#ff00ff">Semantic error:</font></span> you can't call operator &lt; on two streams.</p><p id="ntmcv5_565"><span id="ntmcv5_574"><font style="color:#ff00ff">Conceptual error:</font></span> you can't find the min or max of two streams.</p><p id="ntmcv5_566">The compiler deduces the types and literally replaces the types. Compiler will produce semantic errors, not conceptual error.</p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="template &lt;typename Collection, typename DataType&gt;">
                    template &lt;typename Collection, typename DataType&gt;
                    int countOccurences(const Collection&amp; list, DataType val) {
                        int count = 0;
                        for (size_t i = 0; i &lt; list.size(); ++i) {
                            if (list[i] == val) ++count;
                        }
                        return count;
                    }
                </div><p id="ntmcv5_568">Problem lies in indexing <code class="code" id="ntmcv5_575">list[i]</code>.</p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="template &lt;typename Collection, typename DataType&gt;">
                    template &lt;typename Collection, typename DataType&gt;
                    int countOccurences(const Collection&amp; list, DataType val) {
                        int count = 0;
                        for (auto iter = list.begin(); iter != list.end(); ++iter) {
                            if (*iter == val) ++count;
                        }
                        return count;
                    }
                </div><p id="ntmcv5_570">Or:</p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="template &lt;typename Collection, typename DataType&gt;">
                    template &lt;typename Collection, typename DataType&gt;
                    int countOccurences(const Collection&amp; collection, const DataType&amp; val) {
                        int count = 0;
                        for (const auto&amp; element : collection) {
                            if (element == val) {
                                ++count;
                            }
                        }
                        return count;
                    }
                </div></section><section class="chapter"><h4 id="7-2-template-classes" data-toc="7-2-template-classes">7.2 Template Classes</h4><section class="procedure-steps"><h3 id="template-class" data-toc="template-class">Template Class</h3><ol class="list _decimal"><li class="list__item" id="ntmcv5_577"><p id="ntmcv5_581">Add template declaration for class</p></li><li class="list__item" id="ntmcv5_578"><p id="ntmcv5_582">Add all the member type aliases</p></li><li class="list__item" id="ntmcv5_579"><p id="ntmcv5_583">Add the template declaration to every single class member</p></li><li class="list__item" id="ntmcv5_580"><p id="ntmcv5_584">Move everything to the .h file =&gt; separate compilation template classes are not classes themselves</p></li></ol></section></section></section><section class="chapter"><h3 id="8-functions-and-algorithms" data-toc="8-functions-and-algorithms">8 Functions and Algorithms</h3><section class="chapter"><h4 id="Lambda" data-toc="Lambda">8.1 Lambda Functions</h4><div class="code-block" data-lang="cpp">
                    auto isLessThanLimit = [limit](auto val) -&gt; bool {
                        return val &lt; limit;
                    };
                </div><ul class="list _bullet" id="ntmcv5_588"><li class="list__item" id="ntmcv5_596"><p id="ntmcv5_600"><code class="code" id="ntmcv5_601">auto</code>: We don't know the type, ask compiler.</p></li><li class="list__item" id="ntmcv5_597"><p id="ntmcv5_602"><code class="code" id="ntmcv5_603">[limit]</code>: Capture clause, gives access to outside variables.</p></li><li class="list__item" id="ntmcv5_598"><p id="ntmcv5_604"><code class="code" id="ntmcv5_605">(auto)</code>: Parameter list, can use auto!</p></li><li class="list__item" id="ntmcv5_599"><p id="ntmcv5_606"><code class="code" id="ntmcv5_607">-&gt; bool</code>: Return type, optional.</p></li></ul><p id="ntmcv5_589">Two types of capture clause: By reference or by value.</p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="// capture all by value, except teas is by reference">
                    // capture all by value, except teas is by reference
                    auto func1 = [=, &amp;teas](parameters) -&gt; return-value {
                    // body
                    };
                    
                    // capture all by reference, except banned is by value
                    auto func2 = [&amp;, banned](parameters) -&gt; return-value {
                    // body
                    };
                </div><aside class="prompt" data-type="tip" data-title="" id="ntmcv5_591"><p id="ntmcv5_608"><code class="code" id="ntmcv5_613">std::function&lt;R(Args&hellip;)&gt;</code> is a generic wrapper for all things callable.</p><div class="code-block" data-lang="cpp">
                        int add(int a, int b) {
                            return a + b;
                        }
                        
                        int main() {
                            std::function&lt;int(int, int)&gt; func; // initially empty
                            func = add; // Assign a regular function
                            std::cout &lt;&lt; func(2, 3) &lt;&lt; std::endl; // Output: 5
                            func = [](int a, int b) { return a * b; }; // Reassign a lambda
                            std::cout &lt;&lt; func(2, 3) &lt;&lt; std::endl; // Output: 6
                            return 0;
                        }
                    </div><p id="ntmcv5_610">In this context, <code class="code" id="ntmcv5_614">std::function&lt;int(int, int)&gt;</code> can store any callable object as long as it matches the signature.</p><p id="ntmcv5_611"><span id="ntmcv5_615"><font style="color:#8a2be2">Benefit:</font></span></p><ol class="list _alpha-lower" id="ntmcv5_612" type="a"><li class="list__item" id="ntmcv5_616"><p id="ntmcv5_618"><span id="ntmcv5_619"><font style="color:#ff00ff">Type Erasure for Flexibility:</font></span> It lets you work with different callable objects through a common interface. You can pass <code class="code" id="ntmcv5_620">std::function</code> objects to functions or store them in data structures without knowing the exact type of the underlying callable.</p></li><li class="list__item" id="ntmcv5_617"><p id="ntmcv5_621"><span id="ntmcv5_622"><font style="color:#ff00ff">Enables Polymorphism with Callables:</font></span> You can have a function that accepts a std::function as a parameter, allowing it to work with different lambda functions or other callable types at runtime.</p></li></ol></aside><p id="ntmcv5_592"><code class="code" id="ntmcv5_623">std::bind</code> adapts existing function objects to create new ones with specific argument values pre-filled.</p><div class="code-block" data-lang="cpp">
                    int multiplyAndAdd(int a, int b, int c) {
                        return (a * b) + c;
                    }
                    
                    int main() {
                        auto operation = std::bind(multiplyAndAdd, std::placeholders::_1,
                        std::placeholders::_2, 4);
                        std::cout &lt;&lt; operation(2, 3) &lt;&lt; std::endl; // Output: 10 ((2*3) + 4)
                    }
                </div><ul class="list _bullet" id="ntmcv5_594"><li class="list__item" id="ntmcv5_624"><p id="ntmcv5_627"><code class="code" id="ntmcv5_628">std::placeholders::_1</code> means &quot;take the first argument passed to operation&quot;.</p></li><li class="list__item" id="ntmcv5_625"><p id="ntmcv5_629"><code class="code" id="ntmcv5_630">std::placeholders::_2</code> means &quot;take the second argument passed to operation&quot;.</p></li><li class="list__item" id="ntmcv5_626"><p id="ntmcv5_631">4 is the third argument of <code class="code" id="ntmcv5_632">multiplyAndAdd</code>.</p></li></ul><aside class="prompt" data-type="warning" data-title="" id="ntmcv5_595"><p id="ntmcv5_633">Lambdas provide a convenient and expressive way to define objects that behave like functions. =&gt; Lambdas are a type of function object.</p></aside></section><section class="chapter"><h4 id="8-2-algorithms" data-toc="8-2-algorithms">8.2 Algorithms</h4><section class="chapter"><h5 id="8-2-1-std-sort" data-toc="8-2-1-std-sort">8.2.1 std::sort</h5><p id="ntmcv5_639"><span id="ntmcv5_647"><font style="color:#8a2be2">Syntax:</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="#include &lt;algorithm&gt; // Required header">
                        #include &lt;algorithm&gt; // Required header
                        
                        // 1. Basic Usage (Sorting using &lt; operator)
                        template &lt;class RandomAccessIterator&gt;
                        void sort(RandomAccessIterator first, RandomAccessIterator last);
                        
                        // 2. Custom Comparison Function
                        template &lt;class RandomAccessIterator, class Compare&gt;
                        void sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);
                    </div><p id="ntmcv5_641"><span id="ntmcv5_648"><font style="color:#8a2be2">Example:</font></span></p><div class="code-block" data-lang="cpp">
                        std::vector&lt;int&gt; numbers = {3, 1, 4, 1, 5};
                        std::sort(numbers.begin(), numbers.end()); // Sort the entire vector
                        
                        std::sort(numbers.begin(), numbers.end(), std::greater&lt;int&gt;()); // Sort in descending order
                    </div><p id="ntmcv5_643"><span id="ntmcv5_649"><font style="color:#8a2be2">Parameters:</font></span></p><ol class="list _decimal" id="ntmcv5_644" type="1"><li class="list__item" id="ntmcv5_650"><p id="ntmcv5_653"><span id="ntmcv5_654"><font style="color:#ff00ff">first (iterator):</font></span> An iterator pointing to the beginning of the range you want to sort.</p></li><li class="list__item" id="ntmcv5_651"><p id="ntmcv5_655"><span id="ntmcv5_656"><font style="color:#ff00ff">last (iterator):</font></span> An iterator pointing to one position past the end of the range to be sorted.</p></li><li class="list__item" id="ntmcv5_652"><p id="ntmcv5_657"><span id="ntmcv5_658"><font style="color:#ff00ff">comp (comparison function) (optional):</font></span> A binary function (takes two arguments) that defines the sorting criterion. It should return true if the first argument should come before the second in the sorted order, and false otherwise.</p></li></ol><p id="ntmcv5_645"><span id="ntmcv5_659"><font style="color:#8a2be2">Important notes:</font></span></p><ul class="list _bullet" id="ntmcv5_646"><li class="list__item" id="ntmcv5_660"><p id="ntmcv5_663">You can sort a portion of the entire vector, array, etc.</p><div class="code-block" data-lang="cpp">
                                std::vector&lt;int&gt; data = {5, 2, 8, 1, 9, 3};
                                std::sort(data.begin(), data.begin() + 4); // Result: data = {1, 2, 5, 8, 9, 3}
                            </div></li><li class="list__item" id="ntmcv5_661"><p id="ntmcv5_665">You can overload operator &lt; to define default sorting behavior.</p><div class="code-block" data-lang="cpp">
                                struct Item {
                                    int id;
                                    std::string name;
                                };
                                
                                // Stable Comparison
                                bool compareByNameStable(const Item&amp; a, const Item&amp; b) {
                                    if (a.name == b.name) {
                                        return a.id &lt; b.id; // Keep original order based on 'id' if names are equal
                                    }
                                    return a.name &lt; b.name;
                                }
                                
                                int main() {
                                    std::vector&lt;Item&gt; items = {
                                        {1, &quot;Apple&quot;},
                                        {2, &quot;Banana&quot;},
                                        {3, &quot;Apple&quot;}
                                    };
                                    std::sort(items.begin(), items.end(), compareByNameStable);
                                }
                            </div></li><li class="list__item" id="ntmcv5_662"><p id="ntmcv5_667"><span id="ntmcv5_668"><font style="color:#ff00ff">Average case:</font></span> <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.15ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4928.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mi" transform="translate(2206.7,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(3484.7,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mi" transform="translate(3651.3,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(4539.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p></li></ul></section><section class="chapter"><h5 id="8-2-2-std-nth-element" data-toc="8-2-2-std-nth-element">8.2.2 std::nth_element</h5><p id="ntmcv5_670"><span id="ntmcv5_678"><font style="color:#8a2be2">Syntax:</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="#include &lt;algorithm&gt;">
                        #include &lt;algorithm&gt;
                        
                        template &lt;class RandomAccessIterator&gt;
                        void nth_element (RandomAccessIterator first, RandomAccessIterator nth,
                        RandomAccessIterator last);
                        
                        // Optional: You can provide a custom comparison function
                        template &lt;class RandomAccessIterator, class Compare&gt;
                        void nth_element (RandomAccessIterator first, RandomAccessIterator nth,
                        RandomAccessIterator last, Compare comp);
                    </div><p id="ntmcv5_672"><span id="ntmcv5_679"><font style="color:#8a2be2">Example:</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="std::vector&lt;int&gt; numbers = {5, 2, 8, 1, 9, 3};">
                        std::vector&lt;int&gt; numbers = {5, 2, 8, 1, 9, 3};
                        
                        std::nth_element(numbers.begin(), numbers.begin() + 2, numbers.end());
                        // Output: 2 1 3 8 9 5 (The element at index 2 is now '3',
                        // which is the 3rd smallest, but the rest are not sorted)
                    </div><p id="ntmcv5_674"><span id="ntmcv5_680"><font style="color:#8a2be2">Parameters:</font></span></p><ol class="list _decimal" id="ntmcv5_675" type="1"><li class="list__item" id="ntmcv5_681"><p id="ntmcv5_685"><span id="ntmcv5_686"><font style="color:#ff00ff">first:</font></span> Iterator to the beginning of the range.</p></li><li class="list__item" id="ntmcv5_682"><p id="ntmcv5_687"><span id="ntmcv5_688"><font style="color:#ff00ff">nth:</font></span> Iterator pointing to the position you want the nth element to be placed in.</p></li><li class="list__item" id="ntmcv5_683"><p id="ntmcv5_689"><span id="ntmcv5_690"><font style="color:#ff00ff">last:</font></span> Iterator to one past the end of the range.</p></li><li class="list__item" id="ntmcv5_684"><p id="ntmcv5_691"><span id="ntmcv5_692"><font style="color:#ff00ff">comp (optional):</font></span> A binary comparison function, similar to std::sort.</p></li></ol><p id="ntmcv5_676"><span id="ntmcv5_693"><font style="color:#8a2be2">Important notes:</font></span></p><ul class="list _bullet" id="ntmcv5_677"><li class="list__item" id="ntmcv5_694"><p id="ntmcv5_697">With this, you can efficiently find the median of a dataset without fully sorting it, or determine the <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.878ex" height="1.956ex" role="img" focusable="false" viewBox="0 -853.7 1272.2 864.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="TeXAtom" transform="translate(554,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mtext"><path data-c="74" d="M27 422Q80 426 109 478T141 600V615H181V431H316V385H181V241Q182 116 182 100T189 68Q203 29 238 29Q282 29 292 100Q293 108 293 146V181H333V146V134Q333 57 291 17Q264 -10 221 -10Q187 -10 162 2T124 33T105 68T98 100Q97 107 97 248V385H18V422H27Z"></path><path data-c="68" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 124T102 167T103 217T103 272T103 329Q103 366 103 407T103 482T102 542T102 586T102 603Q99 622 88 628T43 637H25V660Q25 683 27 683L37 684Q47 685 66 686T103 688Q120 689 140 690T170 693T181 694H184V367Q244 442 328 442Q451 442 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(389,0)"></path></g></g></g></g></g></svg></mjx-container> smallest or largest element.</p></li><li class="list__item" id="ntmcv5_695"><p id="ntmcv5_699">It sorts so <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="3.057ex" height="1.956ex" role="img" focusable="false" viewBox="0 -853.7 1351.2 864.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="TeXAtom" transform="translate(633,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mtext"><path data-c="74" d="M27 422Q80 426 109 478T141 600V615H181V431H316V385H181V241Q182 116 182 100T189 68Q203 29 238 29Q282 29 292 100Q293 108 293 146V181H333V146V134Q333 57 291 17Q264 -10 221 -10Q187 -10 162 2T124 33T105 68T98 100Q97 107 97 248V385H18V422H27Z"></path><path data-c="68" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 124T102 167T103 217T103 272T103 329Q103 366 103 407T103 482T102 542T102 586T102 603Q99 622 88 628T43 637H25V660Q25 683 27 683L37 684Q47 685 66 686T103 688Q120 689 140 690T170 693T181 694H184V367Q244 442 328 442Q451 442 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(389,0)"></path></g></g></g></g></g></svg></mjx-container> element is in correct position, and all elements smaller to left, larger to right, but the elements before the <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="3.057ex" height="1.956ex" role="img" focusable="false" viewBox="0 -853.7 1351.2 864.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="TeXAtom" transform="translate(633,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mtext"><path data-c="74" d="M27 422Q80 426 109 478T141 600V615H181V431H316V385H181V241Q182 116 182 100T189 68Q203 29 238 29Q282 29 292 100Q293 108 293 146V181H333V146V134Q333 57 291 17Q264 -10 221 -10Q187 -10 162 2T124 33T105 68T98 100Q97 107 97 248V385H18V422H27Z"></path><path data-c="68" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 124T102 167T103 217T103 272T103 329Q103 366 103 407T103 482T102 542T102 586T102 603Q99 622 88 628T43 637H25V660Q25 683 27 683L37 684Q47 685 66 686T103 688Q120 689 140 690T170 693T181 694H184V367Q244 442 328 442Q451 442 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(389,0)"></path></g></g></g></g></g></svg></mjx-container> element are not guaranteed to be sorted among themselves, and neither are the elements after it.</p></li><li class="list__item" id="ntmcv5_696"><p id="ntmcv5_702"><span id="ntmcv5_703"><font style="color:#ff00ff">Average case:</font></span> <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.495ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2429 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(2040,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p></li></ul></section><section class="chapter"><h5 id="8-2-3-std-stable-partition" data-toc="8-2-3-std-stable-partition">8.2.3 std::stable_partition</h5><p id="ntmcv5_705"><span id="ntmcv5_711"><font style="color:#8a2be2">Syntax:</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="#include &lt;algorithm&gt; // Required header">
                        #include &lt;algorithm&gt; // Required header
                        
                        template &lt;class BidirectionalIterator, class UnaryPredicate&gt;
                        BidirectionalIterator stable_partition (BidirectionalIterator first,
                        BidirectionalIterator last,
                        UnaryPredicate pred);
                    </div><p id="ntmcv5_707"><span id="ntmcv5_712"><font style="color:#8a2be2">Parameters:</font></span></p><ol class="list _decimal" id="ntmcv5_708" type="1"><li class="list__item" id="ntmcv5_713"><p id="ntmcv5_719"><span id="ntmcv5_720"><font style="color:#ff00ff">BidirectionalIterator:</font></span> A template parameter indicating the type of iterators used. These iterators must support bidirectional movement (like those from std::list, std::vector, std::deque).</p></li><li class="list__item" id="ntmcv5_714"><p id="ntmcv5_721"><span id="ntmcv5_722"><font style="color:#ff00ff">first (BidirectionalIterator):</font></span> An iterator to the beginning of the range you want to partition.</p></li><li class="list__item" id="ntmcv5_715"><p id="ntmcv5_723"><span id="ntmcv5_724"><font style="color:#ff00ff">last (BidirectionalIterator):</font></span> An iterator to one past the end of the range to be partitioned.</p></li><li class="list__item" id="ntmcv5_716"><p id="ntmcv5_725"><span id="ntmcv5_726"><font style="color:#ff00ff">UnaryPredicate:</font></span> A template parameter representing the type of the predicate function.</p></li><li class="list__item" id="ntmcv5_717"><p id="ntmcv5_727"><span id="ntmcv5_728"><font style="color:#ff00ff">pred (UnaryPredicate):</font></span> A function that takes a single argument (an element from the range) and returns a bool:</p></li><li class="list__item" id="ntmcv5_718"><ul class="list _bullet" id="ntmcv5_729"><li class="list__item" id="ntmcv5_730"><p id="ntmcv5_732">true: The element satisfies the partitioning criterion.</p></li><li class="list__item" id="ntmcv5_731"><p id="ntmcv5_733">false: The element does not satisfy the criterion.</p></li></ul></li></ol><p id="ntmcv5_709"><span id="ntmcv5_734"><font style="color:#8a2be2">Example:</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="#include &lt;iostream&gt;">
                        #include &lt;iostream&gt;
                        #include &lt;vector&gt;
                        #include &lt;algorithm&gt;
                        #include &lt;string&gt;
                        
                        // A simple struct to represent a course (you can customize this)
                        struct Course {
                            std::string name;
                        };
                        
                        int main() {
                            // Sample course data
                            std::vector&lt;Course&gt; courses = {
                                {&quot;CS101&quot;},
                                {&quot;MATH101&quot;},
                                {&quot;CS202&quot;},
                                {&quot;PHYS101&quot;},
                                {&quot;CS301&quot;}
                            };

                            std::string dep = &quot;CS&quot;;

                            // Lambda function to check if a course belongs to the &quot;CS&quot; department
                            auto isDep = [dep](const Course&amp; course) {
                                return course.name.size() &gt;= dep.size() &amp;&amp;
                                course.name.substr(0, dep.size()) == dep;
                            };

                            // Partition the courses vector, keeping &quot;CS&quot; courses at the beginning
                            auto iter = std::stable_partition(courses.begin(), courses.end(), isDep);

                            // Remove non-&quot;CS&quot; courses
                            courses.erase(iter, courses.end());

                            // Output the remaining &quot;CS&quot; courses
                            std::cout &lt;&lt; &quot;CS Courses:\n&quot;;
                            for (const Course&amp; course : courses) {
                                std::cout &lt;&lt; course.name &lt;&lt; std::endl;
                            }

                            return 0;
                        }
                    </div></section><section class="chapter"><h5 id="8-2-4-std-copy-if" data-toc="8-2-4-std-copy-if">8.2.4 std::copy_if</h5><p id="ntmcv5_735"><span id="ntmcv5_740"><font style="color:#8a2be2">Syntax:</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="#include &lt;algorithm&gt; // Required header">
                        #include &lt;algorithm&gt; // Required header
                        
                        template &lt;class InputIterator, class OutputIterator, class UnaryPredicate&gt;
                        OutputIterator copy_if (InputIterator first, InputIterator last,
                        OutputIterator result, UnaryPredicate pred);
                    </div><ol class="list _decimal" id="ntmcv5_737" type="1"><li class="list__item" id="ntmcv5_741"><p id="ntmcv5_749"><span id="ntmcv5_750"><font style="color:#ff00ff">InputIterator:</font></span> Type of iterator used for the input range.</p></li><li class="list__item" id="ntmcv5_742"><p id="ntmcv5_751"><span id="ntmcv5_752"><font style="color:#ff00ff">OutputIterator:</font></span> Type of iterator used for the output range (where copied elements go).</p></li><li class="list__item" id="ntmcv5_743"><p id="ntmcv5_753"><span id="ntmcv5_754"><font style="color:#ff00ff">first (InputIterator):</font></span> An iterator to the beginning of the input range.</p></li><li class="list__item" id="ntmcv5_744"><p id="ntmcv5_755"><span id="ntmcv5_756"><font style="color:#ff00ff">last (InputIterator):</font></span> An iterator to one past the end of the input range.</p></li><li class="list__item" id="ntmcv5_745"><p id="ntmcv5_757"><span id="ntmcv5_758"><font style="color:#ff00ff">result (OutputIterator):</font></span> An iterator to the beginning of the output range.</p></li><li class="list__item" id="ntmcv5_746"><p id="ntmcv5_759"><span id="ntmcv5_760"><font style="color:#ff00ff">UnaryPredicate:</font></span> Type of the predicate function.</p></li><li class="list__item" id="ntmcv5_747"><p id="ntmcv5_761"><span id="ntmcv5_762"><font style="color:#ff00ff">pred (UnaryPredicate):</font></span> A function that takes a single argument (an element from the input range) and returns:</p></li><li class="list__item" id="ntmcv5_748"><ul class="list _bullet" id="ntmcv5_763"><li class="list__item" id="ntmcv5_764"><p id="ntmcv5_766">true: Copy the element to the output range.</p></li><li class="list__item" id="ntmcv5_765"><p id="ntmcv5_767">false: Skip the element.</p></li></ul></li></ol><p id="ntmcv5_738"><span id="ntmcv5_768"><font style="color:#8a2be2">Example:</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="#include &lt;iostream&gt;">
                        #include &lt;iostream&gt;
                        #include &lt;vector&gt;
                        #include &lt;algorithm&gt;
                        #include &lt;string&gt;
                        
                        struct Course {
                            std::string name;
                        };
                        
                        int main() {
                            std::vector&lt;Course&gt; csCourses = {
                                {&quot;CS101&quot;},
                                {&quot;MATH101&quot;},
                                {&quot;CS202&quot;},
                                {&quot;PHYS101&quot;},
                                {&quot;CS301&quot;}
                            };

                            std::vector&lt;Course&gt; filteredCourses;
                            std::string dep = &quot;CS&quot;;

                            auto isDep = [dep](const Course&amp; course) {
                                return course.name.size() &gt;= dep.size() &amp;&amp;
                                course.name.substr(0, dep.size()) == dep;
                            };

                            // Copy matching courses to 'filteredCourses'
                            // Use back_inserter to add more space!
                            std::copy_if(csCourses.begin(), csCourses.end(),
                            std::back_inserter(filteredCourses), isDep);

                            std::cout &lt;&lt; &quot;Filtered CS Courses:\n&quot;;
                            for (const Course&amp; course : filteredCourses) {
                                std::cout &lt;&lt; course.name &lt;&lt; std::endl;
                            }

                            return 0;
                        }
                    </div></section><section class="chapter"><h5 id="8-2-5-std-remove-if" data-toc="8-2-5-std-remove-if">8.2.5 std::remove_if</h5><p id="ntmcv5_769"><span id="ntmcv5_772"><font style="color:#8a2be2">Syntax:</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="#include &lt;algorithm&gt; // Required header">
                        #include &lt;algorithm&gt; // Required header
                        
                        template &lt;class ForwardIterator, class UnaryPredicate&gt;
                        ForwardIterator remove_if (ForwardIterator first, ForwardIterator last,
                        UnaryPredicate pred);
                    </div><ol class="list _decimal" id="ntmcv5_771" type="1"><li class="list__item" id="ntmcv5_773"><p id="ntmcv5_779"><span id="ntmcv5_780"><font style="color:#ff00ff">ForwardIterator:</font></span> Type of iterator used for the range. Must support forward movement.</p></li><li class="list__item" id="ntmcv5_774"><p id="ntmcv5_781"><span id="ntmcv5_782"><font style="color:#ff00ff">first (ForwardIterator):</font></span> An iterator to the beginning of the range.</p></li><li class="list__item" id="ntmcv5_775"><p id="ntmcv5_783"><span id="ntmcv5_784"><font style="color:#ff00ff">last (ForwardIterator):</font></span> An iterator to one past the end of the range.</p></li><li class="list__item" id="ntmcv5_776"><p id="ntmcv5_785"><span id="ntmcv5_786"><font style="color:#ff00ff">UnaryPredicate:</font></span> Type of the predicate function.</p></li><li class="list__item" id="ntmcv5_777"><p id="ntmcv5_787"><span id="ntmcv5_788"><font style="color:#ff00ff">pred (UnaryPredicate):</font></span> A function that takes a single argument (an element from the range) and returns:</p></li><li class="list__item" id="ntmcv5_778"><ul class="list _bullet" id="ntmcv5_789"><li class="list__item" id="ntmcv5_790"><p id="ntmcv5_792">true: The element should be &quot;removed.&quot;</p></li><li class="list__item" id="ntmcv5_791"><p id="ntmcv5_793">false: The element should be kept.</p></li></ul></li></ol></section></section></section></section><section class="chapter"><h2 id="object" data-toc="object">Ⅲ Object-Oriented Programming</h2><section class="chapter"><h3 id="9-classes-and-consts" data-toc="9-classes-and-consts">9 Classes and Consts</h3><section class="chapter"><h4 id="9-1-classes" data-toc="9-1-classes">9.1 Classes</h4><p id="ntmcv5_802"><span id="ntmcv5_813"><font style="color:#8a2be2">Definitions:</font></span></p><ul class="list _bullet" id="ntmcv5_803"><li class="list__item" id="ntmcv5_814"><p id="ntmcv5_822"><span id="ntmcv5_823"><font style="color:#ff8c00">Class:</font></span> a template for a new type of objects, defines how objects of a particular type behave.</p></li><li class="list__item" id="ntmcv5_815"><p id="ntmcv5_824"><span id="ntmcv5_825"><font style="color:#ff8c00">Object:</font></span> Entity that combines state and behavior, instance of a class.</p></li><li class="list__item" id="ntmcv5_816"><p id="ntmcv5_826"><span id="ntmcv5_827"><font style="color:#ff8c00">Member variables (instance variables, fields):</font></span> Define state inside each object.</p></li><li class="list__item" id="ntmcv5_817"><p id="ntmcv5_828"><span id="ntmcv5_829"><font style="color:#ff8c00">Member functions (methods):</font></span> Define behavior inside each object.</p></li><li class="list__item" id="ntmcv5_818"><p id="ntmcv5_830"><span id="ntmcv5_831"><font style="color:#ff8c00">Constructor:</font></span> Initializes the state of newly created objects.</p></li><li class="list__item" id="ntmcv5_819"><p id="ntmcv5_832"><span id="ntmcv5_834"><font style="color:#ff8c00">Destructor:</font></span> Called when the object is deleted by the program.</p><ul class="list _bullet" id="ntmcv5_833"><li class="list__item" id="ntmcv5_835"><p id="ntmcv5_837">Delete any pointers stored as private members.</p></li><li class="list__item" id="ntmcv5_836"><p id="ntmcv5_838">delete[] any arrays stored as private members.</p></li></ul></li><li class="list__item" id="ntmcv5_820"><p id="ntmcv5_839"><span id="ntmcv5_840"><font style="color:#ff8c00">Client code:</font></span> Code that uses the objects defind.</p></li><li class="list__item" id="ntmcv5_821"><p id="ntmcv5_841"><span id="ntmcv5_842"><font style="color:#ff8c00">Encapsulation:</font></span> Hiding implementation details from the client code.</p></li></ul><p id="ntmcv5_804">C++ separates classes into two kinds of files:</p><ul class="list _bullet" id="ntmcv5_805"><li class="list__item" id="ntmcv5_843"><p id="ntmcv5_845"><span id="ntmcv5_846"><font style="color:#ff00ff">Header File</font></span> (<span id="ntmcv5_847"><font style="color:#ff4500">.h</font></span>, .hh, .hpp): Containing the interface (declarations).</p></li><li class="list__item" id="ntmcv5_844"><p id="ntmcv5_848"><span id="ntmcv5_849"><font style="color:#ff00ff">Source File</font></span> (<span id="ntmcv5_850"><font style="color:#ff4500">.cpp</font></span>, .cc, .cxx, .c++, .C): Containing definitions (method bodies).</p></li></ul><p id="ntmcv5_806">Classes have <span id="ntmcv5_851"><font style="color:#ff4500">three</font></span> main parts:</p><ul class="list _bullet" id="ntmcv5_807"><li class="list__item" id="ntmcv5_852"><p id="ntmcv5_855"><span id="ntmcv5_856"><font style="color:#ff00ff">Constructor and destructor</font></span></p></li><li class="list__item" id="ntmcv5_853"><p id="ntmcv5_857"><span id="ntmcv5_858"><font style="color:#ff00ff">Member variables</font></span></p></li><li class="list__item" id="ntmcv5_854"><p id="ntmcv5_859"><span id="ntmcv5_860"><font style="color:#ff00ff">Member functions</font></span></p></li></ul><p id="ntmcv5_808"><span id="ntmcv5_861"><font style="color:#8a2be2">Example (header file):</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="// Protection in case multiple .cpp files include this header, so">
                    // Protection in case multiple .cpp files include this header, so
                    // that its contents won't get declared twice.
                    #ifndef MYCLASS_H
                    #define MYCLASS_H
                    
                    class MyClass {
                    public:
                        MyClass(); // Constructor
                        ~MyClass(); // Destructor
                        void myMethod(); // Member function (behavior inside each function)
                        int getMyVariable();
                    private:
                        int myVariable; // Member variable (data inside each object)
                    }; // Semicolons!
                    
                    #endif // MYCLASS_H
                </div><p id="ntmcv5_810"><span id="ntmcv5_862"><font style="color:#8a2be2">Example (source file):</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="#include &quot;MyClass.h&quot;">
                    #include &quot;MyClass.h&quot;
                    
                    MyClass::MyClass() {
                        myVariable = 0; // Initialize member variable
                    }
                    
                    void MyClass::myMethod() {
                        myVariable++;
                    }
                    
                    MyClass::~MyClass() {
                        // Simple destructor implementation
                    }
                    
                    int MyClass::getMyVariable() {
                        return myVariable;
                    }
                </div><aside class="prompt" data-type="note" data-title="" id="ntmcv5_812"><p id="ntmcv5_863">Why so many extensions?</p><p id="ntmcv5_864">Depend on the compilers!</p><ul class="list _bullet" id="ntmcv5_865"><li class="list__item" id="ntmcv5_866"><p id="ntmcv5_869">Historically, used .C</p></li><li class="list__item" id="ntmcv5_867"><p id="ntmcv5_870">Now, Unix most uses <span id="ntmcv5_871"><font style="color:#ff4500">.cc</font></span>, and outside Unix mostly uses <span id="ntmcv5_872"><font style="color:#ff4500">.cpp</font></span></p></li><li class="list__item" id="ntmcv5_868"><p id="ntmcv5_873">.h is technically for C programs, so if mixing C and C++ code, use .hh instead</p></li></ul></aside></section><section class="chapter"><h4 id="9-2-consts" data-toc="9-2-consts">9.2 Consts</h4><p id="ntmcv5_874"><span id="ntmcv5_883"><font style="color:#ff8c00">Consts:</font></span> A qualifier for objects that declares they cannot be modified.</p><p id="ntmcv5_875">Consts help us find bugs, and allow us to reason about whether a variable will be changed.</p><p id="ntmcv5_876">Within a function that takes a const parameter, you cannot call non-const member functions (if the parameter is an object) or modify the value (if it's a fundamental type or a pointer to const data) of that parameter.</p><p id="ntmcv5_877"><span id="ntmcv5_884"><font style="color:#8a2be2">Example for value:</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="int plus(const int& x) {">
                    int plus(const int&amp; x) {
                        return x + 1; // Error: x is const
                    }
                    
                    int plus(const int x) {
                        return x + 1; // OK: x is a copy
                    }
                </div><p id="ntmcv5_879"><span id="ntmcv5_885"><font style="color:#8a2be2">Example for member functions:</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="struct Planet {">
                    struct Planet {
                        int countPopulation() const;
                        void deathStar();
                    };
                    
                    int Planet::countPopulation() const {
                        return 42;
                    }
                    
                    void Planet::deathStar() {
                        std::cout &lt;&lt; &quot;BOOM&quot; &lt;&lt; std::endl;
                    }
                    
                    void evil(const Planet &amp;p) {
                        // OK: countPopulation is const
                        std::cout &lt;&lt; p.countPopulation() &lt;&lt; std::endl;
                        // ERROR: deathStar isn't const
                        p.deathStar();
                    }
                </div><section class="chapter"><h5 id="9-2-1-const-pointers" data-toc="9-2-1-const-pointers">9.2.1 Const Pointers</h5><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="// constant pointer to a non-constant int">
                        // constant pointer to a non-constant int
                        // (*p)++; OK!
                        // p++; NOT allowed!
                        int * const p;
                        
                        // non-constant pointer to a constant
                        int const int* p;
                        int const* p;
                        
                        // constant pointer to a constant
                        int const int* const p;
                        int const* const p;
                    </div><aside class="prompt" data-type="warning" data-title="" id="ntmcv5_887"><p id="ntmcv5_888">When in doubt, read from right to left!</p><p id="ntmcv5_889">You can't declare a non-const reference to a const variable!</p></aside></section><section class="chapter"><h5 id="9-2-2-const-iterators" data-toc="9-2-2-const-iterators">9.2.2 Const Iterators</h5><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="const vector&lt;int&gt;::iterator itr = v.begin();">
                        const vector&lt;int&gt;::iterator itr = v.begin();
                        *itr = 5; // OK! changing what itr points to
                        ++itr; // ERROR! can’t modify itr
                        
                        vector&lt;int&gt;::const_iterator itr = v.begin();
                        *itr = 5; //ERROR! can’t change value of itr
                        ++itr; //OK! changing v
                        int value = *itr; //OK! reading from itr
                    </div></section></section></section><section class="chapter"><h3 id="10-operators" data-toc="10-operators">10 Operators</h3><section class="chapter"><h4 id="10-1-basic-operators" data-toc="10-1-basic-operators">10.1 Basic Operators</h4><p id="ntmcv5_895">There are 40 (+4) operators you can overload!</p><figure id="ntmcv5_896"><img alt="Operators" src="Computer-Science-Study-Notes/c8-1.png" title="Operators" width="1899" height="1141"></figure><p id="ntmcv5_897"><span id="ntmcv5_901"><font style="color:#8a2be2">Examples for default operators behaviors:</font></span></p><div class="code-comparer" id="ntmcv5_898" data-comparing="horizontally"><div class="code-block" data-lang="cpp" data-title="Before">
                        std::vector&lt;std::string&gt; v{&quot;Hello&quot;, &quot;World&quot;};
                        std::cout &lt;&lt; v[0];
                        v[1] += &quot;!&quot;;
                    </div><div class="code-block" data-lang="cpp" data-title="After">
                        std::vector&lt;std::string&gt; v{&quot;Hello&quot;, &quot;World&quot;};
                        std::cout.operator &lt;&lt; (v.operator[](0).c_str());
                        v.operator[](1).operator += (&quot;!&quot;);
                    </div></div><p id="ntmcv5_899">In STL,</p><div class="code-block" data-lang="cpp">
                    ostream&amp; operator&lt;&lt;(ostream&amp; s, const string&amp; val) {
                        ...
                    }
                    
                    string&amp; vector&lt;string&gt;::operator[](size_t index) const {
                        ...
                    }
                </div></section><section class="chapter"><h4 id="10-2-operator-overloading" data-toc="10-2-operator-overloading">10.2 Operator Overloading</h4><p id="ntmcv5_904"><span id="ntmcv5_913"><font style="color:#8a2be2">General rule of Thumb:</font></span> (Member &amp; Non-Member)</p><ol class="list _decimal" id="ntmcv5_905" type="1"><li class="list__item" id="ntmcv5_914"><p>Some operators must be implemented as members (e.g., [], (), -&gt;, =) due to C++ semantics.</p></li><li class="list__item" id="ntmcv5_915"><p>Some must be implemented as non-members (eg. &lt;&lt;, if you are writing class for rhs, not lhs).</p></li><li class="list__item" id="ntmcv5_916"><p>If unary operator (eg. ++), implement as member.</p></li><li class="list__item" id="ntmcv5_917"><p>If binary operator and treats both operands equally (eg. both unchanged) implement as non-member (maybe friend). Examples: +, &lt; .</p></li><li class="list__item" id="ntmcv5_918"><p>If binary operator and not both equally (changes lhs), implement as member (allows easy access to lhs private members). Examples: +=</p></li></ol><aside class="prompt" data-type="tip" data-title="" id="ntmcv5_906"><ol class="list _decimal" id="ntmcv5_919" type="1"><li class="list__item" id="ntmcv5_920"><p>Always think about const-ness of parameters.</p></li><li class="list__item" id="ntmcv5_921"><p>Return reference to support chaining &lt;&lt; calls.</p></li><li class="list__item" id="ntmcv5_922"><p>Here we are overloading &lt;&lt; so our class works as the rhs... but we can't change the class of lhs (stream library).</p></li></ol></aside><p id="ntmcv5_907"><span id="ntmcv5_923"><font style="color:#cd5c5c">Examples</font></span></p><p id="ntmcv5_908"><span id="ntmcv5_924"><font style="color:#ff00ff">Member Function:</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="#include &lt;iostream&gt;">
                    #include &lt;iostream&gt;
                    
                    class MyClass {
                    private:
                        int data[10];
                    public:
                        // Subscript operator ([])
                        int&amp; operator[](int index) {
                            return data[index];
                        }
                    
                        // Function call operator ()
                        int operator()(int a, int b) {
                            return data[a] + data[b];
                        }
                    
                        // Assignment operator (=)
                        MyClass&amp; operator=(const MyClass&amp; other) {
                            if (this != &amp;other) { // Avoid self-assignment
                                for (int i = 0; i &lt; 10; ++i) {
                                    data[i] = other.data[i];
                                }
                            }
                            return *this;
                        }
                    };
                    
                    int main() {
                        MyClass obj;
                        obj[2] = 5; // Using the subscript operator
                        obj[3] = 10; // Using the subscript operator
                        int sum = obj(2, 3); // Using the function call operator
                        std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sum &lt;&lt; std::endl;

                        MyClass obj2;
                        obj2 = obj; // Using the assignment operator
                        return 0;
                    }
                </div><p id="ntmcv5_910"><span id="ntmcv5_925"><font style="color:#ff00ff">Non-Member Function:</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="#include &lt;iostream&gt;">
                    #include &lt;iostream&gt;
                    
                    class Point {
                    private:
                        int x, y;
                    public:
                        Point(int xVal, int yVal) : x(xVal), y(yVal) {}
                    
                        // Friend declaration for the output stream operator
                        friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Point&amp; p);
                        };
                    
                        // Non-member output stream operator (&lt;&lt;)
                        std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Point&amp; p) {
                            out &lt;&lt; &quot;(&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;;
                            return out;
                        }
                    };
                    
                    int main() {
                        Point p(5, 10);
                        std::cout &lt;&lt; &quot;Point coordinates: &quot; &lt;&lt; p &lt;&lt; std::endl; // Using the overloaded &lt;&lt;
                        return 0;
                    }
                </div><aside class="prompt" data-type="note" data-title="" id="ntmcv5_912"><p id="ntmcv5_926">Declare non-member functions as friends of a class to give them access to private members.</p></aside></section><section class="chapter"><h4 id="10-3-principle-of-least-astonishment-pola" data-toc="10-3-principle-of-least-astonishment-pola">10.3 Principle of Least Astonishment (POLA)</h4><p id="ntmcv5_927"><span id="ntmcv5_929"><font style="color:#8a2be2">From the C++ Core Guidelines (section C ):</font></span></p><ul class="list _bullet" id="ntmcv5_928"><li class="list__item" id="ntmcv5_930"><p id="ntmcv5_934">Design operators primarily to mimic conventional usage.</p></li><li class="list__item" id="ntmcv5_931"><p id="ntmcv5_935">Use nonmember functions for symmetric operators.</p></li><li class="list__item" id="ntmcv5_932"><p id="ntmcv5_936">Use nonmember functions for symmetric operators.</p><ul class="list _bullet" id="ntmcv5_937"><li class="list__item" id="ntmcv5_938"><p id="ntmcv5_943">Compound operators return reference to *this</p></li><li class="list__item" id="ntmcv5_939"><p id="ntmcv5_944">Arithmetic operators return copies</p></li><li class="list__item" id="ntmcv5_940"><p id="ntmcv5_945">In/decrement prefix vs. postfix rules</p></li><li class="list__item" id="ntmcv5_941"><p id="ntmcv5_946">Indexing requires const and non-const versions</p></li><li class="list__item" id="ntmcv5_942"><p id="ntmcv5_947">Look at the C++ reference for common patterns!</p></li></ul></li><li class="list__item" id="ntmcv5_933"><p>Always provide all out of a set of related operators.</p></li></ul></section><section class="chapter"><h4 id="10-4-interesting-operators" data-toc="10-4-interesting-operators">10.4 Interesting Operators</h4><p id="ntmcv5_948"><span id="ntmcv5_952"><font style="color:#8a2be2">Advanced Multithreading Support (C++ 20) :</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="awaiter operator co_await() const noexcept {">
                    awaiter operator co_await() const noexcept {
                        return awaiter{ *this };
                    }
                </div><p id="ntmcv5_950"><span id="ntmcv5_953"><font style="color:#8a2be2">Spaceship operator (C++20):</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="std::strong_ordering operator&lt;=&gt; (const Time& rhs) {">
                    std::strong_ordering operator&lt;=&gt; (const Time&amp; rhs) {
                        return hour &lt;=&gt; rhs.hour;
                    }
                </div></section></section><section class="chapter"><h3 id="11-special-member-functions" data-toc="11-special-member-functions">11 Special Member Functions</h3><p id="ntmcv5_954"><span id="ntmcv5_965"><font style="color:#8a2be2">Six types of special member functions:</font></span></p><p id="ntmcv5_955">Every class has them by default.</p><p id="ntmcv5_956">These functions are generated only when they're called (and before any are explicitly defined by you):</p><ul class="list _bullet" id="ntmcv5_957"><li class="list__item" id="ntmcv5_966"><p id="ntmcv5_972"><span id="ntmcv5_973"><font style="color:#ff00ff">Default constructor:</font></span> Takes no parameters and creates a new object.</p></li><li class="list__item" id="ntmcv5_967"><p id="ntmcv5_974"><span id="ntmcv5_975"><font style="color:#ff00ff">Destructor:</font></span> Called when an object goes out of scope.</p></li><li class="list__item" id="ntmcv5_968"><p id="ntmcv5_976"><span id="ntmcv5_977"><font style="color:#ff00ff">Copy constructor:</font></span> Creates a <span id="ntmcv5_978"><u>new object</u></span> as a member-wise copy of another.</p></li><li class="list__item" id="ntmcv5_969"><p id="ntmcv5_979"><span id="ntmcv5_980"><font style="color:#ff00ff">Copy assignment operator:</font></span> Assigns an <span id="ntmcv5_981"><u>already existing object</u></span> to another.</p></li><li class="list__item" id="ntmcv5_970"><p id="ntmcv5_982">Move constructor</p></li><li class="list__item" id="ntmcv5_971"><p id="ntmcv5_983">Move assignment operator</p></li></ul><p id="ntmcv5_958"><span id="ntmcv5_984"><font style="color:#8a2be2">Example:</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="MyVector&lt;int&gt; function(MyVector&lt;int&gt; vec0) { // copy constructor">
                MyVector&lt;int&gt; function(MyVector&lt;int&gt; vec0) { // copy constructor
                MyVector&lt;int&gt; vec1; // default constructor
                MyVector&lt;int&gt; vec2{3, 4, 5}; // initializer list constructor
                MyVector&lt;int&gt; vec3(); // function declaration - C++’s most vexing parse
                MyVector&lt;int&gt; vec4(vec2); // copy constructor
                MyVector&lt;int&gt; vec5{}; // default constructor
                MyVector&lt;int&gt; vec6{vec3 + vec4}; // move constructor
                MyVector&lt;int&gt; vec7 = vec4; // copy constructor
                vec7 = vec2; // copy assignment operator
                return vec7; // move constructor
            </div><aside class="prompt" data-type="note" data-title="" id="ntmcv5_960"><p id="ntmcv5_985">About the return value:</p><ol class="list _decimal" id="ntmcv5_986" type="1"><li class="list__item" id="ntmcv5_987"><p id="ntmcv5_989"><span id="ntmcv5_990"><font style="color:#ff00ff">Return Value Optimization (RVO):</font></span> The compiler is allowed to optimize away the copy/move entirely and construct vec7 directly in the location where the return value will be placed. This eliminates any copying or moving.</p></li><li class="list__item" id="ntmcv5_988"><p id="ntmcv5_991"><span id="ntmcv5_992"><font style="color:#ff00ff">Move Semantics:</font></span> If RVO is not applicable (e.g., due to complex control flow or compiler limitations ), the compiler will prefer to use the move constructor because vec7 is a local variable that is going out of scope. This means its resources can be &quot;moved&quot; to the return value efficiently, rather than copying them.</p></li></ol></aside><section class="chapter"><h4 id="11-1-copy-constructor-copy-assignment-operator" data-toc="11-1-copy-constructor-copy-assignment-operator">11.1 Copy Constructor &amp; Copy Assignment Operator</h4><p id="ntmcv5_993">By default, the copy constructor will create copies of each member variable.</p><p id="ntmcv5_994"><span id="ntmcv5_1002"><font style="color:#cd5c5c">Examples</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="/** Problem with the following code:">
                    /** Problem with the following code:
                    * When the vectors go out of scope, their destructor tries to free the array.
                    */
                    IntVector operator+(const IntVector &amp; vec, int elem) {
                        IntVector copy = vec; // default copy constructor, copy a pointer to the same array
                        copy += element;
                        return copy;
                    }
                </div><figure id="ntmcv5_996"><img alt="Copy Constructor" src="Computer-Science-Study-Notes/c11-1.png" title="Copy Constructor" width="8192" height="4698"></figure><aside class="prompt" data-type="note" data-title="" id="ntmcv5_997"><p id="ntmcv5_1003">When the vectors go out of scope, their destructor tries to free the array.</p></aside><p id="ntmcv5_998"><span id="ntmcv5_1004"><font style="color:#8a2be2">Copy constructor:</font></span></p><ul class="list _bullet" id="ntmcv5_999"><li class="list__item" id="ntmcv5_1005"><p id="ntmcv5_1007">Use initializer list to copy members where assignment does the correct thing. e.g., int, other objects, etc.</p></li><li class="list__item" id="ntmcv5_1006"><p id="ntmcv5_1008">Deep copy all members where assignment does not work. e.g., pointers to heap memory.</p></li></ul><p id="ntmcv5_1000"><span id="ntmcv5_1009"><font style="color:#8a2be2">Copy assignment operator:</font></span></p><ul class="list _bullet" id="ntmcv5_1001"><li class="list__item" id="ntmcv5_1010"><p id="ntmcv5_1013">Clean up any resources in the existing object about to be overwritten.</p></li><li class="list__item" id="ntmcv5_1011"><p id="ntmcv5_1014">Copy members using initializer list when assignment works.</p></li><li class="list__item" id="ntmcv5_1012"><p id="ntmcv5_1015">Deep copy members where assignment does not work.</p></li></ul></section><section class="chapter"><h4 id="11-2-delete-operations" data-toc="11-2-delete-operations">11.2 Delete Operations</h4><p id="ntmcv5_1016">Setting a special member function to delete removes its functionality.</p><p id="ntmcv5_1017">We can also keep the default copy constructor if we declare other constructors.</p><p id="ntmcv5_1018"><span id="ntmcv5_1020"><font style="color:#cd5c5c">Examples</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="#include &lt;iostream&gt;">
                    #include &lt;iostream&gt;
                    
                    class NonCopyable {
                    public:
                        NonCopyable() = default; // Default constructor
                    
                        NonCopyable(const NonCopyable&amp;) = delete; // Delete copy constructor
                        NonCopyable&amp; operator=(const NonCopyable&amp;) = delete; // Delete copy assignment
                    
                        NonCopyable(NonCopyable&amp;&amp;) = default; // Default move constructor
                        NonCopyable&amp; operator=(NonCopyable&amp;&amp;) = default; // Default move assignment
                    
                        void print() { std::cout &lt;&lt; &quot;NonCopyable object&quot; &lt;&lt; std::endl; }
                    };
                    
                    int main() {
                        NonCopyable obj1;
                        obj1.print();

                        NonCopyable obj2 = std::move(obj1); // Move construction is allowed
                        obj2.print();

                        // NonCopyable obj3 = obj2; // Error: Copy construction is deleted
                        // obj1 = obj2; // Error: Copy assignment is deleted

                        return 0;
                    }
                </div></section><section class="chapter"><h4 id="11-3-rule-of-zero-three" data-toc="11-3-rule-of-zero-three">11.3 Rule of Zero/Three</h4><p id="ntmcv5_1021"><span id="ntmcv5_1026"><font style="color:#8a2be2">Rule of Zero:</font></span> If the default operations work, don't define your own custom ones!</p><p id="ntmcv5_1022">When the default one generated by the compiler does not work, you need to write your own special member functions.</p><p id="ntmcv5_1023">Most common reason: ownership issues. A member is a handle on a resource outside of the class (e.g., pointers, mutexes, filestreams) .</p><p id="ntmcv5_1024"><span id="ntmcv5_1027"><font style="color:#8a2be2">Rule of Three:</font></span> If you explicitly define (or delete) a copy constructor, copy assignment, or destructor, you should define (or delete) all three.</p><aside class="prompt" data-type="note" data-title="" id="ntmcv5_1025"><p id="ntmcv5_1028">The fact that you defined one of these means one of your members has ownership issues that need to be resolved.</p></aside></section><section class="chapter"><h4 id="11-4-copy-elision-and-return-value-optimization-rvo" data-toc="11-4-copy-elision-and-return-value-optimization-rvo">11.4 Copy Elision and Return Value Optimization (RVO)</h4><p id="ntmcv5_1029"><span id="ntmcv5_1032"><font style="color:#cd5c5c">Examples</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="int main() {">
                    int main() {
                        StringVector words;
                        words = findAllWords(“words.txt”); // print words
                    }
                    
                    StringVector findAllWords(const string&amp; filename) {
                        StringVector words;
                        // read from filename using an ifstream
                        return words;
                    }
                </div><figure id="ntmcv5_1031"><img alt="RVO" src="Computer-Science-Study-Notes/c11-2.png" title="RVO" width="2667" height="1500"></figure></section></section><section class="chapter"><h3 id="12-move-semantics" data-toc="12-move-semantics">12 Move Semantics</h3><section class="chapter"><h4 id="12-1-lvalues-rvalues" data-toc="12-1-lvalues-rvalues">12.1 lvalues &amp; rvalues</h4><p id="ntmcv5_1035"><span id="ntmcv5_1043"><font style="color:#8a2be2">Definitions</font></span></p><ul class="list _bullet" id="ntmcv5_1036"><li class="list__item" id="ntmcv5_1044"><p id="ntmcv5_1046"><span id="ntmcv5_1047"><font style="color:#ff8c00">lvalue:</font></span> An l-value is an expression that has a name (identity).</p></li><li class="list__item" id="ntmcv5_1045"><p id="ntmcv5_1048"><span id="ntmcv5_1049"><font style="color:#ff8c00">rvalue:</font></span> An r-value is an expression that does not have a name (identity).</p></li></ul><div class="table-wrapper"><table class="left_header wide" id="ntmcv5_1037"><thead><tr class="ijRowHead" id="ntmcv5_1050"><th id="ntmcv5_1056"></th><th id="ntmcv5_1057"><p>l-value</p></th><th id="ntmcv5_1058"><p>r-value</p></th></tr></thead><tbody><tr id="ntmcv5_1051"><th id="ntmcv5_1059"><p>Find address using address-of operator (&amp;var)</p></th><td id="ntmcv5_1060"><p>Yes</p></td><td id="ntmcv5_1061"><p>No</p></td></tr><tr id="ntmcv5_1052"><th id="ntmcv5_1062"><p>Intuitive Definition</p></th><td id="ntmcv5_1063"><p>Can appear either left or right of an assignment *</p></td><td id="ntmcv5_1064"><p>Can appear only on the right of an assignment *</p></td></tr><tr id="ntmcv5_1053"><th id="ntmcv5_1065"><p>Lifetime</p></th><td id="ntmcv5_1066"><p>Decided by scope</p></td><td id="ntmcv5_1067"><p>Ends on the very next line (unless you purposely extend it!)</p></td></tr><tr id="ntmcv5_1054"><th id="ntmcv5_1068" rowspan="2"><p>Value References</p></th><td id="ntmcv5_1069"><p id="ntmcv5_1071">An <span id="ntmcv5_1073"><font style="color:#ff4500">l-value</font></span> reference can bind to an l-value.</p><div class="code-block" data-lang="cpp">
                                auto&amp; ptr2 = (ptr += 3);
                            </div></td><td id="ntmcv5_1070"><p id="ntmcv5_1074">An <span id="ntmcv5_1076"><font style="color:#ff4500">r-value</font></span> reference can bind to an r-value.</p><div class="code-block" data-lang="cpp">
                                auto&amp;&amp; v4 = v1 + v2;
                            </div></td></tr><tr id="ntmcv5_1055"><th id="ntmcv5_1077" colspan="2"><p id="ntmcv5_1078">A <span id="ntmcv5_1080"><font style="color:#dda0dd">const</font></span> <span id="ntmcv5_1081"><font style="color:#ff4500">l-value</font></span> reference can bind to either l or r-value.</p><div class="code-block" data-lang="cpp">
                                const auto&amp; ptr2 = (ptr += 3);
                                const auto&amp; v4 = v1 + v2;
                            </div></th></tr></tbody></table></div><aside class="prompt" data-type="note" data-title="" id="ntmcv5_1038"><p id="ntmcv5_1082">*: This was technically the definition until 2011. Technically there are these weird things called gl-values, pr-values, x-values, ...</p></aside><p id="ntmcv5_1039"><span id="ntmcv5_1083"><font style="color:#cd5c5c">Examples</font></span></p><div class="code-collapse" data-lang="cpp" data-is-expanded="false" data-synopsis="int val = 2; // val: lvalue, 2: rvalue">
                    int val = 2; // val: lvalue, 2: rvalue
                    int* ptr = &amp;val; // ptr: lvalue, &amp;val: rvalue
                    std::vector&lt;int&gt; v1{1, 2, 3}; // v1: lvalue, {1, 2, 3}: rvalue
                    
                    auto v4 = v1 + v2; // v4: lvalue, v1 + v2: rvalue =&gt; + returns a copy to a temporary
                    size_t size = v1.size(); // size: lvalue, v1.size(): rvalue
                    val = static_cast&lt;int&gt;(size); // val: lvalue, static_cast&lt;int&gt;(size): rvalue
                    // cast returns a copy of size
                </div><aside class="prompt" data-type="warning" data-title="" id="ntmcv5_1041"><p id="ntmcv5_1084">An r-value reference is an alias to an r-value</p><p id="ntmcv5_1085">BUT the r-value reference itself is an l-value</p></aside><figure id="ntmcv5_1042"><img alt="Value References" src="Computer-Science-Study-Notes/c12-1.png" title="Value References" width="2340" height="609"></figure></section><section class="chapter"><h4 id="12-2-move-semantics" data-toc="12-2-move-semantics">12.2 Move Semantics</h4></section></section><section class="chapter"><h3 id="inheritance" data-toc="inheritance">13 Inheritance</h3><section class="chapter"><h4 id="13-1-namespace" data-toc="13-1-namespace">13.1 Namespace</h4><p id="ntmcv5_1089"><span id="ntmcv5_1094"><font style="color:#ff8c00">Namespace:</font></span> Namespace is an abstract container or environment created to hold a logical grouping of unique identifiers or symbols (i.e. names).</p><p id="ntmcv5_1090"><span id="ntmcv5_1095"><font style="color:#8a2be2">Goal:</font></span> To resolve identifier clash. The same identifier can be independently defined in multiple namespaces. That is, an identifier defined in one namespace may or may not have the same meaning as the same identifier defined in another namespace.</p><aside class="prompt" data-type="tip" data-title="" id="ntmcv5_1091"><p id="ntmcv5_1096">Here is an analogy from Wikipedia:</p><p id="ntmcv5_1097">Imagine that two companies, X and Y, each assign ID numbers to their employees. X should not have two employees with the same ID number, and likewise for Y; but it is not a problem for the same ID number to be used at both companies. For example, if Bill works for company X and Jane works for company Y, then it is not a problem for each of them to be employee #123.</p></aside><p id="ntmcv5_1092"><span id="ntmcv5_1098"><font style="color:#8a2be2">Most modern languages use namespaces to fix this.</font></span></p><div class="tabs" id="ntmcv5_1093" data-anchors="[c,java,javascript,python]"><div class="tabs__content" data-gtm="tab" id="c" data-title="C++"><div class="code-collapse" data-lang="cpp" data-title="C++" data-is-expanded="false" data-synopsis="#include &lt;iostream&gt;">
                            #include &lt;iostream&gt;
                            #include &lt;vector&gt;
                            
                            int main() {
                                std::vector&lt;int&gt; v = {1, 2, 3}; // std:: is namespace
                                for (int i : v) {
                                    std::cout &lt;&lt; i &lt;&lt; std::endl;
                                }
                                return 0;
                            }
                        </div></div><div class="tabs__content" data-gtm="tab" id="python" data-title="Python"><div class="code-block" data-lang="python" data-title="Python">
                            import numpy as np
                            
                            a = np.array([1, 2, 3]) // np. is namespace
                        </div></div><div class="tabs__content" data-gtm="tab" id="java" data-title="Java"><div class="code-collapse" data-lang="java" data-title="Java" data-is-expanded="false" data-synopsis="import java.util.ArrayList; // Java packages before identifier">
                            import java.util.ArrayList; // Java packages before identifier
                            
                            public class Main {
                                public static void main(String[] args) {
                                    ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
                                    list.add(1);
                                    list.add(2);
                                    list.add(3);
                                    for (int i : list) {
                                        System.out.println(i);
                                    }
                                }
                            }
                        </div></div><div class="tabs__content" data-gtm="tab" id="javascript" data-title="JavaScript"><div class="code-block" data-lang="javascript" data-title="JavaScript">
                            const fs = require('fs');
                            
                            const data = fs.readFileSync('file.txt', 'utf8'); // fs. is namespace
                        </div></div></div></section><section class="chapter"><h4 id="13-1-overriding-and-overloading" data-toc="13-1-overriding-and-overloading">13.1 Overriding and Overloading</h4><p id="ntmcv5_1107"><span id="ntmcv5_1117"><font style="color:#8a2be2">Definition:</font></span></p><ul class="list _bullet" id="ntmcv5_1108"><li class="list__item" id="ntmcv5_1118"><p id="ntmcv5_1120"><span id="ntmcv5_1121"><font style="color:#ff8c00">Overloading</font></span>: Methods with the same name but different signature.</p></li><li class="list__item" id="ntmcv5_1119"><p id="ntmcv5_1122"><span id="ntmcv5_1123"><font style="color:#ff8c00">Overriding</font></span>: A subclass to provide a specific implementation of a method that is already provided by its parent class or interface.</p></li></ul><aside class="prompt" data-type="note" data-title="" id="ntmcv5_1109"><p id="ntmcv5_1124">This is an implementation of overloading in the same class.</p></aside><div class="code-collapse" data-lang="java" data-is-expanded="false" data-synopsis="// part of code from Quicksort">
                    // part of code from Quicksort
                    public static void sort(Comparable[] a) {
                        sort(a, 0, a.length - 1);
                    }
                    
                    private static void sort(Comparable[] a, int lo, int hi) {
                        if (hi &lt;= lo) return;
                        int j = partition(a, lo, hi);
                        sort(a, lo, j - 1);
                        sort(a, j + 1, hi);
                    }
                </div><aside class="prompt" data-type="note" data-title="" id="ntmcv5_1111"><p id="ntmcv5_1125">This is an implementation of overloading in different classes.</p></aside><div class="code-collapse" data-lang="java" data-is-expanded="false" data-synopsis="class Shape {">
                    class Shape {
                        public void calculateArea(int side) {
                            System.out.println(&quot;Area of a square: &quot; + (side * side));
                        }
                    }
                    
                    class Rectangle extends Shape {
                        public void calculateArea(int length, int width) {
                            System.out.println(&quot;Area of a rectangle: &quot; + (length * width));
                        }
                    }
                    
                    public class Main {
                    public static void main(String[] args) {
                    Rectangle myRectangle = new Rectangle();
                    
                    myRectangle.calculateArea(5); // Calls Shape's calculateArea (inherited)
                    myRectangle.calculateArea(4, 6); // Calls Rectangle's calculateArea (overloaded)
                    }
                    }
                </div><aside class="prompt" data-type="note" data-title="" id="ntmcv5_1113"><p id="ntmcv5_1126">This is an implementation of overriding.</p></aside><div class="code-collapse" data-lang="java" data-is-expanded="false" data-synopsis="interface Animal {">
                    interface Animal {
                        void makeSound(); // Abstract method declaration
                    }
                    
                    class Dog implements Animal { // Implementing the interface
                        @Override
                        public void makeSound() {
                            System.out.println(&quot;Woof!&quot;);
                        }
                    }
                    
                    class Cat implements Animal { // Implementing the interface
                        @Override
                        public void makeSound() {
                            System.out.println(&quot;Meow!&quot;);
                        }
                    }
                    
                    public class Main {
                        public static void main(String[] args) {
                            Animal myDog = new Dog();
                            Animal myCat = new Cat();

                            myDog.makeSound(); // Output: Woof!
                            myCat.makeSound(); // Output: Meow!
                        }
                    }
                </div><aside class="prompt" data-type="note" data-title="" id="ntmcv5_1115"><p id="ntmcv5_1127">To look up a name in a class:</p><ul class="list _bullet" id="ntmcv5_1128"><li class="list__item" id="ntmcv5_1129"><p id="ntmcv5_1131">If it names an attribute in the class, return the attribute value.</p></li><li class="list__item" id="ntmcv5_1130"><p id="ntmcv5_1132">Otherwise, look up the name in the base class, if there is one.</p></li></ul></aside><aside class="prompt" data-type="tip" data-title="" id="ntmcv5_1116"><p id="ntmcv5_1133">For Java, better use <code class="code" id="ntmcv5_1136">@Override</code>!</p><p id="ntmcv5_1134"><span id="ntmcv5_1137"><font style="color:#8a2be2">Reasons:</font></span></p><ul class="list _bullet" id="ntmcv5_1135"><li class="list__item" id="ntmcv5_1138"><p id="ntmcv5_1140"><span id="ntmcv5_1141"><font style="color:#ff00ff">Protect against typos:</font></span> If you say <code class="code" id="ntmcv5_1142">@Override</code>, but the method isn't actually overriding anything, you will get a compile error.</p></li><li class="list__item" id="ntmcv5_1139"><p id="ntmcv5_1143"><span id="ntmcv5_1144"><font style="color:#ff00ff">Reminder:</font></span> Reminds programmer that method definition came from somewhere higher up in the inheritance hierarchy.</p></li></ul></aside></section><section class="chapter"><h4 id="13-2-types-of-inheritance" data-toc="13-2-types-of-inheritance">13.2 Types of Inheritance</h4><p id="ntmcv5_1145"><span id="ntmcv5_1155"><font style="color:#8a2be2">Interface Inheritance:</font></span></p><p id="ntmcv5_1146">Specifying the capabilities of a subclass.</p><ul class="list _bullet" id="ntmcv5_1147"><li class="list__item" id="ntmcv5_1156"><p id="ntmcv5_1158"><span id="ntmcv5_1159"><font style="color:#ff8c00">Interface:</font></span> The list of all method signatures.</p></li><li class="list__item" id="ntmcv5_1157"><p id="ntmcv5_1160">Specifies what the subclass can do, but not how.</p></li></ul><p id="ntmcv5_1148"><span id="ntmcv5_1161"><font style="color:#cd5c5c">Examples</font></span></p><div class="tabs" id="ntmcv5_1149" data-anchors="[c-circle-h,c-shape-h,c-square-h]"><div class="tabs__content" data-gtm="tab" id="c-shape-h" data-title="C++ (Shape.h)"><div class="code-collapse" data-lang="cpp" data-title="C++" data-is-expanded="false" data-synopsis="#ifndef SHAPE_H">
                            #ifndef SHAPE_H
                            #define SHAPE_H
                            
                            class Shape {
                            public:
                                virtual void draw() const = 0; // Pure virtual function
                                virtual ~Shape() = default; // Virtual destructor
                            };
                            
                            #endif //SHAPE_H
                        </div></div><div class="tabs__content" data-gtm="tab" id="c-circle-h" data-title="C++ (Circle.h)"><div class="code-collapse" data-lang="cpp" data-title="C++" data-is-expanded="false" data-synopsis="#ifndef CIRCLE_H">
                            #ifndef CIRCLE_H
                            #define CIRCLE_H
                            
                            #include &quot;Shape.h&quot;
                            #include &lt;iostream&gt;
                            
                            class Circle final : public Shape {
                            public:
                                void draw() const override {
                                    std::cout &lt;&lt; &quot;Drawing Circle&quot; &lt;&lt; std::endl;
                                }
                            };
                            
                            #endif //CIRCLE_H
                        </div></div><div class="tabs__content" data-gtm="tab" id="c-square-h" data-title="C++ (Square.h)"><div class="code-collapse" data-lang="cpp" data-title="C++" data-is-expanded="false" data-synopsis="#ifndef SQUARE_H">
                            #ifndef SQUARE_H
                            #define SQUARE_H
                            
                            #include &quot;Shape.h&quot;
                            #include &lt;iostream&gt;
                            
                            class Square final : public Shape {
                            public:
                                void draw() const override {
                                    std::cout &lt;&lt; &quot;Drawing Square&quot; &lt;&lt; std::endl;
                                }
                            };
                            
                            #endif //SQUARE_H
                        </div></div></div><div class="tabs" id="ntmcv5_1150" data-anchors="[java-circle-java,java-shape-java]"><div class="tabs__content" data-gtm="tab" id="java-shape-java" data-title="Java (Shape.java)"><div class="code-collapse" data-lang="java" data-title="Java" data-is-expanded="false" data-synopsis="public interface Shape {">
                            public interface Shape {
                                double getArea();
                                double getPerimeter();
                                String toString();
                            }
                        </div></div><div class="tabs__content" data-gtm="tab" id="java-circle-java" data-title="Java (Circle.java)"><div class="code-collapse" data-lang="java" data-title="Java" data-is-expanded="false" data-synopsis="public class Circle implements Shape {">
                            public class Circle implements Shape {
                                private final double radius;

                                public Circle(double radius) {
                                    this.radius = radius;
                                }

                                public double getArea() {
                                    return Math.PI * radius * radius;
                                }

                                public double getPerimeter() {
                                    return 2 * Math.PI * radius;
                                }

                                public String toString() {
                                    return &quot;Circle with radius &quot; + radius;
                                }
                            }
                        </div></div></div><p id="ntmcv5_1151"><span id="ntmcv5_1172"><font style="color:#ff8c00">Implementation Inheritance:</font></span> Subclasses can inherit signatures AND implementation.</p><p id="ntmcv5_1152"><span id="ntmcv5_1173"><font style="color:#cd5c5c">Examples</font></span></p><div class="tabs" id="ntmcv5_1153" data-anchors="[c-animal-h,c-dog-h]"><div class="tabs__content" data-gtm="tab" id="c-animal-h" data-title="C++ (Animal.h)"><div class="code-collapse" data-lang="cpp" data-title="C++" data-is-expanded="false" data-synopsis="#ifndef ANIMAL_H">
                            #ifndef ANIMAL_H
                            #define ANIMAL_H
                            
                            #include &lt;iostream&gt;
                            
                            class Animal {
                            public:
                                virtual void makeSound() const {
                                    std::cout &lt;&lt; &quot;Generic animal sound&quot; &lt;&lt; std::endl;
                                }
                                virtual ~Animal() = default;
                            };
                            
                            #endif //ANIMAL_H
                        </div></div><div class="tabs__content" data-gtm="tab" id="c-dog-h" data-title="C++ (Dog.h)"><div class="code-collapse" data-lang="cpp" data-title="C++" data-is-expanded="false" data-synopsis="#ifndef DOG_H">
                            #ifndef DOG_H
                            #define DOG_H
                            
                            #include &quot;Animal.h&quot;
                            #include &lt;iostream&gt;
                            
                            class Dog final : public Animal {
                            public:
                                void makeSound() const override {
                                    std::cout &lt;&lt; &quot;Bark&quot; &lt;&lt; std::endl;
                                }
                            };
                            
                            #endif //DOG_H
                        </div></div></div><div class="code-collapse" data-lang="java" data-is-expanded="false" data-synopsis="interface Animal {">
                    interface Animal {
                        default void makeSound() {
                            System.out.println(&quot;Generic animal sound&quot;);
                        }
                    
                        void eat();
                        }
                    
                        class Dog implements Animal {
                            @Override
                            public void eat() {
                                System.out.println(&quot;Dog is eating&quot;);
                            }
                        }
                    
                        class Cat implements Animal {
                            @Override
                            public void eat() {
                                System.out.println(&quot;Cat is eating&quot;);
                            }
                    
                            @Override
                            public void makeSound() {
                                System.out.println(&quot;Meow!&quot;);
                            }
                        }
                    
                    public class Main {
                        public static void main(String[] args) {
                            Dog myDog = new Dog();
                            Cat myCat = new Cat();

                            myDog.makeSound(); // Output: Generic animal sound (using default)
                            myDog.eat(); // Output: Dog is eating

                            myCat.makeSound(); // Output: Meow! (overridden)
                            myCat.eat(); // Output: Cat is eating
                        }
                    }
                </div></section></section></section><section class="chapter"><h2 id="modern-c" data-toc="modern-c">Ⅳ Modern C++</h2><section class="chapter"><h3 id="14-raii" data-toc="14-raii">14 RAII</h3></section></section><div class="last-modified">Last modified: 08 December 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="artificial-intelligence.html" class="navigation-links__prev">Artificial Intelligence</a><a href="computer-architecture.html" class="navigation-links__next">Computer Architecture</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b518/app.js"></script></body></html>